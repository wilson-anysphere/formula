const fs = require("node:fs/promises");
const path = require("node:path");
const { builtinModules } = require("node:module");

const esbuild = require("esbuild");

const GENERATED_BANNER = "// This file is generated by formula-extension-builder. Do not edit.\n";
const BROWSER_REQUIRE_SHIM = `import * as __formulaExtensionApi from "@formula/extension-api";\n` +
  `function require(specifier) {\n` +
  `  if (specifier === "@formula/extension-api" || specifier === "formula") return __formulaExtensionApi;\n` +
  `  throw new Error(\`External module "\${String(specifier)}" is not available in the browser extension sandbox\`);\n` +
  `}\n`;

const BUILTIN_MODULES = new Set([
  ...builtinModules,
  ...builtinModules.map((m) => (m.startsWith("node:") ? m : `node:${m}`)),
]);

const ALLOWED_EXTERNAL = new Set(["@formula/extension-api", "formula"]);

function isUrlLike(specifier) {
  // Anything with a scheme is considered a remote/URL-style import (including data:, http:, https:, etc).
  // Note that "node:" is handled separately as a builtin.
  return /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(specifier);
}

function prettyPath(p) {
  return path.relative(process.cwd(), p);
}

async function loadManifest(extensionDir) {
  const manifestPath = path.join(extensionDir, "package.json");
  const raw = await fs.readFile(manifestPath, "utf8").catch((error) => {
    if (error && error.code === "ENOENT") {
      throw new Error(`Missing extension manifest: ${prettyPath(manifestPath)}`);
    }
    throw error;
  });

  try {
    const manifest = JSON.parse(raw);
    if (!manifest || typeof manifest !== "object") throw new Error("Manifest must be an object");
    return { manifest, manifestPath, raw };
  } catch (error) {
    throw new Error(`Failed to parse ${prettyPath(manifestPath)}: ${error?.message ?? error}`);
  }
}

function resolveInsideExtension(extensionDir, relPath, fieldName) {
  const root = path.resolve(extensionDir);
  const targetRel = String(relPath);
  const targetAbs = path.resolve(root, targetRel);
  if (!targetAbs.startsWith(root + path.sep)) {
    throw new Error(`Manifest ${fieldName} must resolve inside extensionDir (got ${relPath})`);
  }
  return targetAbs;
}

async function fileExists(p) {
  try {
    const st = await fs.stat(p);
    return st.isFile();
  } catch {
    return false;
  }
}

async function resolveEntrypoint(extensionDir, manifest, explicitEntry) {
  if (explicitEntry) {
    const abs = resolveInsideExtension(extensionDir, explicitEntry, "--entry");
    if (!(await fileExists(abs))) {
      throw new Error(`Extension entrypoint not found: ${prettyPath(abs)}`);
    }
    return abs;
  }

  const candidates = [
    path.join(extensionDir, "src", "extension.ts"),
    path.join(extensionDir, "src", "extension.js"),
    path.join(extensionDir, "src", "index.ts"),
    path.join(extensionDir, "src", "index.js"),
    path.join(extensionDir, "extension.ts"),
    path.join(extensionDir, "extension.js"),
  ];

  for (const candidate of candidates) {
    if (await fileExists(candidate)) return candidate;
  }

  const hint = manifest?.main ? ` (manifest main=${manifest.main})` : "";
  throw new Error(
    `Failed to find an extension entrypoint. Expected one of: src/extension.{ts,js}, src/index.{ts,js}, extension.{ts,js}${hint}. ` +
      `Provide --entry <path>.`,
  );
}

function resolveOutputPaths(extensionDir, manifest) {
  const mainRel = typeof manifest.main === "string" && manifest.main.trim() ? manifest.main : "./dist/extension.js";

  const browserRel =
    typeof manifest.browser === "string" && manifest.browser.trim() ? manifest.browser : null;
  const moduleRel = typeof manifest.module === "string" && manifest.module.trim() ? manifest.module : null;
  /** @type {string[]} */
  const esmRels = [];
  if (browserRel && moduleRel) {
    if (browserRel === moduleRel) {
      esmRels.push(browserRel);
    } else {
      esmRels.push(browserRel, moduleRel);
    }
  } else if (browserRel) {
    esmRels.push(browserRel);
  } else if (moduleRel) {
    esmRels.push(moduleRel);
  } else {
    esmRels.push("./dist/extension.mjs");
  }
  const esmRel = esmRels[0];

  const cjsOutfile = resolveInsideExtension(extensionDir, mainRel, "main");
  const esmOutfiles = esmRels.map((rel) => {
    const fieldName =
      browserRel && rel === browserRel ? "browser" : moduleRel && rel === moduleRel ? "module" : "browser/module";
    return resolveInsideExtension(extensionDir, rel, fieldName);
  });

  return { mainRel, esmRel, esmRels, cjsOutfile, esmOutfiles };
}

function policyPlugin({ extensionDir, strict, warnings }) {
  return {
    name: "formula-extension-policy",
    setup(build) {
      build.onStart(() => {
        warnings.length = 0;
      });

      build.onResolve({ filter: /.*/ }, (args) => {
        const spec = args.path;

        // Entry points are provided by the builder itself and may be absolute paths.
        // The sandbox restriction is about *module specifiers* inside the extension code.
        if (args.kind === "entry-point") {
          return null;
        }

        if (spec === "formula") {
          // `formula` is an alias for `@formula/extension-api` in the Node host. Rewrite it to
          // the canonical specifier so the browser build (and docs) only need one import path.
          return { path: "@formula/extension-api", external: true };
        }

        if (ALLOWED_EXTERNAL.has(spec)) {
          return { path: spec, external: true };
        }

        if (BUILTIN_MODULES.has(spec)) {
          const msg = `Disallowed Node builtin import "${spec}" (runtime sandbox blocks builtins).`;
          if (strict) {
            return { errors: [{ text: msg }] };
          }
          warnings.push(msg);
          return { path: spec, external: true };
        }

        if (isUrlLike(spec)) {
          // url-like import ("http:", "https:", "data:", etc). "node:" handled above.
          return {
            errors: [
              {
                text: `Remote/URL imports are not allowed in extensions (got "${spec}").`,
              },
            ],
          };
        }

        if (spec.startsWith("/")) {
          return {
            errors: [
              {
                text: `Absolute imports are not allowed in extensions (got "${spec}"). Use a relative import instead.`,
              },
            ],
          };
        }

        // Let esbuild handle everything else (relative imports and build-time deps in node_modules).
        return null;
      });
    },
  };
}

function scanBundledOutput(code, { strict, label }) {
  /** @type {string[]} */
  const warnings = [];

  const dynamicImportRe = /\bimport\s*\(/;
  if (dynamicImportRe.test(code)) {
    throw new Error(`${label}: dynamic import() is not allowed in Formula extensions.`);
  }

  const evalRe = /\beval\b/;
  const newFunctionRe = /\bnew\s+Function\b/;
  if (evalRe.test(code) || newFunctionRe.test(code)) {
    const msg = `${label}: eval/new Function are disabled by the extension sandbox.`;
    if (strict) throw new Error(msg);
    warnings.push(msg);
  }

  return warnings;
}

function watchValidatePlugin({ extensionDir, outfile, strict, warnings }) {
  return {
    name: "formula-extension-watch-validate",
    setup(build) {
      build.onEnd(async (result) => {
        if (result.errors && result.errors.length > 0) return;
        const label = path.relative(extensionDir, outfile);

        for (const w of result.warnings || []) {
          // eslint-disable-next-line no-console
          console.error(`[formula-extension-builder] warning: ${w.text}`);
        }

        let code = "";
        try {
          code = await fs.readFile(outfile, "utf8");
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error(
            `[formula-extension-builder] error: failed to read ${label}: ${error?.message ?? error}`,
          );
          return;
        }

        try {
          const scanWarnings = scanBundledOutput(code, { strict, label });
          for (const warning of scanWarnings) {
            // eslint-disable-next-line no-console
            console.error(`[formula-extension-builder] warning: ${warning}`);
          }

          const externalImports = findExternalImports(result.metafile, outfile);
          validateExternalImports({ externalImports, strict, warnings, label });
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error(`[formula-extension-builder] error: ${error?.message ?? error}`);
          return;
        }

        for (const warning of warnings) {
          // eslint-disable-next-line no-console
          console.error(`[formula-extension-builder] warning: ${warning}`);
        }

        if (strict && ((result.warnings || []).length > 0 || warnings.length > 0)) {
          // eslint-disable-next-line no-console
          console.error(
            `[formula-extension-builder] error: build produced warnings in --strict mode (${label})`,
          );
        }
      });
    },
  };
}

function findExternalImports(metafile, outfile) {
  const outKey = path.resolve(outfile);
  const out = metafile?.outputs?.[outKey];
  const imports = Array.isArray(out?.imports) ? out.imports : [];
  return imports.filter((imp) => imp.external).map((imp) => imp.path);
}

function validateExternalImports({ externalImports, strict, warnings, label }) {
  for (const spec of externalImports) {
    if (ALLOWED_EXTERNAL.has(spec)) continue;
    if (BUILTIN_MODULES.has(spec)) {
      const msg = `${label}: external Node builtin import "${spec}" is not allowed by the runtime sandbox.`;
      if (strict) throw new Error(msg);
      warnings.push(msg);
      continue;
    }
    const msg = `${label}: external import "${spec}" would require node_modules at runtime (not allowed).`;
    if (strict) throw new Error(msg);
    warnings.push(msg);
  }
}

async function bundleOnce({
  extensionDir,
  entrypoint,
  outfile,
  format,
  platform,
  minify,
  sourcemap,
  strict,
  write,
}) {
  /** @type {string[]} */
  const warnings = [];

  const banner = format === "esm" ? GENERATED_BANNER + "\n" + BROWSER_REQUIRE_SHIM : GENERATED_BANNER;

  const options = {
    absWorkingDir: extensionDir,
    entryPoints: [entrypoint],
    bundle: true,
    format,
    platform,
    target: "es2020",
    outfile,
    sourcemap: sourcemap ? "external" : false,
    minify: Boolean(minify),
    banner: { js: banner },
    write,
    metafile: true,
    logLevel: "silent",
    plugins: [policyPlugin({ extensionDir, strict, warnings })],
  };

  /** @type {import("esbuild").BuildResult} */
  let result;
  try {
    result = await esbuild.build(options);
  } catch (error) {
    // Re-wrap esbuild errors so CLI output is readable.
    throw new Error(error?.message ?? String(error));
  }

  for (const w of result.warnings || []) {
    // eslint-disable-next-line no-console
    console.error(`[formula-extension-builder] warning: ${w.text}`);
  }

  if (!result.outputFiles || result.outputFiles.length === 0) {
    // When write=true outputFiles is undefined. We'll read the file from disk in that case.
  }

  let code;
  if (write) {
    code = await fs.readFile(outfile, "utf8");
  } else {
    const out = (result.outputFiles || []).find((f) => path.resolve(f.path) === path.resolve(outfile));
    if (!out) throw new Error(`esbuild did not return output for ${outfile}`);
    code = out.text;
  }

  const scanWarnings = scanBundledOutput(code, { strict, label: path.relative(extensionDir, outfile) });
  for (const warning of scanWarnings) {
    // eslint-disable-next-line no-console
    console.error(`[formula-extension-builder] warning: ${warning}`);
  }

  const externalImports = findExternalImports(result.metafile, outfile);
  validateExternalImports({
    externalImports,
    strict,
    warnings,
    label: path.relative(extensionDir, outfile),
  });

  // Print policy warnings (both from resolving imports and from validating the bundled output).
  for (const warning of warnings) {
    // eslint-disable-next-line no-console
    console.error(`[formula-extension-builder] warning: ${warning}`);
  }

  if (!strict) {
    // In non-strict mode we already printed warnings; nothing else to do.
    return { code };
  }

  // Strict mode: any warning emitted should fail the build.
  const allWarnings = [...warnings, ...scanWarnings, ...(result.warnings || []).map((w) => w.text)];
  if (allWarnings.length > 0) {
    throw new Error(`Build failed in --strict mode due to warnings:\n- ${allWarnings.join("\n- ")}`);
  }

  return { code };
}

async function maybeWriteManifest(manifestPath, manifest, { mainRel, esmRel }) {
  let changed = false;
  const next = { ...manifest };

  if (typeof next.main !== "string" || next.main.trim().length === 0) {
    next.main = mainRel;
    changed = true;
  }
  if (typeof next.module !== "string" || next.module.trim().length === 0) {
    next.module = esmRel;
    changed = true;
  }
  if (typeof next.browser !== "string" || next.browser.trim().length === 0) {
    next.browser = esmRel;
    changed = true;
  }

  if (!changed) return false;
  await fs.writeFile(manifestPath, JSON.stringify(next, null, 2) + "\n", "utf8");
  return true;
}

async function buildExtension(extensionDir, options = {}) {
  const resolved = path.resolve(extensionDir);
  const { manifest, manifestPath } = await loadManifest(resolved);

  const entrypoint = await resolveEntrypoint(resolved, manifest, options.entry);
  const outputs = resolveOutputPaths(resolved, manifest);

  if (options.writeManifest) {
    await maybeWriteManifest(manifestPath, manifest, outputs);
  }

  await fs.mkdir(path.dirname(outputs.cjsOutfile), { recursive: true });
  for (const out of new Set(outputs.esmOutfiles)) {
    await fs.mkdir(path.dirname(out), { recursive: true });
  }

  if (options.watch) {
    const warningsCjs = [];
    const esmContexts = [];
    const ctxCjs = await esbuild.context({
      absWorkingDir: resolved,
      entryPoints: [entrypoint],
      bundle: true,
      format: "cjs",
      platform: "node",
      target: "es2020",
      outfile: outputs.cjsOutfile,
      sourcemap: options.sourcemap ? "external" : false,
      minify: Boolean(options.minify),
      banner: { js: GENERATED_BANNER },
      metafile: true,
      logLevel: "silent",
      plugins: [
        policyPlugin({ extensionDir: resolved, strict: Boolean(options.strict), warnings: warningsCjs }),
        watchValidatePlugin({ extensionDir: resolved, outfile: outputs.cjsOutfile, strict: Boolean(options.strict), warnings: warningsCjs }),
      ],
    });

    await ctxCjs.watch();
    for (const esmOutfile of new Set(outputs.esmOutfiles)) {
      const warningsEsm = [];
      const ctx = await esbuild.context({
        absWorkingDir: resolved,
        entryPoints: [entrypoint],
        bundle: true,
        format: "esm",
        platform: "browser",
        target: "es2020",
        outfile: esmOutfile,
        sourcemap: options.sourcemap ? "external" : false,
        minify: Boolean(options.minify),
        banner: { js: GENERATED_BANNER + "\n" + BROWSER_REQUIRE_SHIM },
        metafile: true,
        logLevel: "silent",
        plugins: [
          policyPlugin({ extensionDir: resolved, strict: Boolean(options.strict), warnings: warningsEsm }),
          watchValidatePlugin({ extensionDir: resolved, outfile: esmOutfile, strict: Boolean(options.strict), warnings: warningsEsm }),
        ],
      });
      await ctx.watch();
      esmContexts.push(ctx);
    }

    // eslint-disable-next-line no-console
    console.error("[formula-extension-builder] Watching for changes...");

    const dispose = async () => {
      await Promise.allSettled([ctxCjs.dispose(), ...esmContexts.map((c) => c.dispose())]);
    };
    process.on("SIGINT", () => {
      void dispose()
        .catch(() => {
          // Best-effort: ignore dispose failures during shutdown.
        })
        .finally(() => process.exit(0));
    });
    process.on("SIGTERM", () => {
      void dispose()
        .catch(() => {
          // Best-effort: ignore dispose failures during shutdown.
        })
        .finally(() => process.exit(0));
    });

    // Keep the process alive.
    await new Promise(() => {});
  }

  await bundleOnce({
    extensionDir: resolved,
    entrypoint,
    outfile: outputs.cjsOutfile,
    format: "cjs",
    platform: "node",
    minify: options.minify,
    sourcemap: options.sourcemap,
    strict: options.strict,
    write: true,
  });

  for (const outfile of new Set(outputs.esmOutfiles)) {
    await bundleOnce({
      extensionDir: resolved,
      entrypoint,
      outfile,
      format: "esm",
      platform: "browser",
      minify: options.minify,
      sourcemap: options.sourcemap,
      strict: options.strict,
      write: true,
    });
  }
}

async function checkExtension(extensionDir, options = {}) {
  const resolved = path.resolve(extensionDir);
  const { manifest } = await loadManifest(resolved);

  const entrypoint = await resolveEntrypoint(resolved, manifest, options.entry);
  const outputs = resolveOutputPaths(resolved, manifest);

  const builtCjs = await bundleOnce({
    extensionDir: resolved,
    entrypoint,
    outfile: outputs.cjsOutfile,
    format: "cjs",
    platform: "node",
    minify: options.minify,
    sourcemap: options.sourcemap,
    strict: options.strict,
    write: false,
  });

  async function assertInSync(outfile, expected) {
    let actual;
    try {
      actual = await fs.readFile(outfile, "utf8");
    } catch (error) {
      if (error && error.code === "ENOENT") {
        throw new Error(
          `Missing ${prettyPath(outfile)}. Run: formula-extension-builder build ${prettyPath(resolved)}`,
        );
      }
      throw error;
    }

    if (actual !== expected) {
      throw new Error(
        `${prettyPath(outfile)} is out of date. Run: formula-extension-builder build ${prettyPath(resolved)}`,
      );
    }
  }

  await assertInSync(outputs.cjsOutfile, builtCjs.code);
  for (const outfile of new Set(outputs.esmOutfiles)) {
    const builtEsm = await bundleOnce({
      extensionDir: resolved,
      entrypoint,
      outfile,
      format: "esm",
      platform: "browser",
      minify: options.minify,
      sourcemap: options.sourcemap,
      strict: options.strict,
      write: false,
    });
    await assertInSync(outfile, builtEsm.code);
  }
}

module.exports = {
  buildExtension,
  checkExtension,
  loadManifest,
  resolveEntrypoint,
  resolveOutputPaths,
};
