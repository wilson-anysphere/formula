const test = require("node:test");
const assert = require("node:assert/strict");
const os = require("node:os");
const path = require("node:path");
const fs = require("node:fs/promises");

const { buildExtension, checkExtension } = require("../src/builder");

async function writeJson(filePath, value) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, JSON.stringify(value, null, 2) + "\n", "utf8");
}

async function writeText(filePath, value) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, value, "utf8");
}

async function createFixtureExtension(t, { withBuiltinImport = false, paddedManifestPaths = false } = {}) {
  const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "formula-ext-builder-"));
  t.after(async () => {
    await fs.rm(tmp, { recursive: true, force: true });
  });

  const main = paddedManifestPaths ? "  ./dist/extension.js  " : "./dist/extension.js";
  const module = paddedManifestPaths ? "  ./dist/extension.mjs  " : "./dist/extension.mjs";
  const browser = paddedManifestPaths ? "  ./dist/extension.mjs  " : "./dist/extension.mjs";

  await writeJson(path.join(tmp, "package.json"), {
    name: "fixture-extension",
    publisher: "publisher",
    version: "1.0.0",
    main,
    module,
    browser,
    engines: { formula: "^1.0.0" },
  });

  const builtinLine = withBuiltinImport ? 'const fsMod = require("node:fs");\nvoid fsMod;\n\n' : "";
  await writeText(
    path.join(tmp, "src", "util.js"),
    `function greet(name) {\n  return "HELLO:" + name;\n}\n\nmodule.exports = { greet };\n`,
  );
  await writeText(
    path.join(tmp, "src", "extension.js"),
    `${builtinLine}const formula = require("@formula/extension-api");\nconst { greet } = require("./util");\n\nasync function activate() {\n  // Reference both imports so esbuild bundles util and keeps extension-api external.\n  void formula;\n  return greet("world");\n}\n\nmodule.exports = { activate };\n`,
  );

  return tmp;
}

test("extension-builder: build emits CJS + ESM entrypoints", async (t) => {
  const dir = await createFixtureExtension(t);
  await buildExtension(dir, { strict: true });

  await assert.doesNotReject(async () => {
    const [cjs, esm] = await Promise.all([
      fs.readFile(path.join(dir, "dist", "extension.js"), "utf8"),
      fs.readFile(path.join(dir, "dist", "extension.mjs"), "utf8"),
    ]);

    assert.match(cjs, /This file is generated by formula-extension-builder/);
    assert.match(cjs, /require\(["']@formula\/extension-api["']\)/);
    assert.match(esm, /@formula\/extension-api/);
  });
});

test("extension-builder: check fails when dist is stale", async (t) => {
  const dir = await createFixtureExtension(t);
  await buildExtension(dir, { strict: true });

  // Change the source without rebuilding.
  await writeText(
    path.join(dir, "src", "util.js"),
    `function greet(name) {\n  return "HELLO-CHANGED:" + name;\n}\n\nmodule.exports = { greet };\n`,
  );

  await assert.rejects(() => checkExtension(dir, { strict: true }), /out of date/i);
});

test("extension-builder: bundles relative dependencies", async (t) => {
  const dir = await createFixtureExtension(t);
  await buildExtension(dir, { strict: true });

  const built = await fs.readFile(path.join(dir, "dist", "extension.js"), "utf8");
  assert.match(built, /HELLO:/);
  assert.ok(!/require\(["']\.\/util["']\)/.test(built), "bundle should not keep relative require('./util')");
});

test("extension-builder: strict mode rejects Node builtin imports", async (t) => {
  const dir = await createFixtureExtension(t, { withBuiltinImport: true });
  await assert.rejects(() => buildExtension(dir, { strict: true }), /builtin/i);
});

test("extension-builder: trims manifest output paths before resolving", async (t) => {
  const dir = await createFixtureExtension(t, { paddedManifestPaths: true });
  await buildExtension(dir, { strict: true });

  const cjsPath = path.join(dir, "dist", "extension.js");
  const esmPath = path.join(dir, "dist", "extension.mjs");
  await assert.doesNotReject(async () => {
    await Promise.all([fs.readFile(cjsPath, "utf8"), fs.readFile(esmPath, "utf8")]);
  });
});
