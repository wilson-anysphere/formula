import type { CollabSessionConnectionOptions } from "@formula/collab-session";

export type CollabShareLinkPayload = {
  wsUrl: string;
  docId: string;
  /**
   * Sync-server auth token.
   *
   * This may be an opaque shared token (dev) or a JWT depending on sync-server
   * configuration.
   */
  token?: string;
  /**
   * Optional flag to disable y-websocket BroadcastChannel syncing.
   *
   * Useful for multi-tab testing where each client must sync through the
   * websocket server.
   */
  disableBc?: boolean;
};

function resolveDefaultBaseUrl(): string {
  if (typeof window !== "undefined" && window.location) {
    // Use the app origin + pathname (strip existing query/hash) so generated share
    // links are stable and don't accidentally include unrelated query params.
    return `${window.location.origin}${window.location.pathname}`;
  }
  return "http://localhost/";
}

function parseHashParams(hash: string): URLSearchParams {
  const raw = hash.startsWith("#") ? hash.slice(1) : hash;
  return new URLSearchParams(raw);
}

function getFirstNonEmpty(...values: Array<string | null | undefined>): string {
  for (const value of values) {
    if (typeof value !== "string") continue;
    const trimmed = value.trim();
    if (trimmed) return trimmed;
  }
  return "";
}

export function serializeCollabShareLink(
  payload: CollabShareLinkPayload,
  opts: { baseUrl?: string } = {},
): string {
  const wsUrl = String(payload.wsUrl ?? "").trim();
  const docId = String(payload.docId ?? "").trim();
  const token = typeof payload.token === "string" ? payload.token.trim() : "";
  if (!wsUrl) throw new Error("serializeCollabShareLink requires wsUrl");
  if (!docId) throw new Error("serializeCollabShareLink requires docId");

  const baseUrl = opts.baseUrl ?? resolveDefaultBaseUrl();
  const url = new URL(baseUrl);

  url.searchParams.set("collab", "1");
  url.searchParams.set("wsUrl", wsUrl);
  url.searchParams.set("docId", docId);
  if (payload.disableBc) url.searchParams.set("disableBc", "1");

  // Put tokens in the URL hash rather than query params. This keeps tokens out of
  // server logs (hash fragments are not sent to the server) and makes it easier
  // to scrub them from browser history via `history.replaceState`.
  if (token) {
    const hash = parseHashParams(url.hash);
    hash.set("token", token);
    url.hash = hash.toString();
  }

  return url.toString();
}

/**
 * Parse a collaboration link generated by `serializeCollabShareLink`.
 *
 * Also accepts existing legacy formats that embed `token` in the query string.
 */
export function parseCollabShareLink(
  input: string,
  opts: { baseUrl?: string } = {},
): CollabShareLinkPayload | null {
  const raw = String(input ?? "").trim();
  if (!raw) return null;

  const baseUrl = opts.baseUrl ?? (typeof window !== "undefined" ? window.location.href : "http://localhost/");

  let url: URL;
  try {
    url = new URL(raw);
  } catch {
    try {
      url = new URL(raw, baseUrl);
    } catch {
      return null;
    }
  }

  const search = url.searchParams;
  const hash = parseHashParams(url.hash);

  const wsUrl = getFirstNonEmpty(search.get("collabWsUrl"), search.get("wsUrl"));
  const docId = getFirstNonEmpty(search.get("collabDocId"), search.get("docId"));

  if (!wsUrl || !docId) return null;

  const token = getFirstNonEmpty(search.get("collabToken"), search.get("token"), hash.get("collabToken"), hash.get("token"));
  const disableBcRaw = getFirstNonEmpty(search.get("collabDisableBc"), search.get("disableBc"));
  const disableBc = disableBcRaw === "1" || disableBcRaw.toLowerCase() === "true" || disableBcRaw.toLowerCase() === "yes";

  return {
    wsUrl,
    docId,
    ...(token ? { token } : {}),
    ...(disableBc ? { disableBc } : {}),
  };
}

export function collabConnectionOptionsFromShareLink(
  link: string,
  opts: { baseUrl?: string } = {},
): CollabSessionConnectionOptions | null {
  const parsed = parseCollabShareLink(link, opts);
  if (!parsed) return null;
  return {
    wsUrl: parsed.wsUrl,
    docId: parsed.docId,
    ...(parsed.token !== undefined ? { token: parsed.token } : {}),
    ...(parsed.disableBc ? { disableBc: true } : {}),
  };
}
