function makeIdentifier(prefix, name) {
  const cleaned = name.replace(/[^a-zA-Z0-9_]/g, "_");
  const candidate = `${prefix}${cleaned}`;
  if (/^[a-zA-Z_]/.test(candidate)) return candidate;
  return `${prefix}_${cleaned}`;
}

function literal(value) {
  return JSON.stringify(value, null, 2);
}

function colLettersToIndex(letters) {
  let col = 0;
  for (const ch of letters.toUpperCase()) {
    const code = ch.charCodeAt(0);
    if (code < 65 || code > 90) {
      throw new Error(`Invalid column letter: ${ch}`);
    }
    col = col * 26 + (code - 64);
  }
  return col - 1;
}

function parseA1(ref) {
  const match = /^([A-Za-z]+[0-9]+)(?::([A-Za-z]+[0-9]+))?$/.exec(ref.trim());
  if (!match) {
    throw new Error(`Invalid A1 reference: ${ref}`);
  }
  const parseCell = (cell) => {
    const m = /^([A-Za-z]+)([0-9]+)$/.exec(cell);
    if (!m) throw new Error(`Invalid A1 cell reference: ${cell}`);
    const [, colLetters, rowDigits] = m;
    const row = Number.parseInt(rowDigits, 10) - 1;
    const col = colLettersToIndex(colLetters);
    if (!Number.isFinite(row) || row < 0) {
      throw new Error(`Invalid row in A1 reference: ${cell}`);
    }
    return { row, col };
  };

  const startCell = parseCell(match[1]);
  const endCell = match[2] ? parseCell(match[2]) : startCell;
  if (endCell.row < startCell.row || endCell.col < startCell.col) {
    throw new Error(`Invalid A1 range (end before start): ${ref}`);
  }

  return {
    start_row: startCell.row,
    start_col: startCell.col,
    end_row: endCell.row,
    end_col: endCell.col,
  };
}

function pythonLiteral(value) {
  if (value === null || value === undefined) return "None";
  if (typeof value === "boolean") return value ? "True" : "False";
  if (typeof value === "number") {
    if (Number.isFinite(value)) return String(value);
    if (Number.isNaN(value)) return 'float("nan")';
    return value > 0 ? 'float("inf")' : 'float("-inf")';
  }
  if (typeof value === "string") return JSON.stringify(value);
  if (Array.isArray(value)) return `[${value.map((v) => pythonLiteral(v)).join(", ")}]`;
  if (typeof value === "object") {
    const entries = Object.entries(value)
      .filter(([, v]) => v !== undefined)
      .sort(([a], [b]) => a.localeCompare(b));
    return `{${entries.map(([k, v]) => `${JSON.stringify(k)}: ${pythonLiteral(v)}`).join(", ")}}`;
  }
  // Fallback: JSON string representation is usually acceptable for simple scalar types.
  return JSON.stringify(value);
}

export function generateTypeScriptMacro(actions) {
  const header = [];
  header.push("// Generated by Formula Macro Recorder");
  header.push("//");
  header.push("// This script is intended to be run with the Formula Script Runtime.");
  header.push("");

  const body = [];
  const sheetVars = new Map();

  const ensureSheetVar = (sheetName) => {
    const existing = sheetVars.get(sheetName);
    if (existing) return existing;
    const id = makeIdentifier("sheet_", sheetName);
    sheetVars.set(sheetName, id);
    body.push(`const ${id} = ctx.workbook.getSheet(${literal(sheetName)});`);
    return id;
  };

  for (const action of actions) {
    switch (action.type) {
      case "setCellValue": {
        const sheetVar = ensureSheetVar(action.sheetName);
        body.push(`await ${sheetVar}.getRange(${literal(action.address)}).setValue(${literal(action.value)});`);
        break;
      }
      case "setCellFormula": {
        const sheetVar = ensureSheetVar(action.sheetName);
        body.push(
          `await ${sheetVar}.getRange(${literal(action.address)}).setFormulas(${literal([[action.formula]])});`,
        );
        break;
      }
      case "setRangeValues": {
        const sheetVar = ensureSheetVar(action.sheetName);
        body.push(
          `await ${sheetVar}.getRange(${literal(action.address)}).setValues(${literal(action.values)});`,
        );
        break;
      }
      case "setRangeFormulas": {
        const sheetVar = ensureSheetVar(action.sheetName);
        body.push(
          `await ${sheetVar}.getRange(${literal(action.address)}).setFormulas(${literal(action.formulas)});`,
        );
        break;
      }
      case "setFormat": {
        const sheetVar = ensureSheetVar(action.sheetName);
        body.push(
          `await ${sheetVar}.getRange(${literal(action.address)}).setFormat(${literal(action.format)});`,
        );
        break;
      }
      case "setSelection": {
        body.push(
          `await ctx.workbook.setSelection(${literal(action.sheetName)}, ${literal(action.address)});`,
        );
        break;
      }
      default: {
        // Exhaustiveness.
        throw new Error(`Unhandled action: ${JSON.stringify(action)}`);
      }
    }
  }

  const out = [...header];
  out.push("export default async function main(ctx) {");
  out.push(...body.map((line) => `  ${line}`));
  out.push("}");
  out.push("");
  return out.join("\n");
}

export function generatePythonMacro(actions) {
  const lines = [];
  lines.push("# Generated by Formula Macro Recorder");
  lines.push("#");
  lines.push("# This script is intended to be run with the Formula Python Runtime.");
  lines.push("");
  lines.push("import formula");
  lines.push("");
  lines.push("def _get_sheet(name):");
  lines.push("    active = formula.active_sheet");
  lines.push("    return active if active.name == name else formula.get_sheet(name)");
  lines.push("");
  lines.push("def _col_index_to_letters(index):");
  lines.push("    n = int(index) + 1");
  lines.push('    out = ""');
  lines.push("    while n > 0:");
  lines.push("        n, rem = divmod(n - 1, 26)");
  lines.push("        out = chr(65 + rem) + out");
  lines.push("    return out");
  lines.push("");
  lines.push("def _a1_from_rc(row, col):");
  lines.push("    return f\"{_col_index_to_letters(col)}{int(row) + 1}\"");
  lines.push("");

  const sheetVars = new Map();

  const ensureSheetVar = (sheetName) => {
    const existing = sheetVars.get(sheetName);
    if (existing) return existing;
    const id = makeIdentifier("sheet_", sheetName);
    sheetVars.set(sheetName, id);
    lines.push(`${id} = _get_sheet(${pythonLiteral(sheetName)})`);
    return id;
  };

  for (const action of actions) {
    switch (action.type) {
      case "setCellValue": {
        const sheetVar = ensureSheetVar(action.sheetName);
        let value = action.value;
        if (typeof value === "string") {
          const trimmed = value.trimStart();
          if (!value.startsWith("'") && trimmed.startsWith("=")) {
            // Python treats single-cell strings that start with "=" as formulas. When the recorder
            // captured this as a *value* write, preserve it as literal text by prefixing Excel's
            // apostrophe escape.
            value = `'${value}`;
          }
        }
        lines.push(`${sheetVar}[${pythonLiteral(action.address)}] = ${pythonLiteral(value)}`);
        break;
      }
      case "setCellFormula": {
        const sheetVar = ensureSheetVar(action.sheetName);
        if (action.formula == null) {
          lines.push(`${sheetVar}[${pythonLiteral(action.address)}].value = None`);
        } else {
          lines.push(`${sheetVar}[${pythonLiteral(action.address)}].formula = ${pythonLiteral(action.formula)}`);
        }
        break;
      }
      case "setRangeValues": {
        const sheetVar = ensureSheetVar(action.sheetName);
        lines.push(`${sheetVar}[${pythonLiteral(action.address)}].value = ${pythonLiteral(action.values)}`);
        break;
      }
      case "setRangeFormulas": {
        const sheetVar = ensureSheetVar(action.sheetName);
        const sel = parseA1(action.address);
        const formulasVar = `_formulas_${lines.length}`;
        lines.push(`${formulasVar} = ${pythonLiteral(action.formulas)}`);
        lines.push(`for _r, _row in enumerate(${formulasVar}):`);
        lines.push("    for _c, _formula in enumerate(_row):");
        lines.push(`        _addr = _a1_from_rc(${sel.start_row} + _r, ${sel.start_col} + _c)`);
        lines.push("        if _formula is None:");
        lines.push(`            ${sheetVar}[_addr].value = None`);
        lines.push("        else:");
        lines.push(`            ${sheetVar}[_addr].formula = _formula`);
        break;
      }
      case "setFormat": {
        const sheetVar = ensureSheetVar(action.sheetName);
        lines.push(`${sheetVar}[${pythonLiteral(action.address)}].format = ${pythonLiteral(action.format)}`);
        break;
      }
      case "setSelection": {
        const sheetVar = ensureSheetVar(action.sheetName);
        const sel = parseA1(action.address);
        lines.push(
          `formula.set_selection({"sheet_id": ${sheetVar}.id, "start_row": ${sel.start_row}, "start_col": ${sel.start_col}, ` +
            `"end_row": ${sel.end_row}, "end_col": ${sel.end_col}})`,
        );
        break;
      }
      default: {
        // Exhaustiveness.
        throw new Error(`Unhandled action: ${JSON.stringify(action)}`);
      }
    }
  }

  lines.push("");
  return lines.join("\n");
}
