use formula_model::charts::ChartKind;
use formula_model::drawings::Anchor;
use formula_xlsx::drawingml::charts::ChartDiagnosticLevel;
use formula_xlsx::XlsxPackage;
use roxmltree::Document;
use rust_xlsxwriter::{Chart, ChartType as XlsxChartType, Workbook};

fn build_workbook_with_chart() -> Vec<u8> {
    let mut workbook = Workbook::new();
    let worksheet = workbook.add_worksheet();

    worksheet.write_string(0, 0, "Category").unwrap();
    worksheet.write_string(0, 1, "Value").unwrap();

    let categories = ["A", "B", "C", "D"];
    let values = [2.0, 4.0, 3.0, 5.0];

    for (i, (cat, val)) in categories.iter().zip(values).enumerate() {
        let row = (i + 1) as u32;
        worksheet.write_string(row, 0, *cat).unwrap();
        worksheet.write_number(row, 1, val).unwrap();
    }

    let mut chart = Chart::new(XlsxChartType::Column);
    chart.title().set_name("Example Chart");

    let series = chart.add_series();
    series
        .set_categories("Sheet1!$A$2:$A$5")
        .set_values("Sheet1!$B$2:$B$5");

    worksheet.insert_chart(1, 3, &chart).unwrap();

    workbook.save_to_buffer().unwrap()
}

fn rels_for_part(part: &str) -> String {
    match part.rsplit_once('/') {
        Some((dir, file_name)) => format!("{dir}/_rels/{file_name}.rels"),
        None => format!("_rels/{part}.rels"),
    }
}

fn extract_chart_rid(drawing_frame_xml: &str) -> Option<String> {
    // Prefer `r:id="..."`, but fall back to `id="..."` to match the production parser.
    drawing_frame_xml
        .split("r:id=\"")
        .nth(1)
        .and_then(|s| s.split('"').next())
        .map(str::to_string)
        .or_else(|| {
            drawing_frame_xml
                .split("id=\"")
                .nth(1)
                .and_then(|s| s.split('"').next())
                .map(str::to_string)
        })
}

fn rewrite_rels_xml(
    mut xml: &str,
    mut edit: impl FnMut(&str, &str, &str, Option<&str>) -> (String, Option<String>),
) -> String {
    // Workbooks generated by some producers omit the XML declaration. Preserve it when present
    // so we don't unintentionally change behavior in the parser.
    let xml_decl = if let Some(idx) = xml.find("?>") {
        let (decl, rest) = xml.split_at(idx + 2);
        xml = rest;
        Some(decl.trim().to_string())
    } else {
        None
    };

    let doc = Document::parse(xml).expect("parse rels XML");

    let mut out = String::new();
    if let Some(decl) = xml_decl {
        out.push_str(&decl);
    } else {
        out.push_str(r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?>"#);
    }
    out.push_str(
        r#"<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">"#,
    );
    for rel in doc
        .descendants()
        .filter(|n| n.is_element() && n.tag_name().name() == "Relationship")
    {
        let id = rel.attribute("Id").unwrap_or_default();
        let type_ = rel.attribute("Type").unwrap_or_default();
        let target = rel.attribute("Target").unwrap_or_default();
        let target_mode = rel.attribute("TargetMode");
        let (target, target_mode) = edit(id, type_, target, target_mode);

        out.push_str(&format!(
            r#"<Relationship Id="{id}" Type="{type_}" Target="{target}""#
        ));
        if let Some(mode) = target_mode {
            out.push_str(&format!(r#" TargetMode="{mode}""#));
        }
        out.push_str("/>");
    }
    out.push_str("</Relationships>");
    out
}

#[test]
fn extracts_chart_objects_with_anchor_and_parts() {
    let bytes = build_workbook_with_chart();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();

    let chart_objects = package.extract_chart_objects().unwrap();
    assert_eq!(chart_objects.len(), 1);

    let chart_object = &chart_objects[0];
    assert!(chart_object.parts.chart.path.starts_with("xl/charts/chart"));

    assert!(chart_object.drawing_frame_xml.contains("<c:chart"));
    let rid = extract_chart_rid(&chart_object.drawing_frame_xml).expect("chart r:id present");
    assert!(chart_object.drawing_frame_xml.contains(&rid));
    assert_eq!(chart_object.drawing_rel_id, rid);
    assert!(
        chart_object
            .drawing_object_name
            .as_deref()
            .is_some_and(|name| !name.trim().is_empty()),
        "expected drawing object name to be populated from xdr:cNvPr"
    );
    assert!(
        chart_object.drawing_object_id.is_some(),
        "expected drawing object id to be populated from xdr:cNvPr"
    );

    match chart_object.anchor {
        Anchor::TwoCell { from, to } => {
            assert!(to.cell.col > from.cell.col);
            assert!(to.cell.row > from.cell.row);
        }
        other => panic!("expected two-cell chart anchor, got {other:?}"),
    }
}

#[test]
fn detects_and_preserves_chart_ex_part_from_chart_relationships() {
    let bytes = build_workbook_with_chart();
    let mut package = XlsxPackage::from_bytes(&bytes).unwrap();

    let chart_part = package
        .part_names()
        .find(|p| p.starts_with("xl/charts/chart") && p.ends_with(".xml"))
        .expect("chart part present")
        .to_string();
    let chart_rels_part = rels_for_part(&chart_part);

    let mut updated_rels = package
        .part(&chart_rels_part)
        .map(|bytes| String::from_utf8(bytes.to_vec()).unwrap())
        .unwrap_or_else(|| {
            r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#.to_string()
        });
    let insert_idx = updated_rels
        .rfind("</Relationships>")
        .expect("closing Relationships tag");
    updated_rels.insert_str(
        insert_idx,
        r#"  <Relationship Id="rId999" Type="http://schemas.microsoft.com/office/2014/relationships/chartEx" Target="chartEx1.xml"/>"#,
    );
    package.set_part(chart_rels_part.clone(), updated_rels.into_bytes());

    let chart_ex_xml = br#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cx:chartSpace xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex"><cx:spPr/></cx:chartSpace>"#.to_vec();
    package.set_part("xl/charts/chartEx1.xml", chart_ex_xml.clone());

    package.set_part(
        "xl/charts/_rels/chartEx1.xml.rels",
        br#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#
            .to_vec(),
    );

    let bytes = package.write_to_bytes().unwrap();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();
    let chart_objects = package.extract_chart_objects().unwrap();
    assert_eq!(chart_objects.len(), 1);

    let chart_object = &chart_objects[0];
    let chart_part = &chart_object.parts.chart;
    let chart_rels_path = chart_part
        .rels_path
        .as_deref()
        .expect("chart rels should be present");
    assert_eq!(
        chart_part.rels_bytes.as_deref(),
        package.part(chart_rels_path),
        "chart rels bytes should be stored on the OpcPart"
    );
    let chart_ex = chart_object
        .parts
        .chart_ex
        .as_ref()
        .expect("chartEx part detected");
    assert_eq!(chart_ex.path, "xl/charts/chartEx1.xml");
    assert_eq!(chart_ex.bytes, chart_ex_xml);
    assert_eq!(
        chart_ex.rels_path.as_deref(),
        Some("xl/charts/_rels/chartEx1.xml.rels")
    );
    let chart_ex_rels_path = chart_ex
        .rels_path
        .as_deref()
        .expect("chartEx rels path should be present");
    assert_eq!(
        chart_ex.rels_bytes.as_deref(),
        package.part(chart_ex_rels_path),
        "chartEx rels bytes should be stored on the OpcPart"
    );

    let model = chart_object.model.as_ref().expect("chart model present");
    match &model.chart_kind {
        ChartKind::Unknown { name } => assert!(
            name.starts_with("ChartEx:"),
            "expected ChartEx chart kind prefix, got {name:?}"
        ),
        other => panic!("expected ChartKind::Unknown for ChartEx, got {other:?}"),
    }

    // Even when a minimal chartEx part exists, the extracted model should still include the
    // richer series information from the classic chartSpace part.
    assert!(
        !model.series.is_empty(),
        "expected non-empty series from chartSpace when chartEx is minimal"
    );

    // Ensure other classic chartSpace details are also preserved when ChartEx is minimal.
    assert!(
        !model.axes.is_empty(),
        "expected non-empty axes from chartSpace when chartEx is minimal"
    );
    assert_eq!(
        model.title.as_ref().map(|t| t.rich_text.text.as_str()),
        Some("Example Chart")
    );
}

#[test]
fn falls_back_to_chart_space_model_when_chart_ex_parse_fails() {
    let bytes = build_workbook_with_chart();
    let mut package = XlsxPackage::from_bytes(&bytes).unwrap();

    let chart_part = package
        .part_names()
        .find(|p| p.starts_with("xl/charts/chart") && p.ends_with(".xml"))
        .expect("chart part present")
        .to_string();
    let chart_rels_part = rels_for_part(&chart_part);

    // Inject a ChartEx relationship but provide an invalid chartEx XML part so parsing fails.
    let mut updated_rels = package
        .part(&chart_rels_part)
        .map(|bytes| String::from_utf8(bytes.to_vec()).unwrap())
        .unwrap_or_else(|| {
            r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#.to_string()
        });
    let insert_idx = updated_rels
        .rfind("</Relationships>")
        .expect("closing Relationships tag");
    updated_rels.insert_str(
        insert_idx,
        r#"  <Relationship Id="rId999" Type="http://schemas.microsoft.com/office/2014/relationships/chartEx" Target="chartEx1.xml"/>"#,
    );
    package.set_part(chart_rels_part.clone(), updated_rels.into_bytes());

    let invalid_chart_ex_xml = br#"<cx:chartSpace"#.to_vec();
    package.set_part("xl/charts/chartEx1.xml", invalid_chart_ex_xml.clone());
    package.set_part(
        "xl/charts/_rels/chartEx1.xml.rels",
        br#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#
            .to_vec(),
    );

    let bytes = package.write_to_bytes().unwrap();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();
    let chart_objects = package.extract_chart_objects().unwrap();
    assert_eq!(chart_objects.len(), 1);

    let chart_object = &chart_objects[0];
    let chart_ex = chart_object
        .parts
        .chart_ex
        .as_ref()
        .expect("chartEx part detected");
    assert_eq!(chart_ex.bytes, invalid_chart_ex_xml);

    let model = chart_object.model.as_ref().expect("chart model present");
    assert!(
        !model.series.is_empty(),
        "expected series from chartSpace when chartEx parsing fails"
    );
    assert!(
        !model.axes.is_empty(),
        "expected axes from chartSpace when chartEx parsing fails"
    );
    assert_eq!(
        model.title.as_ref().map(|t| t.rich_text.text.as_str()),
        Some("Example Chart")
    );

    assert!(
        chart_object.diagnostics.iter().any(|d| {
            d.level == ChartDiagnosticLevel::Warning
                && d.message.contains("failed to parse ChartEx part")
        }),
        "expected ChartEx parse warning, got diagnostics: {:?}",
        chart_object.diagnostics
    );
}

#[test]
fn falls_back_to_chart_ex_model_when_chart_space_parse_fails() {
    let bytes = build_workbook_with_chart();
    let mut package = XlsxPackage::from_bytes(&bytes).unwrap();

    let chart_part = package
        .part_names()
        .find(|p| p.starts_with("xl/charts/chart") && p.ends_with(".xml"))
        .expect("chart part present")
        .to_string();
    let chart_rels_part = rels_for_part(&chart_part);

    // Corrupt the classic chartSpace part so parsing fails.
    let invalid_chart_xml = br#"<c:chartSpace"#.to_vec();
    package.set_part(chart_part.clone(), invalid_chart_xml);

    // Provide a valid chartEx part with at least one series so we can verify we fall back to it.
    let mut updated_rels = package
        .part(&chart_rels_part)
        .map(|bytes| String::from_utf8(bytes.to_vec()).unwrap())
        .unwrap_or_else(|| {
            r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#.to_string()
        });
    let insert_idx = updated_rels
        .rfind("</Relationships>")
        .expect("closing Relationships tag");
    updated_rels.insert_str(
        insert_idx,
        r#"  <Relationship Id="rId999" Type="http://schemas.microsoft.com/office/2014/relationships/chartEx" Target="chartEx1.xml"/>"#,
    );
    package.set_part(chart_rels_part.clone(), updated_rels.into_bytes());

    let chart_ex_xml = br#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cx:chartSpace xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex">
  <cx:chart>
    <cx:plotArea>
      <cx:waterfallChart>
        <cx:ser/>
      </cx:waterfallChart>
    </cx:plotArea>
  </cx:chart>
</cx:chartSpace>"#
        .to_vec();
    package.set_part("xl/charts/chartEx1.xml", chart_ex_xml);
    package.set_part(
        "xl/charts/_rels/chartEx1.xml.rels",
        br#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>"#
            .to_vec(),
    );

    let bytes = package.write_to_bytes().unwrap();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();
    let chart_objects = package.extract_chart_objects().unwrap();
    assert_eq!(chart_objects.len(), 1);

    let chart_object = &chart_objects[0];
    assert!(
        chart_object.diagnostics.iter().any(|d| {
            d.level == ChartDiagnosticLevel::Warning
                && d.message.contains("failed to parse chartSpace part")
        }),
        "expected chartSpace parse warning, got diagnostics: {:?}",
        chart_object.diagnostics
    );

    let model = chart_object.model.as_ref().expect("chart model present");
    match &model.chart_kind {
        ChartKind::Unknown { name } => assert!(
            name.starts_with("ChartEx:"),
            "expected ChartEx chart kind prefix, got {name:?}"
        ),
        other => panic!("expected ChartKind::Unknown for ChartEx, got {other:?}"),
    }
    assert!(
        !model.series.is_empty(),
        "expected non-empty series from chartEx when chartSpace parsing fails"
    );
}

#[test]
fn skips_external_chart_relationship_targets_in_drawing_rels() {
    let bytes = build_workbook_with_chart();
    let mut package = XlsxPackage::from_bytes(&bytes).unwrap();

    let drawing_part = package
        .part_names()
        .find(|p| p.starts_with("xl/drawings/drawing") && p.ends_with(".xml"))
        .expect("drawing part present")
        .to_string();
    let drawing_rels_part = rels_for_part(&drawing_part);
    let drawing_rels_xml = package
        .part(&drawing_rels_part)
        .expect("drawing rels present");
    let drawing_rels_xml = String::from_utf8(drawing_rels_xml.to_vec()).unwrap();

    let updated_rels = rewrite_rels_xml(&drawing_rels_xml, |_id, type_, _target, target_mode| {
        if type_.contains("/chart") {
            (
                "https://example.com/chart1.xml".to_string(),
                Some("External".to_string()),
            )
        } else {
            (_target.to_string(), target_mode.map(str::to_string))
        }
    });
    package.set_part(drawing_rels_part, updated_rels.into_bytes());

    let bytes = package.write_to_bytes().unwrap();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();
    let chart_objects = package.extract_chart_objects().unwrap();

    assert_eq!(chart_objects.len(), 1);
    let chart_object = &chart_objects[0];
    assert!(chart_object.parts.chart.path.is_empty());
    assert!(chart_object.parts.chart.bytes.is_empty());
    assert!(
        chart_object.diagnostics.iter().any(|d| {
            d.level == ChartDiagnosticLevel::Warning
                && d.message.to_ascii_lowercase().contains("external")
        }),
        "expected external target warning, got diagnostics: {:?}",
        chart_object.diagnostics
    );
}

#[test]
fn rejects_fragment_only_chart_relationship_targets_in_drawing_rels() {
    let bytes = build_workbook_with_chart();
    let mut package = XlsxPackage::from_bytes(&bytes).unwrap();

    let drawing_part = package
        .part_names()
        .find(|p| p.starts_with("xl/drawings/drawing") && p.ends_with(".xml"))
        .expect("drawing part present")
        .to_string();
    let drawing_rels_part = rels_for_part(&drawing_part);
    let drawing_rels_xml = package
        .part(&drawing_rels_part)
        .expect("drawing rels present");
    let drawing_rels_xml = String::from_utf8(drawing_rels_xml.to_vec()).unwrap();

    let updated_rels = rewrite_rels_xml(&drawing_rels_xml, |_id, type_, _target, target_mode| {
        if type_.contains("/chart") {
            ("#rId5".to_string(), target_mode.map(str::to_string))
        } else {
            (_target.to_string(), target_mode.map(str::to_string))
        }
    });
    package.set_part(drawing_rels_part, updated_rels.into_bytes());

    let bytes = package.write_to_bytes().unwrap();
    let package = XlsxPackage::from_bytes(&bytes).unwrap();
    let chart_objects = package.extract_chart_objects().unwrap();

    assert_eq!(chart_objects.len(), 1);
    let chart_object = &chart_objects[0];
    assert!(chart_object.parts.chart.path.is_empty());
    assert!(chart_object.parts.chart.bytes.is_empty());
    assert!(
        chart_object.diagnostics.iter().any(|d| {
            d.level == ChartDiagnosticLevel::Error
                && d.message
                    .to_ascii_lowercase()
                    .contains("invalid chart relationship target")
        }),
        "expected invalid fragment-only target diagnostic, got diagnostics: {:?}",
        chart_object.diagnostics
    );
}
