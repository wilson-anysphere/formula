use std::collections::{BTreeMap, BTreeSet, HashMap};

use formula_engine::locale::{
    canonicalize_formula, get_locale, FormulaLocale, ValueLocaleConfig, EN_US,
};
use formula_engine::{Engine, ErrorKind, NameDefinition, NameScope, Value as EngineValue};
use formula_model::{
    display_formula_text, CellRef, CellValue, DateSystem, DefinedNameScope, Range, EXCEL_MAX_COLS,
    EXCEL_MAX_ROWS,
};
use js_sys::{Array, Object, Reflect};
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use wasm_bindgen::prelude::*;

pub const DEFAULT_SHEET: &str = "Sheet1";

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct CellData {
    pub sheet: String,
    pub address: String,
    pub input: JsonValue,
    pub value: JsonValue,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct CellChange {
    pub sheet: String,
    pub address: String,
    pub value: JsonValue,
}

fn js_err(message: impl ToString) -> JsValue {
    JsValue::from_str(&message.to_string())
}

#[cfg(target_arch = "wasm32")]
fn ensure_rust_constructors_run() {
    use std::sync::Once;

    static ONCE: Once = Once::new();
    ONCE.call_once(|| {
        // `inventory` (used by `formula-engine` for its built-in function registry)
        // relies on `.init_array` constructors on wasm. Some runtimes (notably
        // `wasm-bindgen-test`) do not automatically invoke them, which leaves the
        // function registry empty. Call the generated constructor trampoline when
        // needed so spreadsheet functions like `SUM()` work under wasm.
        if formula_engine::functions::iter_function_specs()
            .into_iter()
            .next()
            .is_some()
        {
            return;
        }

        extern "C" {
            fn __wasm_call_ctors();
        }

        // SAFETY: `__wasm_call_ctors` is generated by the Rust/Wasm toolchain to run global
        // constructors. This is required for `inventory`-style registries (used by `formula-engine`)
        // to be populated under wasm-bindgen-test.
        unsafe { __wasm_call_ctors() }

        debug_assert!(
            formula_engine::functions::iter_function_specs()
                .into_iter()
                .next()
                .is_some(),
            "formula-engine inventory registry did not populate after calling __wasm_call_ctors"
        );
    });
}

#[cfg(not(target_arch = "wasm32"))]
fn ensure_rust_constructors_run() {}

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen(start)]
pub fn wasm_start() {
    ensure_rust_constructors_run();
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
struct FormulaCellKey {
    sheet: String,
    row: u32,
    col: u32,
}

impl FormulaCellKey {
    fn new(sheet: String, cell: CellRef) -> Self {
        Self {
            sheet,
            row: cell.row,
            col: cell.col,
        }
    }

    fn address(&self) -> String {
        CellRef::new(self.row, self.col).to_a1()
    }
}

fn is_scalar_json(value: &JsonValue) -> bool {
    matches!(
        value,
        JsonValue::Null | JsonValue::Bool(_) | JsonValue::Number(_) | JsonValue::String(_)
    )
}

fn is_formula_input(value: &JsonValue) -> bool {
    value.as_str().is_some_and(|s| {
        let trimmed = s.trim_start();
        let Some(rest) = trimmed.strip_prefix('=') else {
            return false;
        };
        !rest.trim().is_empty()
    })
}

fn normalize_sheet_key(name: &str) -> String {
    name.to_ascii_uppercase()
}

fn json_to_engine_value(value: &JsonValue) -> EngineValue {
    match value {
        JsonValue::Null => EngineValue::Blank,
        JsonValue::Bool(b) => EngineValue::Bool(*b),
        JsonValue::Number(n) => EngineValue::Number(n.as_f64().unwrap_or(0.0)),
        JsonValue::String(s) => EngineValue::Text(s.clone()),
        JsonValue::Array(_) | JsonValue::Object(_) => {
            // Should be unreachable due to `is_scalar_json` validation, but keep a fallback.
            EngineValue::Blank
        }
    }
}

fn engine_value_to_json(value: EngineValue) -> JsonValue {
    match value {
        EngineValue::Blank => JsonValue::Null,
        EngineValue::Bool(b) => JsonValue::Bool(b),
        EngineValue::Text(s) => JsonValue::String(s),
        EngineValue::Number(n) => serde_json::Number::from_f64(n)
            .map(JsonValue::Number)
            .unwrap_or_else(|| JsonValue::String(ErrorKind::Num.as_code().to_string())),
        EngineValue::Error(kind) => JsonValue::String(kind.as_code().to_string()),
        // The JS worker protocol only supports scalar-ish values today.
        // References are intermediate Excel values; surface them as #VALUE!.
        EngineValue::Reference(_) | EngineValue::ReferenceUnion(_) => {
            JsonValue::String(ErrorKind::Value.as_code().to_string())
        }
        // Arrays should generally be spilled into grid cells. If one reaches the JS boundary,
        // degrade to its top-left value so callers still get a scalar.
        EngineValue::Array(arr) => engine_value_to_json(arr.top_left()),
        // Spill markers should not leak because `Engine::get_cell_value` resolves spill cells to
        // their concrete values. Keep a defensive fallback anyway.
        EngineValue::Spill { .. } => JsonValue::String(ErrorKind::Spill.as_code().to_string()),
        // Excel treats bare lambda values (not invoked) as a #CALC! cell result.
        // Degrade any lambda that leaks to the JS worker boundary to the same error code so
        // callers never have to handle function-valued JSON payloads.
        EngineValue::Lambda(_) => JsonValue::String(ErrorKind::Calc.as_code().to_string()),
    }
}

fn cell_value_to_engine(value: &CellValue) -> EngineValue {
    match value {
        CellValue::Empty => EngineValue::Blank,
        CellValue::Number(n) => EngineValue::Number(*n),
        CellValue::String(s) => EngineValue::Text(s.clone()),
        CellValue::Boolean(b) => EngineValue::Bool(*b),
        CellValue::Error(err) => match err {
            formula_model::ErrorValue::Null => EngineValue::Error(ErrorKind::Null),
            formula_model::ErrorValue::Div0 => EngineValue::Error(ErrorKind::Div0),
            formula_model::ErrorValue::Value => EngineValue::Error(ErrorKind::Value),
            formula_model::ErrorValue::Ref => EngineValue::Error(ErrorKind::Ref),
            formula_model::ErrorValue::Name => EngineValue::Error(ErrorKind::Name),
            formula_model::ErrorValue::Num => EngineValue::Error(ErrorKind::Num),
            formula_model::ErrorValue::NA => EngineValue::Error(ErrorKind::NA),
            formula_model::ErrorValue::Spill => EngineValue::Error(ErrorKind::Spill),
            formula_model::ErrorValue::Calc => EngineValue::Error(ErrorKind::Calc),
            other => EngineValue::Text(other.as_str().to_string()),
        },
        CellValue::RichText(rt) => EngineValue::Text(rt.plain_text().to_string()),
        // The workbook model can store cached array/spill results, but the WASM worker API only
        // supports scalar values today. Treat these as spill errors so downstream formulas see an
        // error rather than silently treating an array as a string.
        CellValue::Array(_) | CellValue::Spill(_) => EngineValue::Error(ErrorKind::Spill),
    }
}

fn cell_value_to_json(value: &CellValue) -> JsonValue {
    engine_value_to_json(cell_value_to_engine(value))
}

struct WorkbookState {
    engine: Engine,
    formula_locale: &'static FormulaLocale,
    /// Workbook input state for `toJson`/`getCell.input`.
    ///
    /// Mirrors the simple JSON workbook schema consumed by `packages/engine`.
    sheets: BTreeMap<String, BTreeMap<String, JsonValue>>,
    /// Case-insensitive mapping (Excel semantics) from sheet key -> display name.
    sheet_lookup: HashMap<String, String>,
    /// Spill cells that were cleared by edits since the last recalc.
    ///
    /// `Engine::recalculate_with_value_changes` can only diff values across a recalc tick; when a
    /// spill is cleared as part of `setCell`/`setRange` we stash the affected cells so the next
    /// `recalculate()` call can return `CellChange[]` entries that blank out any now-stale spill
    /// outputs in the JS cache.
    pending_spill_clears: BTreeSet<FormulaCellKey>,
    /// Formula cells that were edited since the last recalc, keyed by their previous visible value.
    ///
    /// The JS frontend applies `directChange` updates for literal edits but not for formulas; the
    /// WASM bridge resets formula cells to blank until the next `recalculate()` so `getCell` matches
    /// the existing semantics. This can hide "value cleared" edits when the new formula result is
    /// also blank, so we keep the previous value here and explicitly diff it against the post-recalc
    /// value.
    pending_formula_baselines: BTreeMap<FormulaCellKey, JsonValue>,
}

impl WorkbookState {
    fn new_empty() -> Self {
        ensure_rust_constructors_run();
        Self {
            engine: Engine::new(),
            formula_locale: &EN_US,
            sheets: BTreeMap::new(),
            sheet_lookup: HashMap::new(),
            pending_spill_clears: BTreeSet::new(),
            pending_formula_baselines: BTreeMap::new(),
        }
    }

    fn new_with_default_sheet() -> Self {
        let mut wb = Self::new_empty();
        wb.ensure_sheet(DEFAULT_SHEET);
        wb
    }

    fn ensure_sheet(&mut self, name: &str) -> String {
        let key = normalize_sheet_key(name);
        if let Some(existing) = self.sheet_lookup.get(&key) {
            return existing.clone();
        }

        let display = name.to_string();
        self.sheet_lookup.insert(key, display.clone());
        self.sheets.entry(display.clone()).or_default();
        self.engine.ensure_sheet(&display);
        display
    }

    fn set_sheet_dimensions_internal(
        &mut self,
        name: &str,
        rows: u32,
        cols: u32,
    ) -> Result<(), JsValue> {
        let sheet = self.ensure_sheet(name);
        self.engine
            .set_sheet_dimensions(&sheet, rows, cols)
            .map_err(|err| js_err(err.to_string()))
    }

    fn get_sheet_dimensions_internal(&self, name: &str) -> Result<(u32, u32), JsValue> {
        let sheet = self.require_sheet(name)?;
        self.engine
            .sheet_dimensions(sheet)
            .ok_or_else(|| js_err(format!("missing sheet: {name}")))
    }

    fn resolve_sheet(&self, name: &str) -> Option<&str> {
        let key = normalize_sheet_key(name);
        self.sheet_lookup.get(&key).map(String::as_str)
    }

    fn require_sheet(&self, name: &str) -> Result<&str, JsValue> {
        self.resolve_sheet(name)
            .ok_or_else(|| js_err(format!("missing sheet: {name}")))
    }

    fn parse_address(address: &str) -> Result<CellRef, JsValue> {
        CellRef::from_a1(address).map_err(|_| js_err(format!("invalid cell address: {address}")))
    }

    fn parse_range(range: &str) -> Result<Range, JsValue> {
        Range::from_a1(range).map_err(|_| js_err(format!("invalid range: {range}")))
    }

    fn set_cell_internal(
        &mut self,
        sheet: &str,
        address: &str,
        input: JsonValue,
    ) -> Result<(), JsValue> {
        if !is_scalar_json(&input) {
            return Err(js_err(format!("invalid cell value: {address}")));
        }

        let sheet = self.ensure_sheet(sheet);
        let cell_ref = Self::parse_address(address)?;
        let address = cell_ref.to_a1();

        if let Some((origin, end)) = self.engine.spill_range(&sheet, &address) {
            let edited_row = cell_ref.row;
            let edited_col = cell_ref.col;
            let edited_is_formula = is_formula_input(&input);
            for row in origin.row..=end.row {
                for col in origin.col..=end.col {
                    // Skip the origin cell (top-left); we only need to clear spill outputs.
                    if row == origin.row && col == origin.col {
                        continue;
                    }
                    // If the user overwrote a spill output cell with a literal value, don't emit a
                    // spill-clear change for that cell; the caller already knows its new input.
                    if !edited_is_formula && row == edited_row && col == edited_col {
                        continue;
                    }
                    self.pending_spill_clears
                        .insert(FormulaCellKey::new(sheet.clone(), CellRef::new(row, col)));
                }
            }
        }

        let sheet_cells = self
            .sheets
            .get_mut(&sheet)
            .expect("sheet just ensured must exist");

        // `null` represents an empty cell in the JS protocol. Preserve sparse semantics by
        // removing the stored entry instead of storing an explicit blank.
        if input.is_null() {
            self.engine
                .clear_cell(&sheet, &address)
                .map_err(|err| js_err(err.to_string()))?;

            sheet_cells.remove(&address);
            // If this cell was previously tracked as part of a spill-clear batch, drop it so we
            // don't report direct input edits as recalc changes.
            self.pending_spill_clears
                .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
            self.pending_formula_baselines
                .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
            return Ok(());
        }

        if is_formula_input(&input) {
            let raw = input.as_str().expect("formula input must be string");
            // Match `formula-model`'s display semantics so the worker protocol doesn't
            // drift from other layers (trim both ends, strip a single leading '=', and
            // treat bare '=' as empty).
            let normalized = display_formula_text(raw);
            if normalized.is_empty() {
                // This should be unreachable because `is_formula_input` requires
                // non-whitespace content after '=', but keep a defensive fallback so
                // we never store a literal "=" formula.
                self.engine
                    .clear_cell(&sheet, &address)
                    .map_err(|err| js_err(err.to_string()))?;
                sheet_cells.remove(&address);
                self.pending_spill_clears
                    .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
                self.pending_formula_baselines
                    .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
                return Ok(());
            }

            let canonical = if self.formula_locale.id == EN_US.id {
                normalized
            } else {
                canonicalize_formula(&normalized, self.formula_locale)
                    .map_err(|err| js_err(err.to_string()))?
            };

            let key = FormulaCellKey::new(sheet.clone(), cell_ref);
            self.pending_formula_baselines
                .entry(key)
                .or_insert_with(|| {
                    engine_value_to_json(self.engine.get_cell_value(&sheet, &address))
                });

            // Reset the stored value to blank so `getCell` returns null until the next recalc,
            // matching the existing worker semantics.
            self.engine
                .set_cell_value(&sheet, &address, EngineValue::Blank)
                .map_err(|err| js_err(err.to_string()))?;
            self.engine
                .set_cell_formula(&sheet, &address, &canonical)
                .map_err(|err| js_err(err.to_string()))?;

            sheet_cells.insert(address.clone(), JsonValue::String(canonical));
            return Ok(());
        }

        // Non-formula scalar value.
        self.engine
            .set_cell_value(&sheet, &address, json_to_engine_value(&input))
            .map_err(|err| js_err(err.to_string()))?;

        sheet_cells.insert(address.clone(), input);
        // If this cell was previously tracked as part of a spill-clear batch (e.g. a multi-cell
        // paste over a spill range), drop it so we don't report direct input edits as recalc
        // changes.
        self.pending_spill_clears
            .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
        self.pending_formula_baselines
            .remove(&FormulaCellKey::new(sheet.clone(), cell_ref));
        Ok(())
    }

    fn get_cell_data(&self, sheet: &str, address: &str) -> Result<CellData, JsValue> {
        let sheet = self.require_sheet(sheet)?.to_string();
        let address = Self::parse_address(address)?.to_a1();

        let input = self
            .sheets
            .get(&sheet)
            .and_then(|cells| cells.get(&address))
            .cloned()
            .unwrap_or(JsonValue::Null);

        let value = engine_value_to_json(self.engine.get_cell_value(&sheet, &address));

        Ok(CellData {
            sheet,
            address,
            input,
            value,
        })
    }

    fn recalculate_internal(&mut self, sheet: Option<&str>) -> Result<Vec<CellChange>, JsValue> {
        // The JS worker protocol historically accepted a `sheet` argument for API symmetry, but
        // callers rely on `recalculate()` returning *all* value changes across the workbook so
        // client-side caches stay coherent across sheet switches.
        //
        // Therefore we intentionally ignore `sheet` here (and do not validate it).
        let _ = sheet;

        let recalc_changes = self.engine.recalculate_with_value_changes_single_threaded();
        let mut by_cell: BTreeMap<FormulaCellKey, JsonValue> = BTreeMap::new();

        for change in recalc_changes {
            by_cell.insert(
                FormulaCellKey {
                    sheet: change.sheet,
                    row: change.addr.row,
                    col: change.addr.col,
                },
                engine_value_to_json(change.value),
            );
        }

        let pending_spills = std::mem::take(&mut self.pending_spill_clears);
        for key in pending_spills {
            if by_cell.contains_key(&key) {
                continue;
            }
            let address = key.address();
            let value = engine_value_to_json(self.engine.get_cell_value(&key.sheet, &address));
            by_cell.insert(key, value);
        }

        let pending_formulas = std::mem::take(&mut self.pending_formula_baselines);
        for (key, before) in pending_formulas {
            if by_cell.contains_key(&key) {
                continue;
            }
            let address = key.address();
            let after = engine_value_to_json(self.engine.get_cell_value(&key.sheet, &address));
            if after != before {
                by_cell.insert(key, after);
            }
        }

        let changes: Vec<CellChange> = by_cell
            .into_iter()
            .map(|(key, value)| {
                let address = key.address();
                CellChange {
                    sheet: key.sheet,
                    address,
                    value,
                }
            })
            .collect();

        Ok(changes)
    }

    fn set_locale_id(&mut self, locale_id: &str) -> bool {
        let Some(formula_locale) = get_locale(locale_id) else {
            return false;
        };
        let Some(value_locale) = ValueLocaleConfig::for_locale_id(locale_id) else {
            return false;
        };

        self.formula_locale = formula_locale;
        self.engine.set_locale_config(formula_locale.config.clone());
        self.engine.set_value_locale(value_locale);
        true
    }
}

fn json_scalar_to_js(value: &JsonValue) -> JsValue {
    match value {
        JsonValue::Null => JsValue::NULL,
        JsonValue::Bool(b) => JsValue::from_bool(*b),
        JsonValue::Number(n) => n.as_f64().map(JsValue::from_f64).unwrap_or(JsValue::NULL),
        JsonValue::String(s) => JsValue::from_str(s),
        // The engine protocol only supports scalars; fall back to `null` for any
        // unexpected values to avoid surfacing `undefined`.
        _ => JsValue::NULL,
    }
}

fn object_set(obj: &Object, key: &str, value: &JsValue) -> Result<(), JsValue> {
    Reflect::set(obj, &JsValue::from_str(key), value).map(|_| ())
}

fn cell_data_to_js(cell: &CellData) -> Result<JsValue, JsValue> {
    let obj = Object::new();
    object_set(&obj, "sheet", &JsValue::from_str(&cell.sheet))?;
    object_set(&obj, "address", &JsValue::from_str(&cell.address))?;
    object_set(&obj, "input", &json_scalar_to_js(&cell.input))?;
    object_set(&obj, "value", &json_scalar_to_js(&cell.value))?;
    Ok(obj.into())
}

fn cell_change_to_js(change: &CellChange) -> Result<JsValue, JsValue> {
    let obj = Object::new();
    object_set(&obj, "sheet", &JsValue::from_str(&change.sheet))?;
    object_set(&obj, "address", &JsValue::from_str(&change.address))?;
    object_set(&obj, "value", &json_scalar_to_js(&change.value))?;
    Ok(obj.into())
}

fn utf16_cursor_to_byte_index(s: &str, cursor_utf16: u32) -> usize {
    let cursor_utf16 = cursor_utf16 as usize;
    if cursor_utf16 == 0 {
        return 0;
    }

    let mut seen_utf16: usize = 0;
    for (byte_idx, ch) in s.char_indices() {
        let ch_utf16 = ch.len_utf16();
        if seen_utf16 + ch_utf16 > cursor_utf16 {
            // Cursor points into the middle of this char (possible for surrogate pairs).
            // Clamp to the previous valid UTF-8 boundary.
            return byte_idx;
        }
        seen_utf16 += ch_utf16;
        if seen_utf16 == cursor_utf16 {
            return byte_idx + ch.len_utf8();
        }
    }
    s.len()
}

fn byte_index_to_utf16_cursor(s: &str, byte_idx: usize) -> usize {
    let mut byte_idx = byte_idx.min(s.len());
    while byte_idx > 0 && !s.is_char_boundary(byte_idx) {
        byte_idx -= 1;
    }
    s[..byte_idx].encode_utf16().count()
}

fn is_ident_start_char(c: char) -> bool {
    matches!(c, '$' | '_' | '\\' | 'A'..='Z' | 'a'..='z') || (!c.is_ascii() && c.is_alphabetic())
}

fn is_ident_cont_char(c: char) -> bool {
    matches!(
        c,
        '$' | '_' | '\\' | '.' | 'A'..='Z' | 'a'..='z' | '0'..='9'
    ) || (!c.is_ascii() && c.is_alphanumeric())
}

#[derive(Debug)]
struct FallbackFunctionFrame {
    name: String,
    paren_depth: usize,
    arg_index: usize,
    brace_depth: usize,
    bracket_depth: usize,
}

fn scan_fallback_function_context(
    formula_prefix: &str,
    arg_separator: char,
) -> Option<formula_engine::FunctionContext> {
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    enum Mode {
        Normal,
        String,
        QuotedIdent,
    }

    let mut mode = Mode::Normal;
    let mut paren_depth: usize = 0;
    let mut brace_depth: usize = 0;
    let mut bracket_depth: usize = 0;
    let mut stack: Vec<FallbackFunctionFrame> = Vec::new();

    let mut i: usize = 0;
    while i < formula_prefix.len() {
        let ch = formula_prefix[i..]
            .chars()
            .next()
            .expect("char_indices iteration should always yield a char");
        let ch_len = ch.len_utf8();

        match mode {
            Mode::String => {
                if ch == '"' {
                    let next_i = i + ch_len;
                    if next_i < formula_prefix.len()
                        && formula_prefix[next_i..].chars().next() == Some('"')
                    {
                        // Escaped quote within a string literal: `""`.
                        i = next_i + 1;
                    } else {
                        // Closing quote.
                        mode = Mode::Normal;
                        i = next_i;
                    }
                    continue;
                }

                i += ch_len;
                continue;
            }
            Mode::QuotedIdent => {
                if ch == '\'' {
                    let next_i = i + ch_len;
                    if next_i < formula_prefix.len()
                        && formula_prefix[next_i..].chars().next() == Some('\'')
                    {
                        // Escaped quote within a quoted identifier: `''`.
                        i = next_i + 1;
                    } else {
                        mode = Mode::Normal;
                        i = next_i;
                    }
                    continue;
                }

                i += ch_len;
                continue;
            }
            Mode::Normal => {
                // In the engine lexer, quotes are treated as literal characters inside
                // structured reference brackets, so only treat them as string/quoted-ident
                // openers when we're not in a bracket segment.
                if bracket_depth == 0 {
                    if ch == '"' {
                        mode = Mode::String;
                        i += ch_len;
                        continue;
                    }
                    if ch == '\'' {
                        mode = Mode::QuotedIdent;
                        i += ch_len;
                        continue;
                    }
                }

                if bracket_depth > 0 {
                    // Mirror `formula-engine`'s lexer behavior: inside structured-ref/workbook
                    // brackets, treat everything as raw text except nested bracket open/close.
                    match ch {
                        '[' => bracket_depth += 1,
                        ']' => {
                            // Excel escapes `]` inside structured references as `]]`. At the
                            // outermost bracket depth, treat a double `]]` as a literal `]` rather
                            // than the end of the bracket segment.
                            if bracket_depth == 1 && formula_prefix[i..].starts_with("]]") {
                                i += 2;
                                continue;
                            }
                            bracket_depth = bracket_depth.saturating_sub(1);
                        }
                        _ => {}
                    }
                    i += ch_len;
                    continue;
                }

                match ch {
                    '[' => {
                        bracket_depth += 1;
                        i += ch_len;
                    }
                    ']' => {
                        if bracket_depth > 0 {
                            bracket_depth -= 1;
                        }
                        i += ch_len;
                    }
                    '{' => {
                        brace_depth += 1;
                        i += ch_len;
                    }
                    '}' => {
                        if brace_depth > 0 {
                            brace_depth -= 1;
                        }
                        i += ch_len;
                    }
                    '(' => {
                        paren_depth += 1;
                        i += ch_len;
                    }
                    ')' => {
                        if paren_depth > 0 {
                            if stack
                                .last()
                                .is_some_and(|frame| frame.paren_depth == paren_depth)
                            {
                                stack.pop();
                            }
                            paren_depth -= 1;
                        }
                        i += ch_len;
                    }
                    c if c == arg_separator => {
                        if let Some(frame) = stack.last_mut() {
                            // Count only separators that are at the "top level" within the call.
                            if paren_depth == frame.paren_depth
                                && brace_depth == frame.brace_depth
                                && bracket_depth == frame.bracket_depth
                            {
                                frame.arg_index += 1;
                            }
                        }
                        i += ch_len;
                    }
                    c if is_ident_start_char(c) => {
                        let start = i;
                        let mut end = i + ch_len;
                        while end < formula_prefix.len() {
                            let next = formula_prefix[end..]
                                .chars()
                                .next()
                                .expect("slice must start at char boundary");
                            if is_ident_cont_char(next) {
                                end += next.len_utf8();
                            } else {
                                break;
                            }
                        }

                        let ident = &formula_prefix[start..end];

                        // Look ahead for `(`, allowing whitespace between.
                        let mut j = end;
                        while j < formula_prefix.len() {
                            let next = formula_prefix[j..]
                                .chars()
                                .next()
                                .expect("slice must start at char boundary");
                            if next.is_whitespace() {
                                j += next.len_utf8();
                            } else {
                                break;
                            }
                        }

                        if j < formula_prefix.len()
                            && formula_prefix[j..].chars().next() == Some('(')
                        {
                            paren_depth += 1;
                            stack.push(FallbackFunctionFrame {
                                name: ident.to_ascii_uppercase(),
                                paren_depth,
                                arg_index: 0,
                                brace_depth,
                                bracket_depth,
                            });
                            // Skip whitespace + `(`.
                            i = j + 1;
                        } else {
                            i = end;
                        }
                    }
                    _ => {
                        i += ch_len;
                    }
                }
            }
        }
    }

    stack.last().map(|frame| formula_engine::FunctionContext {
        name: frame.name.clone(),
        arg_index: frame.arg_index,
    })
}

#[derive(Debug, Serialize)]
struct WasmSpan {
    start: usize,
    end: usize,
}

#[derive(Debug, Serialize)]
struct WasmToken {
    kind: String,
    span: WasmSpan,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<JsonValue>,
}

#[derive(Debug, Serialize)]
struct WasmParseError {
    message: String,
    span: WasmSpan,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
struct WasmFunctionContext {
    name: String,
    arg_index: usize,
}

#[derive(Debug, Serialize)]
struct WasmParseContext {
    function: Option<WasmFunctionContext>,
}

#[derive(Debug, Serialize)]
struct WasmPartialParse {
    ast: formula_engine::Ast,
    error: Option<WasmParseError>,
    context: WasmParseContext,
}

#[wasm_bindgen(js_name = "lexFormula")]
pub fn lex_formula(formula: String, opts: Option<JsValue>) -> Result<JsValue, JsValue> {
    ensure_rust_constructors_run();

    let opts: formula_engine::ParseOptions = match opts {
        Some(value) if !value.is_undefined() && !value.is_null() => {
            serde_wasm_bindgen::from_value(value).map_err(|err| js_err(err.to_string()))?
        }
        _ => formula_engine::ParseOptions::default(),
    };

    let (expr_src, span_offset) = if let Some(rest) = formula.strip_prefix('=') {
        (rest, 1usize)
    } else {
        (formula.as_str(), 0usize)
    };

    let mut fallback_error: Option<(formula_engine::ParseError, usize)> = None;
    let mut tokens = match formula_engine::lex(expr_src, &opts) {
        Ok(tokens) => tokens,
        Err(err) => {
            // Best-effort fallback: return tokens up to the error span start, and surface the
            // remainder as a final token so editor highlighting can still function during
            // incomplete input (e.g. unterminated strings).
            let mut error_start = err.span.start.min(expr_src.len());
            while error_start > 0 && !expr_src.is_char_boundary(error_start) {
                error_start -= 1;
            }
            fallback_error = Some((err, error_start));

            let prefix = &expr_src[..error_start];
            formula_engine::lex(prefix, &opts).unwrap_or_default()
        }
    };

    // Drop EOF: editor consumers care about concrete spans within the input.
    tokens.retain(|t| !matches!(&t.kind, formula_engine::TokenKind::Eof));

    let mut wasm_tokens: Vec<WasmToken> = tokens
        .into_iter()
        .map(|token| {
            let span = token.span;
            let (kind, value) = match token.kind {
                formula_engine::TokenKind::Number(raw) => ("number".to_string(), Some(JsonValue::String(raw))),
                formula_engine::TokenKind::String(value) => ("string".to_string(), Some(JsonValue::String(value))),
                formula_engine::TokenKind::Boolean(v) => ("boolean".to_string(), Some(JsonValue::Bool(v))),
                formula_engine::TokenKind::Error(code) => ("error".to_string(), Some(JsonValue::String(code))),
                formula_engine::TokenKind::Cell(cell) => (
                    "cell".to_string(),
                    Some(serde_json::json!({
                        "col": cell.col,
                        "row": cell.row,
                        "colAbs": cell.col_abs,
                        "rowAbs": cell.row_abs,
                    })),
                ),
                formula_engine::TokenKind::R1C1Cell(cell) => (
                    "r1c1Cell".to_string(),
                    Some(serde_json::json!({
                        "row": cell.row,
                        "col": cell.col,
                    })),
                ),
                formula_engine::TokenKind::R1C1Row(row) => {
                    ("r1c1Row".to_string(), Some(serde_json::json!({ "row": row.row })))
                }
                formula_engine::TokenKind::R1C1Col(col) => {
                    ("r1c1Col".to_string(), Some(serde_json::json!({ "col": col.col })))
                }
                formula_engine::TokenKind::Ident(name) => ("ident".to_string(), Some(JsonValue::String(name))),
                formula_engine::TokenKind::QuotedIdent(name) => {
                    ("quotedIdent".to_string(), Some(JsonValue::String(name)))
                }
                formula_engine::TokenKind::Whitespace(raw) => {
                    ("whitespace".to_string(), Some(JsonValue::String(raw)))
                }
                formula_engine::TokenKind::Intersect(raw) => {
                    ("intersect".to_string(), Some(JsonValue::String(raw)))
                }
                formula_engine::TokenKind::LParen => ("lParen".to_string(), None),
                formula_engine::TokenKind::RParen => ("rParen".to_string(), None),
                formula_engine::TokenKind::LBrace => ("lBrace".to_string(), None),
                formula_engine::TokenKind::RBrace => ("rBrace".to_string(), None),
                formula_engine::TokenKind::LBracket => ("lBracket".to_string(), None),
                formula_engine::TokenKind::RBracket => ("rBracket".to_string(), None),
                formula_engine::TokenKind::Bang => ("bang".to_string(), None),
                formula_engine::TokenKind::Colon => ("colon".to_string(), None),
                formula_engine::TokenKind::ArgSep => ("argSep".to_string(), None),
                formula_engine::TokenKind::Union => ("union".to_string(), None),
                formula_engine::TokenKind::ArrayRowSep => ("arrayRowSep".to_string(), None),
                formula_engine::TokenKind::ArrayColSep => ("arrayColSep".to_string(), None),
                formula_engine::TokenKind::Plus => ("plus".to_string(), None),
                formula_engine::TokenKind::Minus => ("minus".to_string(), None),
                formula_engine::TokenKind::Star => ("star".to_string(), None),
                formula_engine::TokenKind::Slash => ("slash".to_string(), None),
                formula_engine::TokenKind::Caret => ("caret".to_string(), None),
                formula_engine::TokenKind::Amp => ("amp".to_string(), None),
                formula_engine::TokenKind::Percent => ("percent".to_string(), None),
                formula_engine::TokenKind::Hash => ("hash".to_string(), None),
                formula_engine::TokenKind::Eq => ("eq".to_string(), None),
                formula_engine::TokenKind::Ne => ("ne".to_string(), None),
                formula_engine::TokenKind::Lt => ("lt".to_string(), None),
                formula_engine::TokenKind::Gt => ("gt".to_string(), None),
                formula_engine::TokenKind::Le => ("le".to_string(), None),
                formula_engine::TokenKind::Ge => ("ge".to_string(), None),
                formula_engine::TokenKind::At => ("at".to_string(), None),
                formula_engine::TokenKind::Eof => ("eof".to_string(), None),
            };

            let start_byte = span.start.saturating_add(span_offset);
            let end_byte = span.end.saturating_add(span_offset);
            WasmToken {
                kind,
                span: WasmSpan {
                    start: byte_index_to_utf16_cursor(&formula, start_byte),
                    end: byte_index_to_utf16_cursor(&formula, end_byte),
                },
                value,
            }
        })
        .collect();

    if let Some((err, error_start)) = fallback_error {
        if error_start < expr_src.len() {
            let kind = match err.message.as_str() {
                "Unterminated string literal" => "string".to_string(),
                "Unterminated quoted identifier" => "quotedIdent".to_string(),
                _ => "lexError".to_string(),
            };

            let start_byte = error_start.saturating_add(span_offset);
            let end_byte = formula.len();
            wasm_tokens.push(WasmToken {
                kind,
                span: WasmSpan {
                    start: byte_index_to_utf16_cursor(&formula, start_byte),
                    end: byte_index_to_utf16_cursor(&formula, end_byte),
                },
                value: Some(JsonValue::String(err.message)),
            });
        }
    }

    serde_wasm_bindgen::to_value(&wasm_tokens).map_err(|err| js_err(err.to_string()))
}

#[wasm_bindgen(js_name = "parseFormulaPartial")]
pub fn parse_formula_partial(
    formula: String,
    cursor: Option<u32>,
    opts: Option<JsValue>,
) -> Result<JsValue, JsValue> {
    ensure_rust_constructors_run();

    let opts: formula_engine::ParseOptions = match opts {
        Some(value) if !value.is_undefined() && !value.is_null() => {
            serde_wasm_bindgen::from_value(value).map_err(|err| js_err(err.to_string()))?
        }
        _ => formula_engine::ParseOptions::default(),
    };

    // Cursor is expressed in UTF-16 code units by JS callers.
    let cursor_utf16 = cursor.unwrap_or_else(|| formula.encode_utf16().count() as u32);
    let byte_cursor = utf16_cursor_to_byte_index(&formula, cursor_utf16);
    let prefix = &formula[..byte_cursor];

    let mut parsed = formula_engine::parse_formula_partial(prefix, opts.clone());
    if parsed.context.function.is_none() {
        let lex_error = parsed.error.as_ref().is_some_and(|err| {
            matches!(
                err.message.as_str(),
                "Unterminated string literal" | "Unterminated quoted identifier"
            )
        });
        if lex_error {
            parsed.context.function =
                scan_fallback_function_context(prefix, opts.locale.arg_separator);
        }
    }

    let error = parsed.error.map(|err| WasmParseError {
        message: err.message,
        span: WasmSpan {
            start: byte_index_to_utf16_cursor(prefix, err.span.start),
            end: byte_index_to_utf16_cursor(prefix, err.span.end),
        },
    });

    let context = WasmParseContext {
        function: parsed.context.function.map(|ctx| WasmFunctionContext {
            name: ctx.name.to_ascii_uppercase(),
            arg_index: ctx.arg_index,
        }),
    };

    let out = WasmPartialParse {
        ast: parsed.ast,
        error,
        context,
    };

    use serde::ser::Serialize as _;
    out.serialize(&serde_wasm_bindgen::Serializer::json_compatible())
        .map_err(|err| js_err(err.to_string()))
}

#[wasm_bindgen]
pub struct WasmWorkbook {
    inner: WorkbookState,
}

#[wasm_bindgen]
impl WasmWorkbook {
    #[wasm_bindgen(constructor)]
    pub fn new() -> WasmWorkbook {
        WasmWorkbook {
            inner: WorkbookState::new_with_default_sheet(),
        }
    }

    #[wasm_bindgen(js_name = "setLocale")]
    pub fn set_locale(&mut self, locale_id: String) -> bool {
        self.inner.set_locale_id(&locale_id)
    }

    #[wasm_bindgen(js_name = "fromJson")]
    pub fn from_json(json: &str) -> Result<WasmWorkbook, JsValue> {
        #[derive(Debug, Deserialize)]
        struct WorkbookJson {
            sheets: BTreeMap<String, SheetJson>,
        }

        #[derive(Debug, Deserialize)]
        struct SheetJson {
            #[serde(default, rename = "rowCount")]
            row_count: Option<u32>,
            #[serde(default, rename = "colCount")]
            col_count: Option<u32>,
            cells: BTreeMap<String, JsonValue>,
        }

        let parsed: WorkbookJson = serde_json::from_str(json)
            .map_err(|err| js_err(format!("invalid workbook json: {err}")))?;

        let mut wb = WorkbookState::new_empty();

        // Create all sheets up-front so cross-sheet formula references resolve correctly.
        for sheet_name in parsed.sheets.keys() {
            wb.ensure_sheet(sheet_name);
        }

        for (sheet_name, sheet) in parsed.sheets {
            // Apply sheet dimensions (when provided) before importing cells so large addresses
            // can be set without pre-populating the full grid.
            if sheet.row_count.is_some() || sheet.col_count.is_some() {
                let rows = sheet.row_count.unwrap_or(EXCEL_MAX_ROWS);
                let cols = sheet.col_count.unwrap_or(EXCEL_MAX_COLS);
                if rows != EXCEL_MAX_ROWS || cols != EXCEL_MAX_COLS {
                    wb.set_sheet_dimensions_internal(&sheet_name, rows, cols)?;
                }
            }

            for (address, input) in sheet.cells {
                if !is_scalar_json(&input) {
                    return Err(js_err(format!("invalid cell value: {address}")));
                }
                if input.is_null() {
                    // `null` cells are treated as absent (sparse semantics).
                    continue;
                }
                wb.set_cell_internal(&sheet_name, &address, input)?;
            }
        }

        if wb.sheets.is_empty() {
            wb.ensure_sheet(DEFAULT_SHEET);
        }

        Ok(WasmWorkbook { inner: wb })
    }

    #[wasm_bindgen(js_name = "fromXlsxBytes")]
    pub fn from_xlsx_bytes(bytes: &[u8]) -> Result<WasmWorkbook, JsValue> {
        let model = formula_xlsx::read_workbook_model_from_bytes(bytes)
            .map_err(|err| js_err(err.to_string()))?;

        let mut wb = WorkbookState::new_empty();

        // Date system influences date serials for NOW/TODAY/DATE, etc.
        wb.engine.set_date_system(match model.date_system {
            DateSystem::Excel1900 => formula_engine::date::ExcelDateSystem::EXCEL_1900,
            DateSystem::Excel1904 => formula_engine::date::ExcelDateSystem::Excel1904,
        });

        // Create all sheets up-front so formulas can resolve cross-sheet references.
        for sheet in &model.sheets {
            wb.ensure_sheet(&sheet.name);
        }

        // Apply per-sheet dimensions (logical grid size) before importing cells/formulas so
        // whole-column/row semantics (`A:A`, `1:1`) resolve correctly for large sheets.
        for sheet in &model.sheets {
            if sheet.row_count != EXCEL_MAX_ROWS || sheet.col_count != EXCEL_MAX_COLS {
                wb.set_sheet_dimensions_internal(&sheet.name, sheet.row_count, sheet.col_count)?;
            }
        }

        // Import Excel tables (structured reference metadata) before formulas are compiled so
        // expressions like `Table1[Col]` and `[@Col]` resolve correctly.
        for sheet in &model.sheets {
            let sheet_name = wb
                .resolve_sheet(&sheet.name)
                .expect("sheet just ensured must resolve")
                .to_string();
            wb.engine
                .set_sheet_tables(&sheet_name, sheet.tables.clone());
        }

        // Best-effort defined names.
        let mut sheet_names_by_id: HashMap<u32, String> = HashMap::new();
        for sheet in &model.sheets {
            sheet_names_by_id.insert(sheet.id, sheet.name.clone());
        }

        for name in &model.defined_names {
            let scope = match name.scope {
                DefinedNameScope::Workbook => NameScope::Workbook,
                DefinedNameScope::Sheet(sheet_id) => {
                    let Some(sheet_name) = sheet_names_by_id.get(&sheet_id) else {
                        continue;
                    };
                    NameScope::Sheet(sheet_name)
                }
            };

            let refers_to = name.refers_to.trim();
            if refers_to.is_empty() {
                continue;
            }

            // Best-effort heuristic:
            // - numeric/bool constants are imported as constants
            // - everything else is imported as a reference-like expression
            let definition = if refers_to.eq_ignore_ascii_case("TRUE") {
                NameDefinition::Constant(EngineValue::Bool(true))
            } else if refers_to.eq_ignore_ascii_case("FALSE") {
                NameDefinition::Constant(EngineValue::Bool(false))
            } else if let Ok(n) = refers_to.parse::<f64>() {
                NameDefinition::Constant(EngineValue::Number(n))
            } else {
                NameDefinition::Reference(refers_to.to_string())
            };

            let _ = wb.engine.define_name(&name.name, scope, definition);
        }

        for sheet in &model.sheets {
            let sheet_name = wb
                .resolve_sheet(&sheet.name)
                .expect("sheet just ensured must resolve")
                .to_string();

            for (cell_ref, cell) in sheet.iter_cells() {
                let address = cell_ref.to_a1();

                // Skip style-only cells (not representable in this WASM DTO surface).
                let has_formula = cell.formula.is_some();
                let has_value = !cell.value.is_empty();
                if !has_formula && !has_value {
                    continue;
                }

                // Seed cached values first (including cached formula results).
                wb.engine
                    .set_cell_value(&sheet_name, &address, cell_value_to_engine(&cell.value))
                    .map_err(|err| js_err(err.to_string()))?;

                if let Some(formula) = cell.formula.as_deref() {
                    // `formula-model` stores formulas without a leading '='.
                    let display = display_formula_text(formula);
                    if !display.is_empty() {
                        // Best-effort: if the formula fails to parse (unsupported syntax), leave the
                        // cached value and still store the display formula in the input map.
                        let _ = wb.engine.set_cell_formula(&sheet_name, &address, &display);

                        let sheet_cells = wb
                            .sheets
                            .get_mut(&sheet_name)
                            .expect("sheet just ensured must exist");
                        sheet_cells.insert(address.clone(), JsonValue::String(display));
                        continue;
                    }
                }

                // Non-formula cell; store scalar value as input.
                let sheet_cells = wb
                    .sheets
                    .get_mut(&sheet_name)
                    .expect("sheet just ensured must exist");
                sheet_cells.insert(address, cell_value_to_json(&cell.value));
            }
        }

        if wb.sheets.is_empty() {
            wb.ensure_sheet(DEFAULT_SHEET);
        }

        Ok(WasmWorkbook { inner: wb })
    }

    #[wasm_bindgen(js_name = "setSheetDimensions")]
    pub fn set_sheet_dimensions(
        &mut self,
        sheet_name: String,
        rows: u32,
        cols: u32,
    ) -> Result<(), JsValue> {
        self.inner
            .set_sheet_dimensions_internal(&sheet_name, rows, cols)
    }

    #[wasm_bindgen(js_name = "getSheetDimensions")]
    pub fn get_sheet_dimensions(&self, sheet_name: String) -> Result<JsValue, JsValue> {
        let (rows, cols) = self.inner.get_sheet_dimensions_internal(&sheet_name)?;
        let obj = Object::new();
        object_set(&obj, "rows", &JsValue::from_f64(rows as f64))?;
        object_set(&obj, "cols", &JsValue::from_f64(cols as f64))?;
        Ok(obj.into())
    }

    #[wasm_bindgen(js_name = "toJson")]
    pub fn to_json(&self) -> Result<String, JsValue> {
        #[derive(Serialize)]
        struct WorkbookJson {
            sheets: BTreeMap<String, SheetJson>,
        }

        #[derive(Serialize)]
        struct SheetJson {
            #[serde(default, skip_serializing_if = "Option::is_none", rename = "rowCount")]
            row_count: Option<u32>,
            #[serde(default, skip_serializing_if = "Option::is_none", rename = "colCount")]
            col_count: Option<u32>,
            cells: BTreeMap<String, JsonValue>,
        }

        let mut sheets = BTreeMap::new();
        for (sheet_name, cells) in &self.inner.sheets {
            let mut out_cells = BTreeMap::new();
            for (address, input) in cells {
                // Ensure we never serialize explicit `null` cells; empty cells are
                // omitted from the sparse workbook representation.
                if input.is_null() {
                    continue;
                }
                out_cells.insert(address.clone(), input.clone());
            }
            let (rows, cols) = self
                .inner
                .engine
                .sheet_dimensions(sheet_name)
                .unwrap_or((EXCEL_MAX_ROWS, EXCEL_MAX_COLS));
            let row_count = (rows != EXCEL_MAX_ROWS).then_some(rows);
            let col_count = (cols != EXCEL_MAX_COLS).then_some(cols);
            sheets.insert(
                sheet_name.clone(),
                SheetJson {
                    row_count,
                    col_count,
                    cells: out_cells,
                },
            );
        }

        serde_json::to_string(&WorkbookJson { sheets })
            .map_err(|err| js_err(format!("invalid workbook json: {err}")))
    }

    #[wasm_bindgen(js_name = "getCell")]
    pub fn get_cell(&self, address: String, sheet: Option<String>) -> Result<JsValue, JsValue> {
        let sheet = sheet.as_deref().unwrap_or(DEFAULT_SHEET);
        let cell = self.inner.get_cell_data(sheet, &address)?;
        cell_data_to_js(&cell)
    }

    #[wasm_bindgen(js_name = "setCell")]
    pub fn set_cell(
        &mut self,
        address: String,
        input: JsValue,
        sheet: Option<String>,
    ) -> Result<(), JsValue> {
        let sheet = sheet.as_deref().unwrap_or(DEFAULT_SHEET);
        if input.is_null() {
            return self
                .inner
                .set_cell_internal(sheet, &address, JsonValue::Null);
        }
        let input: JsonValue =
            serde_wasm_bindgen::from_value(input).map_err(|err| js_err(err.to_string()))?;
        self.inner.set_cell_internal(sheet, &address, input)
    }

    #[wasm_bindgen(js_name = "setCells")]
    pub fn set_cells(&mut self, updates: JsValue) -> Result<(), JsValue> {
        #[derive(Deserialize)]
        struct CellUpdate {
            address: String,
            value: JsonValue,
            sheet: Option<String>,
        }

        let updates: Vec<CellUpdate> =
            serde_wasm_bindgen::from_value(updates).map_err(|err| js_err(err.to_string()))?;

        for update in updates {
            let sheet = update.sheet.as_deref().unwrap_or(DEFAULT_SHEET);
            self.inner
                .set_cell_internal(sheet, &update.address, update.value)?;
        }

        Ok(())
    }

    #[wasm_bindgen(js_name = "getRange")]
    pub fn get_range(&self, range: String, sheet: Option<String>) -> Result<JsValue, JsValue> {
        let sheet = sheet.as_deref().unwrap_or(DEFAULT_SHEET);
        let sheet = self.inner.require_sheet(sheet)?.to_string();
        let range = WorkbookState::parse_range(&range)?;

        let outer = Array::new();
        for row in range.start.row..=range.end.row {
            let inner = Array::new();
            for col in range.start.col..=range.end.col {
                let addr = CellRef::new(row, col).to_a1();
                let cell = self.inner.get_cell_data(&sheet, &addr)?;
                inner.push(&cell_data_to_js(&cell)?);
            }
            outer.push(&inner);
        }

        Ok(outer.into())
    }

    #[wasm_bindgen(js_name = "setRange")]
    pub fn set_range(
        &mut self,
        range: String,
        values: JsValue,
        sheet: Option<String>,
    ) -> Result<(), JsValue> {
        let sheet = sheet.as_deref().unwrap_or(DEFAULT_SHEET);
        let range_parsed = WorkbookState::parse_range(&range)?;

        let values: Vec<Vec<JsonValue>> =
            serde_wasm_bindgen::from_value(values).map_err(|err| js_err(err.to_string()))?;

        let expected_rows = range_parsed.height() as usize;
        let expected_cols = range_parsed.width() as usize;
        if values.len() != expected_rows || values.iter().any(|row| row.len() != expected_cols) {
            return Err(js_err(format!(
                "invalid range: range {range} expects {expected_rows}x{expected_cols} values"
            )));
        }

        for (r_idx, row_values) in values.into_iter().enumerate() {
            for (c_idx, input) in row_values.into_iter().enumerate() {
                let row = range_parsed.start.row + r_idx as u32;
                let col = range_parsed.start.col + c_idx as u32;
                let addr = CellRef::new(row, col).to_a1();
                self.inner.set_cell_internal(sheet, &addr, input)?;
            }
        }

        Ok(())
    }

    #[wasm_bindgen(js_name = "recalculate")]
    pub fn recalculate(&mut self, sheet: Option<String>) -> Result<JsValue, JsValue> {
        let changes = self.inner.recalculate_internal(sheet.as_deref())?;
        let out = Array::new();
        for change in changes {
            out.push(&cell_change_to_js(&change)?);
        }
        Ok(out.into())
    }

    #[wasm_bindgen(js_name = "defaultSheetName")]
    pub fn default_sheet_name() -> String {
        DEFAULT_SHEET.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn parse_formula_partial_uses_utf16_cursor_and_spans() {
        // Emoji (``) is a surrogate pair in UTF-16 (2 code units) but 4 bytes in UTF-8.
        // Ensure cursor positions expressed as UTF-16 offsets do not panic when slicing, and that
        // returned spans are also expressed in UTF-16 code units.
        let formula = "=\"";
        let cursor_utf16 = formula.encode_utf16().count() as u32;

        let byte_cursor = utf16_cursor_to_byte_index(formula, cursor_utf16);
        assert_eq!(byte_cursor, formula.len());

        let prefix = &formula[..byte_cursor];
        let parsed = formula_engine::parse_formula_partial(prefix, formula_engine::ParseOptions::default());
        let err = parsed.error.expect("expected unterminated string literal error");
        assert_eq!(err.message, "Unterminated string literal");

        let span_start = byte_index_to_utf16_cursor(prefix, err.span.start);
        let span_end = byte_index_to_utf16_cursor(prefix, err.span.end);
        assert_eq!(span_start, 1);
        assert_eq!(span_end, cursor_utf16 as usize);
    }

    #[test]
    fn lex_formula_emits_utf16_spans_for_emoji() {
        let formula = "=\"\"";
        let (expr_src, span_offset) = formula
            .strip_prefix('=')
            .map(|rest| (rest, 1usize))
            .unwrap_or((formula, 0usize));

        let tokens = formula_engine::lex(expr_src, &formula_engine::ParseOptions::default())
            .expect("lexing should succeed");
        let string_token = tokens
            .iter()
            .find(|t| matches!(&t.kind, formula_engine::TokenKind::String(_)))
            .expect("expected a string token");

        let start = byte_index_to_utf16_cursor(formula, string_token.span.start + span_offset);
        let end = byte_index_to_utf16_cursor(formula, string_token.span.end + span_offset);
        assert_eq!(start, 1);
        assert_eq!(end, formula.encode_utf16().count());
    }

    #[test]
    fn recalculate_includes_spill_output_cells() {
        let mut wb = WorkbookState::new_with_default_sheet();
        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=SEQUENCE(1,2)"))
            .unwrap();

        let changes = wb.recalculate_internal(None).unwrap();
        assert_eq!(
            changes,
            vec![
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "A1".to_string(),
                    value: json!(1.0),
                },
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "B1".to_string(),
                    value: json!(2.0),
                },
            ]
        );
    }

    #[test]
    fn recalculate_reports_spill_clears_when_spill_origin_is_edited() {
        let mut wb = WorkbookState::new_with_default_sheet();
        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=SEQUENCE(1,2)"))
            .unwrap();
        let _ = wb.recalculate_internal(None).unwrap();

        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=1"))
            .unwrap();
        let changes = wb.recalculate_internal(None).unwrap();
        assert_eq!(
            changes,
            vec![
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "A1".to_string(),
                    value: json!(1.0),
                },
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "B1".to_string(),
                    value: JsonValue::Null,
                },
            ]
        );
    }

    #[test]
    fn recalculate_reports_spill_clears_when_spill_cell_is_overwritten() {
        let mut wb = WorkbookState::new_with_default_sheet();
        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=SEQUENCE(1,3)"))
            .unwrap();
        let _ = wb.recalculate_internal(None).unwrap();

        wb.set_cell_internal(DEFAULT_SHEET, "B1", json!(5.0))
            .unwrap();
        let changes = wb.recalculate_internal(None).unwrap();
        assert_eq!(
            changes,
            vec![
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "A1".to_string(),
                    value: json!("#SPILL!"),
                },
                CellChange {
                    sheet: DEFAULT_SHEET.to_string(),
                    address: "C1".to_string(),
                    value: JsonValue::Null,
                },
            ]
        );
    }

    #[test]
    fn recalculate_reports_formula_edit_to_blank_value() {
        let mut wb = WorkbookState::new_with_default_sheet();
        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=1"))
            .unwrap();
        let _ = wb.recalculate_internal(None).unwrap();

        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!("=A2"))
            .unwrap();
        let changes = wb.recalculate_internal(None).unwrap();
        assert_eq!(
            changes,
            vec![CellChange {
                sheet: DEFAULT_SHEET.to_string(),
                address: "A1".to_string(),
                value: JsonValue::Null,
            }]
        );
    }

    #[test]
    fn recalculate_does_not_filter_changes_by_sheet_argument() {
        let mut wb = WorkbookState::new_with_default_sheet();

        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!(1.0))
            .unwrap();
        wb.set_cell_internal(DEFAULT_SHEET, "A2", json!("=A1*2"))
            .unwrap();

        wb.set_cell_internal("Sheet2", "A1", json!(10.0)).unwrap();
        wb.set_cell_internal("Sheet2", "A2", json!("=A1*2"))
            .unwrap();

        wb.recalculate_internal(None).unwrap();

        wb.set_cell_internal(DEFAULT_SHEET, "A1", json!(2.0))
            .unwrap();
        wb.set_cell_internal("Sheet2", "A1", json!(11.0)).unwrap();

        // The wasm API accepts a `sheet` argument for symmetry, but recalc deltas are always
        // workbook-wide. Unknown sheet names should be ignored.
        let changes = wb.recalculate_internal(Some("MissingSheet")).unwrap();
        assert_eq!(
            changes,
            vec![
                CellChange {
                    sheet: "Sheet1".to_string(),
                    address: "A2".to_string(),
                    value: json!(4.0),
                },
                CellChange {
                    sheet: "Sheet2".to_string(),
                    address: "A2".to_string(),
                    value: json!(22.0),
                },
            ]
        );
    }

    #[test]
    #[cfg(not(target_arch = "wasm32"))]
    fn to_json_preserves_engine_workbook_schema() {
        let input = json!({
            "sheets": {
                "Sheet1": {
                    "cells": {
                        "A1": 1.0,
                        "A2": "=A1*2"
                    }
                }
            }
        })
        .to_string();

        let wb = WasmWorkbook::from_json(&input).unwrap();
        let json_str = wb.to_json().unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert_eq!(parsed["sheets"]["Sheet1"]["cells"]["A1"], json!(1.0));
        assert_eq!(parsed["sheets"]["Sheet1"]["cells"]["A2"], json!("=A1*2"));

        let wb2 = WasmWorkbook::from_json(&json_str).unwrap();
        let json_str2 = wb2.to_json().unwrap();
        let parsed2: serde_json::Value = serde_json::from_str(&json_str2).unwrap();
        assert_eq!(parsed2["sheets"]["Sheet1"]["cells"]["A2"], json!("=A1*2"));
    }

    #[test]
    fn from_xlsx_bytes_imports_tables_for_structured_reference_formulas() {
        let bytes = include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/../formula-xlsx/tests/fixtures/table.xlsx"
        ));

        let mut wb = WasmWorkbook::from_xlsx_bytes(bytes).unwrap();
        wb.inner.recalculate_internal(None).unwrap();

        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "D2"),
            EngineValue::Number(6.0)
        );
        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "E1"),
            EngineValue::Number(20.0)
        );
        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "F1"),
            EngineValue::Text("Qty".into())
        );
    }

    #[test]
    fn localized_formula_input_is_canonicalized_and_persisted() {
        let mut wb = WasmWorkbook::new();
        assert!(wb.set_locale("de-DE".to_string()));

        wb.inner
            .set_cell_internal(DEFAULT_SHEET, "A1", json!("=SUMME(1;2)"))
            .unwrap();
        wb.inner
            .set_cell_internal(DEFAULT_SHEET, "A2", json!("=1,5+1"))
            .unwrap();

        wb.inner.recalculate_internal(None).unwrap();

        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "A1"),
            EngineValue::Number(3.0)
        );
        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "A2"),
            EngineValue::Number(2.5)
        );

        let json_str = wb.to_json().unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert_eq!(
            parsed["sheets"]["Sheet1"]["cells"]["A1"],
            json!("=SUM(1,2)")
        );
        assert_eq!(parsed["sheets"]["Sheet1"]["cells"]["A2"], json!("=1.5+1"));
    }

    #[test]
    fn sheet_dimensions_expand_whole_column_references() {
        let mut wb = WasmWorkbook::new();

        // Expand the default sheet to include row 2,000,000.
        wb.set_sheet_dimensions(DEFAULT_SHEET.to_string(), 2_100_000, EXCEL_MAX_COLS)
            .unwrap();

        wb.inner
            .set_cell_internal(DEFAULT_SHEET, "A2000000", json!(5.0))
            .unwrap();
        wb.inner
            .set_cell_internal(DEFAULT_SHEET, "B1", json!("=SUM(A:A)"))
            .unwrap();

        wb.inner.recalculate_internal(None).unwrap();

        assert_eq!(
            wb.inner.engine.get_cell_value(DEFAULT_SHEET, "B1"),
            EngineValue::Number(5.0)
        );
    }
}
