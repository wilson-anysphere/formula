[package]
name = "formula-engine"
version = "0.1.0"
edition = "2021"
publish = false

[features]
# Enable parallel evaluation + concurrent caches on native builds.
#
# WASM builds (`wasm32-unknown-unknown`) are single-threaded, so the implementation
# automatically falls back to sequential code paths even if this feature is enabled.
default = ["parallel"]
parallel = ["dep:rayon", "dep:dashmap"]

[dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock", "serde", "std"] }
formula-model = { path = "../formula-model" }
rstar = "0.12"
inventory = "0.3"
serde = { version = "1.0", features = ["derive"] }
formula-format = { path = "../formula-format" }
serde_json = "1.0"
thiserror = "2.0"
statrs = { version = "0.16", default-features = false }
unicode-segmentation = "1.12"
unicode-ident = "1.0"
unicode-normalization = "0.1"
libm = "0.2"
num-complex = "0.4"

# Bytecode cache + SIMD kernels for bulk range evaluation.
ahash = "0.8"
smallvec = "1"
wide = "0.7"

[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
rayon = { version = "1.10", optional = true }
dashmap = { version = "5", optional = true }

[target.'cfg(target_arch = "wasm32")'.dependencies]
# WASM targets need explicit opt-in for the JS RNG backend in `getrandom`.
# We depend on both v0.3 (via `ahash`) and v0.2 (via `rand` â†’ `rand_core` from `statrs`).
getrandom = { version = "0.3", features = ["wasm_js"] }
# `statrs` pulls in `rand`, which depends on `getrandom` v0.2; enable its WASM backend too.
getrandom02 = { package = "getrandom", version = "0.2", features = ["js"] }

[dev-dependencies]
pretty_assertions = "1.4"

[target.'cfg(not(target_arch = "wasm32"))'.dev-dependencies]
criterion = { version = "0.5", default-features = false, features = ["html_reports"] }
proptest = "1"
rand = "0.8"

[[bench]]
name = "pipeline"
harness = false

[lib]
path = "src/lib.rs"

[[bin]]
name = "perf_bench"
path = "src/bin/perf_bench.rs"

[[bench]]
name = "engine"
harness = false
