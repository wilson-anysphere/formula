// THIS FILE IS AUTO-GENERATED
// Run: node packages/python-runtime/scripts/generate-formula-files.js
//
// It bundles the in-repo python/formula_api package into a JS object so the
// Pyodide worker can install it into its virtual filesystem.

export const formulaFiles = {
  "formula/__init__.py": "\"\"\"\n`formula` â€“ Python scripting API for Formula spreadsheets.\n\nThis module is designed to run in two environments:\n\n1. Pyodide (browser/webview): spreadsheet operations are bridged via a JS module\n   injected into the Pyodide runtime.\n2. Native Python (desktop): spreadsheet operations are bridged via a JSON-RPC\n   transport (stdio/IPC).\n\nThe public API intentionally mirrors the conceptual model from\ndocs/08-macro-compatibility.md:\n\n- `active_sheet` (dynamic attribute)\n- `get_sheet(name)`\n- `create_sheet(name)`\n- Sheet and Range objects with convenient cell/range accessors\n- Optional pandas helpers (`to_dataframe`, `from_dataframe`)\n- `@custom_function` decorator for UDF registration\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union\n\nfrom ._a1 import parse_a1\nfrom ._bridge import Bridge\n\n_bridge: Optional[Bridge] = None\n\n\ndef set_bridge(bridge: Bridge) -> None:\n    \"\"\"Configure the runtime bridge used to talk to the host spreadsheet.\"\"\"\n\n    global _bridge\n    _bridge = bridge\n\n\ndef _require_bridge() -> Bridge:\n    if _bridge is None:\n        raise RuntimeError(\n            \"formula bridge is not configured. \"\n            \"If you're running natively, use formula.runtime.stdio_runner. \"\n            \"If you're running in Pyodide, inject a `formula_bridge` module and \"\n            \"call formula.set_bridge(...) from your runtime.\"\n        )\n    return _bridge\n\n\ndef __getattr__(name: str) -> Any:\n    # PEP 562: module-level dynamic attributes.\n    if name == \"active_sheet\":\n        bridge = _require_bridge()\n        sheet_id = bridge.get_active_sheet_id()\n        return Sheet(sheet_id=sheet_id, bridge=bridge)\n    raise AttributeError(name)\n\n\ndef get_sheet(name: str) -> \"Sheet\":\n    bridge = _require_bridge()\n    sheet_id = bridge.get_sheet_id(name)\n    if sheet_id is None:\n        raise KeyError(f\"Sheet not found: {name!r}\")\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef create_sheet(name: str) -> \"Sheet\":\n    bridge = _require_bridge()\n    sheet_id = bridge.create_sheet(name)\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef _pandas() -> Any:\n    try:\n        import pandas as pd  # type: ignore\n\n        return pd\n    except Exception:  # pragma: no cover - environment dependent\n        return None\n\n\n@dataclass(frozen=True)\nclass RangeRef:\n    sheet_id: str\n    start_row: int\n    start_col: int\n    end_row: int\n    end_col: int\n\n    @property\n    def is_single_cell(self) -> bool:\n        return self.start_row == self.end_row and self.start_col == self.end_col\n\n\nclass Sheet:\n    \"\"\"Represents a worksheet in the spreadsheet.\"\"\"\n\n    def __init__(self, sheet_id: str, bridge: Bridge):\n        self._id = sheet_id\n        self._bridge = bridge\n\n    @property\n    def id(self) -> str:\n        return self._id\n\n    @property\n    def name(self) -> str:\n        return self._bridge.get_sheet_name(self._id)\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self._bridge.rename_sheet(self._id, value)\n\n    def __getitem__(self, key: str) -> \"Range\":\n        # Access cells via sheet[\"A1\"] or sheet[\"A1:B10\"].\n        start_row, start_col, end_row, end_col = parse_a1(key)\n        return Range(\n            ref=RangeRef(\n                sheet_id=self._id,\n                start_row=start_row,\n                start_col=start_col,\n                end_row=end_row,\n                end_col=end_col,\n            ),\n            bridge=self._bridge,\n        )\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        self[key].value = value\n\n\nclass Range:\n    \"\"\"Represents a range of cells.\"\"\"\n\n    def __init__(self, ref: RangeRef, bridge: Bridge):\n        self._ref = ref\n        self._bridge = bridge\n\n    @property\n    def ref(self) -> RangeRef:\n        return self._ref\n\n    @property\n    def value(self) -> Any:\n        values = self._bridge.get_range_values(self._ref.__dict__)\n        if self._ref.is_single_cell:\n            return values[0][0] if values and values[0] else None\n        return values\n\n    @value.setter\n    def value(self, val: Any) -> None:\n        pd = _pandas()\n        if pd is not None and isinstance(val, pd.DataFrame):\n            self.from_dataframe(val)\n            return\n\n        if self._ref.is_single_cell and isinstance(val, str) and val.startswith(\"=\"):\n            self.formula = val\n            return\n\n        if self._ref.is_single_cell and not isinstance(val, (list, tuple)):\n            self._bridge.set_cell_value(self._ref.__dict__, val)\n            return\n\n        self._bridge.set_range_values(self._ref.__dict__, val)\n\n    @property\n    def formula(self) -> Optional[str]:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        return self._bridge.get_cell_formula(self._ref.__dict__)\n\n    @formula.setter\n    def formula(self, val: str) -> None:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        self._bridge.set_cell_formula(self._ref.__dict__, val)\n\n    def clear(self) -> None:\n        self._bridge.clear_range(self._ref.__dict__)\n\n    def to_dataframe(self, header: bool = True) -> Any:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n\n        values = self.value\n        if not isinstance(values, list):\n            return pd.DataFrame([[values]])\n\n        if header and values:\n            return pd.DataFrame(values[1:], columns=values[0])\n        return pd.DataFrame(values)\n\n    def from_dataframe(self, df: Any, include_header: bool = True) -> None:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n        if not isinstance(df, pd.DataFrame):  # type: ignore[attr-defined]\n            raise TypeError(\"from_dataframe expects a pandas.DataFrame\")\n\n        values: List[List[Any]] = []\n        if include_header:\n            values.append([str(col) for col in df.columns.tolist()])\n        values.extend(df.values.tolist())\n\n        self._bridge.set_range_values(self._ref.__dict__, values)\n\n\n_function_registry: Dict[str, Callable[..., Any]] = {}\n\n\ndef custom_function(func: Optional[Callable[..., Any]] = None, *, name: Optional[str] = None) -> Any:\n    \"\"\"Decorator to register a Python function as a spreadsheet custom function.\"\"\"\n\n    def register(fn: Callable[..., Any]) -> Callable[..., Any]:\n        _function_registry[name or fn.__name__] = fn\n        return fn\n\n    return register(func) if func is not None else register\n\n\ndef list_custom_functions() -> List[str]:\n    return sorted(_function_registry.keys())\n\n",
  "formula/_a1.py": "from __future__ import annotations\n\nimport re\nfrom typing import Tuple\n\n_CELL_RE = re.compile(r\"^([A-Za-z]+)([0-9]+)$\")\n_RANGE_RE = re.compile(r\"^([A-Za-z]+[0-9]+)(?::([A-Za-z]+[0-9]+))?$\")\n\n\ndef _col_letters_to_index(letters: str) -> int:\n    col = 0\n    for ch in letters.upper():\n        if ch < \"A\" or ch > \"Z\":\n            raise ValueError(f\"Invalid column letter: {ch!r}\")\n        col = col * 26 + (ord(ch) - ord(\"A\") + 1)\n    return col - 1\n\n\ndef _parse_cell(cell: str) -> Tuple[int, int]:\n    m = _CELL_RE.match(cell)\n    if not m:\n        raise ValueError(f\"Invalid A1 cell reference: {cell!r}\")\n    col_letters, row_digits = m.groups()\n    row = int(row_digits) - 1\n    col = _col_letters_to_index(col_letters)\n    if row < 0:\n        raise ValueError(f\"Invalid row in A1 reference: {cell!r}\")\n    return row, col\n\n\ndef parse_a1(ref: str) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parse an A1-style range like \"A1\" or \"A1:B10\".\n\n    Returns a tuple: (start_row, start_col, end_row, end_col) with 0-indexed\n    coordinates.\n    \"\"\"\n\n    m = _RANGE_RE.match(ref.strip())\n    if not m:\n        raise ValueError(f\"Invalid A1 reference: {ref!r}\")\n\n    start_cell, end_cell = m.groups()\n    start_row, start_col = _parse_cell(start_cell)\n    if end_cell is None:\n        return start_row, start_col, start_row, start_col\n\n    end_row, end_col = _parse_cell(end_cell)\n    if end_row < start_row or end_col < start_col:\n        raise ValueError(f\"Invalid A1 range (end before start): {ref!r}\")\n\n    return start_row, start_col, end_row, end_col\n\n",
  "formula/_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional, Protocol\n\n\nclass Bridge(Protocol):\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str: ...\n\n    def get_sheet_id(self, name: str) -> Optional[str]: ...\n\n    def create_sheet(self, name: str) -> str: ...\n\n    def get_sheet_name(self, sheet_id: str) -> str: ...\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None: ...\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]: ...\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None: ...\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None: ...\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]: ...\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None: ...\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None: ...\n\n",
  "formula/_js_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\n# When running under Pyodide, the JS runtime registers a `formula_bridge` module\n# (via `pyodide.registerJsModule`). Importing it here provides the host callback\n# surface for spreadsheet operations.\nimport formula_bridge  # type: ignore\n\ntry:  # pragma: no cover - only available in Pyodide\n    from pyodide.ffi import to_py  # type: ignore\nexcept Exception:  # pragma: no cover - native Python\n\n    def to_py(value: Any) -> Any:\n        return value\n\n\nclass JsBridge:\n    \"\"\"Bridge implementation backed by a JS module (Pyodide/WebView).\"\"\"\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(formula_bridge.get_active_sheet_id())\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return to_py(formula_bridge.get_sheet_id(name))\n\n    def create_sheet(self, name: str) -> str:\n        return str(formula_bridge.create_sheet(name))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(formula_bridge.get_sheet_name(sheet_id))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        formula_bridge.rename_sheet(sheet_id, name)\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return to_py(formula_bridge.get_range_values(range_ref))\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        formula_bridge.set_range_values(range_ref, values)\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        formula_bridge.set_cell_value(range_ref, value)\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return to_py(formula_bridge.get_cell_formula(range_ref))\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        formula_bridge.set_cell_formula(range_ref, formula)\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        formula_bridge.clear_range(range_ref)\n\n",
  "formula/_rpc_bridge.py": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Optional, TextIO\n\n\nclass StdioRpcBridge:\n    \"\"\"\n    JSON-RPC-ish bridge over stdio.\n\n    The host (Formula app) is expected to read request messages from stdout and\n    write response messages to stdin.\n\n    Stdout is reserved for protocol messages; user script stdout should be\n    redirected to stderr by the runner to avoid corrupting the stream.\n    \"\"\"\n\n    def __init__(self, protocol_in: TextIO, protocol_out: TextIO):\n        self._in = protocol_in\n        self._out = protocol_out\n        self._next_id = 1\n\n    def _request(self, method: str, params: Any) -> Any:\n        msg_id = self._next_id\n        self._next_id += 1\n\n        self._out.write(json.dumps({\"type\": \"rpc\", \"id\": msg_id, \"method\": method, \"params\": params}) + \"\\n\")\n        self._out.flush()\n\n        while True:\n            line = self._in.readline()\n            if not line:\n                raise RuntimeError(f\"RPC connection closed while waiting for {method!r}\")\n            msg = json.loads(line)\n            if msg.get(\"type\") != \"rpc_response\":\n                continue\n            if msg.get(\"id\") != msg_id:\n                continue\n            if msg.get(\"error\"):\n                raise RuntimeError(msg[\"error\"])\n            return msg.get(\"result\")\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(self._request(\"get_active_sheet_id\", None))\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return self._request(\"get_sheet_id\", {\"name\": name})\n\n    def create_sheet(self, name: str) -> str:\n        return str(self._request(\"create_sheet\", {\"name\": name}))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(self._request(\"get_sheet_name\", {\"sheet_id\": sheet_id}))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        self._request(\"rename_sheet\", {\"sheet_id\": sheet_id, \"name\": name})\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return self._request(\"get_range_values\", {\"range\": range_ref})\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        self._request(\"set_range_values\", {\"range\": range_ref, \"values\": values})\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        self._request(\"set_cell_value\", {\"range\": range_ref, \"value\": value})\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return self._request(\"get_cell_formula\", {\"range\": range_ref})\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        self._request(\"set_cell_formula\", {\"range\": range_ref, \"formula\": formula})\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        self._request(\"clear_range\", {\"range\": range_ref})\n\n",
  "formula/runtime/__init__.py": "# Runtime helpers for Formula Python execution environments.\n\n",
  "formula/runtime/sandbox.py": "from __future__ import annotations\n\nimport builtins\nfrom typing import Any, Dict\n\n\ndef apply_memory_limit(max_memory_bytes: int | None) -> None:\n    \"\"\"Best-effort address space limit (native Python only).\"\"\"\n\n    if not max_memory_bytes:\n        return\n\n    try:\n        import resource  # Unix only\n\n        # RLIMIT_AS limits the total available address space.\n        resource.setrlimit(resource.RLIMIT_AS, (max_memory_bytes, max_memory_bytes))\n    except Exception:\n        # Best-effort: not all platforms support resource or RLIMIT_AS.\n        pass\n\n\ndef apply_sandbox(permissions: Dict[str, Any]) -> None:\n    \"\"\"\n    Apply lightweight sandbox restrictions for Python scripts.\n\n    Notes:\n    - This is *not* a hardened security boundary.\n    - In Pyodide, filesystem access is limited to the in-memory FS, but we still\n      block `open()` by default to keep behavior consistent across runtimes.\n    \"\"\"\n\n    filesystem = permissions.get(\"filesystem\", \"none\")\n    network = permissions.get(\"network\", \"none\")\n\n    block_process_execution = filesystem == \"none\" or network == \"none\"\n\n    if filesystem == \"none\":\n\n        def blocked_open(*_args: Any, **_kwargs: Any) -> Any:\n            raise PermissionError(\"Filesystem access is not permitted\")\n\n        builtins.open = blocked_open  # type: ignore[assignment]\n\n        # `io.open` / `_io.open` keep a reference to the original builtin open,\n        # so patch them too to avoid trivial escapes.\n        try:  # pragma: no cover - implementation dependent\n            import io\n\n            io.open = blocked_open  # type: ignore[assignment]\n        except Exception:\n            pass\n\n        try:  # pragma: no cover - implementation dependent\n            import _io  # type: ignore\n\n            _io.open = blocked_open  # type: ignore[attr-defined]\n        except Exception:\n            pass\n\n        try:  # pragma: no cover - platform dependent\n            import os\n\n            def blocked_fs(*_args: Any, **_kwargs: Any) -> Any:\n                raise PermissionError(\"Filesystem access is not permitted\")\n\n            # Common filesystem-related helpers that allow reads/writes without\n            # going through builtins.open.\n            for attr in (\n                \"open\",\n                \"fdopen\",\n                \"startfile\",\n                \"listdir\",\n                \"scandir\",\n                \"remove\",\n                \"unlink\",\n                \"rmdir\",\n                \"mkdir\",\n                \"makedirs\",\n                \"rename\",\n                \"replace\",\n                \"link\",\n                \"symlink\",\n                \"readlink\",\n            ):\n                if hasattr(os, attr):\n                    setattr(os, attr, blocked_fs)\n        except Exception:\n            pass\n\n    if block_process_execution:\n        try:  # pragma: no cover - platform dependent\n            import os\n\n            def blocked_process(*_args: Any, **_kwargs: Any) -> Any:\n                raise PermissionError(\"Process execution is not permitted\")\n\n            for attr in (\n                \"system\",\n                \"popen\",\n                \"spawnl\",\n                \"spawnle\",\n                \"spawnlp\",\n                \"spawnlpe\",\n                \"spawnv\",\n                \"spawnve\",\n                \"spawnvp\",\n                \"spawnvpe\",\n                \"execl\",\n                \"execle\",\n                \"execlp\",\n                \"execlpe\",\n                \"execv\",\n                \"execve\",\n                \"execvp\",\n                \"execvpe\",\n            ):\n                if hasattr(os, attr):\n                    setattr(os, attr, blocked_process)\n        except Exception:\n            pass\n\n    # Always block interactive input (native runtime stdin is used for RPC, and\n    # Pyodide has no meaningful stdin).\n    def blocked_input(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Interactive input is not permitted\")\n\n    builtins.input = blocked_input  # type: ignore[assignment]\n\n    blocked_roots = set()\n    # `subprocess` is an easy escape hatch for both filesystem and network access.\n    if filesystem == \"none\" or network == \"none\":\n        blocked_roots.add(\"subprocess\")\n    if network == \"none\":\n        blocked_roots.update({\"socket\", \"ssl\", \"http\", \"urllib\", \"requests\"})\n\n    if blocked_roots:\n        original_import = builtins.__import__\n\n        def guarded_import(name: str, globals=None, locals=None, fromlist=(), level: int = 0):\n            root = name.split(\".\", 1)[0]\n            if root in blocked_roots:\n                raise PermissionError(f\"Import of {root!r} is not permitted\")\n            return original_import(name, globals, locals, fromlist, level)\n\n        builtins.__import__ = guarded_import  # type: ignore[assignment]\n",
  "formula/runtime/stdio_runner.py": "from __future__ import annotations\n\nimport json\nimport sys\nimport traceback\nfrom typing import Any, Dict\n\nimport formula\nfrom formula._rpc_bridge import StdioRpcBridge\nfrom formula.runtime.sandbox import apply_memory_limit, apply_sandbox\n\n\ndef main() -> None:\n    # Stdout is reserved for protocol messages. Redirect user output to stderr so\n    # prints don't corrupt the JSON stream.\n    protocol_out = sys.stdout\n    sys.stdout = sys.stderr  # type: ignore[assignment]\n\n    first_line = sys.stdin.readline()\n    if not first_line:\n        return\n\n    cmd = json.loads(first_line)\n    if cmd.get(\"type\") != \"execute\":\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": False, \"error\": \"Invalid command\"}) + \"\\n\")\n        protocol_out.flush()\n        return\n\n    apply_memory_limit(cmd.get(\"max_memory_bytes\"))\n\n    # Configure the bridge before applying sandbox restrictions so our own\n    # imports aren't blocked.\n    bridge = StdioRpcBridge(protocol_in=sys.stdin, protocol_out=protocol_out)\n    formula.set_bridge(bridge)\n\n    apply_sandbox(cmd.get(\"permissions\", {}))\n\n    try:\n        globals_dict: Dict[str, Any] = {\"__name__\": \"__main__\"}\n        exec(cmd.get(\"code\", \"\"), globals_dict, globals_dict)\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": True}) + \"\\n\")\n        protocol_out.flush()\n    except Exception as err:\n        protocol_out.write(\n            json.dumps(\n                {\n                    \"type\": \"result\",\n                    \"success\": False,\n                    \"error\": str(err),\n                    \"traceback\": traceback.format_exc(),\n                }\n            )\n            + \"\\n\"\n        )\n        protocol_out.flush()\n\n\nif __name__ == \"__main__\":\n    main()\n"
};
