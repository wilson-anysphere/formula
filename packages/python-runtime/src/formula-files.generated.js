// THIS FILE IS AUTO-GENERATED
// Run: node packages/python-runtime/scripts/generate-formula-files.js
//
// It bundles the in-repo python/formula_api package into a JS object so the
// Pyodide worker can install it into its virtual filesystem.

export const formulaFiles = {
  "formula/__init__.py": "\"\"\"\n`formula` â€“ Python scripting API for Formula spreadsheets.\n\nThis module is designed to run in two environments:\n\n1. Pyodide (browser/webview): spreadsheet operations are bridged via a JS module\n   injected into the Pyodide runtime.\n2. Native Python (desktop): spreadsheet operations are bridged via a JSON-RPC\n   transport (stdio/IPC).\n\nThe public API intentionally mirrors the conceptual model from\ndocs/08-macro-compatibility.md:\n\n- `active_sheet` (dynamic attribute)\n- `get_sheet(name)`\n- `create_sheet(name, index=None)`\n- Sheet and Range objects with convenient cell/range accessors\n- Optional pandas helpers (`to_dataframe`, `from_dataframe`)\n- `@custom_function` decorator for UDF registration\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union\n\nfrom ._a1 import parse_a1\nfrom ._bridge import Bridge\n\n_bridge: Optional[Bridge] = None\n\n\ndef set_bridge(bridge: Bridge) -> None:\n    \"\"\"Configure the runtime bridge used to talk to the host spreadsheet.\"\"\"\n\n    global _bridge\n    _bridge = bridge\n\n\ndef _require_bridge() -> Bridge:\n    if _bridge is None:\n        raise RuntimeError(\n            \"formula bridge is not configured. \"\n            \"If you're running natively, use formula.runtime.stdio_runner. \"\n            \"If you're running in Pyodide, inject a `formula_bridge` module and \"\n            \"call formula.set_bridge(...) from your runtime.\"\n        )\n    return _bridge\n\n\ndef __getattr__(name: str) -> Any:\n    # PEP 562: module-level dynamic attributes.\n    if name == \"active_sheet\":\n        bridge = _require_bridge()\n        sheet_id = bridge.get_active_sheet_id()\n        return Sheet(sheet_id=sheet_id, bridge=bridge)\n    raise AttributeError(name)\n\n\ndef get_sheet(name: str) -> \"Sheet\":\n    bridge = _require_bridge()\n    sheet_id = bridge.get_sheet_id(name)\n    if sheet_id is None:\n        raise KeyError(f\"Sheet not found: {name!r}\")\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef create_sheet(name: str, index: Optional[int] = None) -> \"Sheet\":\n    \"\"\"\n    Create a new sheet.\n\n    By default, Formula inserts the new sheet after the active sheet. Pass `index`\n    to insert at a specific 0-based sheet position instead.\n    \"\"\"\n\n    bridge = _require_bridge()\n    if index is not None:\n        if not isinstance(index, int) or isinstance(index, bool):\n            raise TypeError(\"index must be an integer (0-based) or None\")\n        if index < 0:\n            raise ValueError(\"index must be >= 0\")\n    sheet_id = bridge.create_sheet(name, index=index)\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef get_selection() -> Dict[str, Any]:\n    \"\"\"\n    Get the current selection as a range reference dict:\n    {sheet_id, start_row, start_col, end_row, end_col}.\n    \"\"\"\n\n    bridge = _require_bridge()\n    return bridge.get_selection()\n\n\ndef set_selection(selection: Dict[str, Any]) -> None:\n    \"\"\"Set the current selection using a range reference dict.\"\"\"\n\n    bridge = _require_bridge()\n    bridge.set_selection(selection)\n\n\ndef _pandas() -> Any:\n    try:\n        import pandas as pd  # type: ignore\n\n        return pd\n    except Exception:  # pragma: no cover - environment dependent\n        return None\n\n\n@dataclass(frozen=True)\nclass RangeRef:\n    sheet_id: str\n    start_row: int\n    start_col: int\n    end_row: int\n    end_col: int\n\n    @property\n    def is_single_cell(self) -> bool:\n        return self.start_row == self.end_row and self.start_col == self.end_col\n\n\nclass Sheet:\n    \"\"\"Represents a worksheet in the spreadsheet.\"\"\"\n\n    def __init__(self, sheet_id: str, bridge: Bridge):\n        self._id = sheet_id\n        self._bridge = bridge\n\n    @property\n    def id(self) -> str:\n        return self._id\n\n    @property\n    def name(self) -> str:\n        return self._bridge.get_sheet_name(self._id)\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self._bridge.rename_sheet(self._id, value)\n\n    def __getitem__(self, key: str) -> \"Range\":\n        # Access cells via sheet[\"A1\"] or sheet[\"A1:B10\"].\n        start_row, start_col, end_row, end_col = parse_a1(key)\n        return Range(\n            ref=RangeRef(\n                sheet_id=self._id,\n                start_row=start_row,\n                start_col=start_col,\n                end_row=end_row,\n                end_col=end_col,\n            ),\n            bridge=self._bridge,\n        )\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        self[key].value = value\n\n\nclass Range:\n    \"\"\"Represents a range of cells.\"\"\"\n\n    def __init__(self, ref: RangeRef, bridge: Bridge):\n        self._ref = ref\n        self._bridge = bridge\n\n    @property\n    def ref(self) -> RangeRef:\n        return self._ref\n\n    @property\n    def value(self) -> Any:\n        values = self._bridge.get_range_values(self._ref.__dict__)\n        if self._ref.is_single_cell:\n            return values[0][0] if values and values[0] else None\n        return values\n\n    @value.setter\n    def value(self, val: Any) -> None:\n        pd = _pandas()\n        if pd is not None and isinstance(val, pd.DataFrame):\n            self.from_dataframe(val)\n            return\n\n        if self._ref.is_single_cell and isinstance(val, str):\n            # Match DocumentController's string input semantics:\n            # - Leading apostrophe escapes literal text.\n            # - Leading whitespace is ignored when detecting formulas (\"=...\"), but\n            #   a bare \"=\" is treated as a literal value.\n            if val.startswith(\"'\"):\n                self._bridge.set_cell_value(self._ref.__dict__, val[1:])\n                return\n\n            trimmed = val.lstrip()\n            if trimmed.startswith(\"=\") and len(trimmed) > 1:\n                self.formula = trimmed\n                return\n\n        if self._ref.is_single_cell and not isinstance(val, (list, tuple)):\n            self._bridge.set_cell_value(self._ref.__dict__, val)\n            return\n\n        # Convenience: allow 1D sequences for single-row or single-column ranges.\n        if (\n            not self._ref.is_single_cell\n            and isinstance(val, (list, tuple))\n            and (len(val) == 0 or not isinstance(val[0], (list, tuple)))\n        ):\n            row_count = self._ref.end_row - self._ref.start_row + 1\n            col_count = self._ref.end_col - self._ref.start_col + 1\n            if row_count == 1:\n                if len(val) != col_count:\n                    raise ValueError(\n                        f\"Range expects {col_count} values for a 1x{col_count} row range, got {len(val)}\"\n                    )\n                val = [list(val)]\n            elif col_count == 1:\n                if len(val) != row_count:\n                    raise ValueError(\n                        f\"Range expects {row_count} values for a {row_count}x1 column range, got {len(val)}\"\n                    )\n                val = [[v] for v in val]\n            else:\n                raise TypeError(\n                    \"Range.value expects a 2D list for multi-cell ranges \"\n                    \"(a 1D list is only allowed for single-row or single-column ranges)\"\n                )\n\n        self._bridge.set_range_values(self._ref.__dict__, val)\n\n    @property\n    def formula(self) -> Optional[str]:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        return self._bridge.get_cell_formula(self._ref.__dict__)\n\n    @formula.setter\n    def formula(self, val: Optional[str]) -> None:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        if val is None:\n            # Clear both value and formula (preserving formatting), matching\n            # DocumentController.setCellFormula(..., null).\n            self._bridge.set_cell_value(self._ref.__dict__, None)\n            return\n\n        trimmed = str(val).lstrip()\n        if trimmed == \"\":\n            self._bridge.set_cell_value(self._ref.__dict__, None)\n            return\n\n        normalized = trimmed if trimmed.startswith(\"=\") else f\"={trimmed}\"\n        self._bridge.set_cell_formula(self._ref.__dict__, normalized)\n\n    @property\n    def format(self) -> Any:\n        return self._bridge.get_range_format(self._ref.__dict__)\n\n    @format.setter\n    def format(self, val: Any) -> None:\n        self._bridge.set_range_format(self._ref.__dict__, val)\n\n    def set_format(self, val: Any) -> None:\n        self.format = val\n\n    def clear(self) -> None:\n        self._bridge.clear_range(self._ref.__dict__)\n\n    def to_dataframe(self, header: bool = True) -> Any:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n\n        values = self.value\n        if not isinstance(values, list):\n            return pd.DataFrame([[values]])\n\n        if header and values:\n            return pd.DataFrame(values[1:], columns=values[0])\n        return pd.DataFrame(values)\n\n    def from_dataframe(self, df: Any, include_header: bool = True) -> None:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n        if not isinstance(df, pd.DataFrame):  # type: ignore[attr-defined]\n            raise TypeError(\"from_dataframe expects a pandas.DataFrame\")\n\n        values: List[List[Any]] = []\n        if include_header:\n            values.append([str(col) for col in df.columns.tolist()])\n        values.extend(df.values.tolist())\n\n        self._bridge.set_range_values(self._ref.__dict__, values)\n\n\n_function_registry: Dict[str, Callable[..., Any]] = {}\n\n\ndef custom_function(func: Optional[Callable[..., Any]] = None, *, name: Optional[str] = None) -> Any:\n    \"\"\"Decorator to register a Python function as a spreadsheet custom function.\"\"\"\n\n    def register(fn: Callable[..., Any]) -> Callable[..., Any]:\n        _function_registry[name or fn.__name__] = fn\n        return fn\n\n    return register(func) if func is not None else register\n\n\ndef list_custom_functions() -> List[str]:\n    return sorted(_function_registry.keys())\n",
  "formula/_a1.py": "from __future__ import annotations\n\nimport re\nfrom typing import Tuple\n\n_CELL_RE = re.compile(r\"^([A-Za-z]+)([0-9]+)$\")\n_RANGE_RE = re.compile(r\"^([A-Za-z]+[0-9]+)(?::([A-Za-z]+[0-9]+))?$\")\n\n\ndef _col_letters_to_index(letters: str) -> int:\n    col = 0\n    for ch in letters.upper():\n        if ch < \"A\" or ch > \"Z\":\n            raise ValueError(f\"Invalid column letter: {ch!r}\")\n        col = col * 26 + (ord(ch) - ord(\"A\") + 1)\n    return col - 1\n\n\ndef _parse_cell(cell: str) -> Tuple[int, int]:\n    m = _CELL_RE.match(cell)\n    if not m:\n        raise ValueError(f\"Invalid A1 cell reference: {cell!r}\")\n    col_letters, row_digits = m.groups()\n    row = int(row_digits) - 1\n    col = _col_letters_to_index(col_letters)\n    if row < 0:\n        raise ValueError(f\"Invalid row in A1 reference: {cell!r}\")\n    return row, col\n\n\ndef parse_a1(ref: str) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parse an A1-style range like \"A1\" or \"A1:B10\".\n\n    Returns a tuple: (start_row, start_col, end_row, end_col) with 0-indexed\n    coordinates.\n    \"\"\"\n\n    m = _RANGE_RE.match(ref.strip())\n    if not m:\n        raise ValueError(f\"Invalid A1 reference: {ref!r}\")\n\n    start_cell, end_cell = m.groups()\n    start_row, start_col = _parse_cell(start_cell)\n    if end_cell is None:\n        return start_row, start_col, start_row, start_col\n\n    end_row, end_col = _parse_cell(end_cell)\n    if end_row < start_row or end_col < start_col:\n        raise ValueError(f\"Invalid A1 range (end before start): {ref!r}\")\n\n    return start_row, start_col, end_row, end_col\n\n",
  "formula/_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional, Protocol\n\n\nclass Bridge(Protocol):\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str: ...\n\n    def get_sheet_id(self, name: str) -> Optional[str]: ...\n\n    def create_sheet(self, name: str, index: Optional[int] = None) -> str: ...\n\n    def get_sheet_name(self, sheet_id: str) -> str: ...\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None: ...\n\n    # Selection operations\n    def get_selection(self) -> Dict[str, Any]: ...\n\n    def set_selection(self, selection: Dict[str, Any]) -> None: ...\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]: ...\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None: ...\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None: ...\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]: ...\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None: ...\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None: ...\n\n    # Formatting operations\n    def set_range_format(self, range_ref: Dict[str, Any], format_obj: Any) -> None: ...\n\n    def get_range_format(self, range_ref: Dict[str, Any]) -> Any: ...\n",
  "formula/_js_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\n# When running under Pyodide, the JS runtime registers a `formula_bridge` module\n# (via `pyodide.registerJsModule`). Importing it here provides the host callback\n# surface for spreadsheet operations.\nimport formula_bridge  # type: ignore\n\ntry:  # pragma: no cover - only available in Pyodide\n    from pyodide.ffi import to_py  # type: ignore\nexcept Exception:  # pragma: no cover - native Python\n\n    def to_py(value: Any) -> Any:\n        return value\n\n\nclass JsBridge:\n    \"\"\"Bridge implementation backed by a JS module (Pyodide/WebView).\"\"\"\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(formula_bridge.get_active_sheet_id())\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return to_py(formula_bridge.get_sheet_id(name))\n\n    def create_sheet(self, name: str, index: Optional[int] = None) -> str:\n        if index is None:\n            return str(formula_bridge.create_sheet(name))\n        if not isinstance(index, int) or isinstance(index, bool):\n            raise TypeError(\"index must be an integer (0-based) or None\")\n        if index < 0:\n            raise ValueError(\"index must be >= 0\")\n        return str(formula_bridge.create_sheet(name, index))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(formula_bridge.get_sheet_name(sheet_id))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        formula_bridge.rename_sheet(sheet_id, name)\n\n    # Selection operations\n    def get_selection(self) -> Dict[str, Any]:\n        return to_py(formula_bridge.get_selection())\n\n    def set_selection(self, selection: Dict[str, Any]) -> None:\n        formula_bridge.set_selection(selection)\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return to_py(formula_bridge.get_range_values(range_ref))\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        formula_bridge.set_range_values(range_ref, values)\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        formula_bridge.set_cell_value(range_ref, value)\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return to_py(formula_bridge.get_cell_formula(range_ref))\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        formula_bridge.set_cell_formula(range_ref, formula)\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        formula_bridge.clear_range(range_ref)\n\n    # Formatting operations\n    def set_range_format(self, range_ref: Dict[str, Any], format_obj: Any) -> None:\n        formula_bridge.set_range_format(range_ref, format_obj)\n\n    def get_range_format(self, range_ref: Dict[str, Any]) -> Any:\n        return to_py(formula_bridge.get_range_format(range_ref))\n",
  "formula/_rpc_bridge.py": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Optional, TextIO\n\n\nclass StdioRpcBridge:\n    \"\"\"\n    JSON-RPC-ish bridge over stdio.\n\n    The host (Formula app) is expected to read request messages from stdout and\n    write response messages to stdin.\n\n    Stdout is reserved for protocol messages; user script stdout should be\n    redirected to stderr by the runner to avoid corrupting the stream.\n    \"\"\"\n\n    def __init__(self, protocol_in: TextIO, protocol_out: TextIO):\n        self._in = protocol_in\n        self._out = protocol_out\n        self._next_id = 1\n\n    def _request(self, method: str, params: Any) -> Any:\n        msg_id = self._next_id\n        self._next_id += 1\n\n        self._out.write(json.dumps({\"type\": \"rpc\", \"id\": msg_id, \"method\": method, \"params\": params}) + \"\\n\")\n        self._out.flush()\n\n        while True:\n            line = self._in.readline()\n            if not line:\n                raise RuntimeError(f\"RPC connection closed while waiting for {method!r}\")\n            msg = json.loads(line)\n            if msg.get(\"type\") != \"rpc_response\":\n                continue\n            if msg.get(\"id\") != msg_id:\n                continue\n            if msg.get(\"error\"):\n                raise RuntimeError(msg[\"error\"])\n            return msg.get(\"result\")\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(self._request(\"get_active_sheet_id\", None))\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return self._request(\"get_sheet_id\", {\"name\": name})\n\n    def create_sheet(self, name: str, index: Optional[int] = None) -> str:\n        params: Dict[str, Any] = {\"name\": name}\n        if index is not None:\n            if not isinstance(index, int) or isinstance(index, bool):\n                raise TypeError(\"index must be an integer (0-based) or None\")\n            if index < 0:\n                raise ValueError(\"index must be >= 0\")\n            params[\"index\"] = index\n        return str(self._request(\"create_sheet\", params))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(self._request(\"get_sheet_name\", {\"sheet_id\": sheet_id}))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        self._request(\"rename_sheet\", {\"sheet_id\": sheet_id, \"name\": name})\n\n    # Selection operations\n    def get_selection(self) -> Dict[str, Any]:\n        return self._request(\"get_selection\", None)\n\n    def set_selection(self, selection: Dict[str, Any]) -> None:\n        self._request(\"set_selection\", {\"selection\": selection})\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return self._request(\"get_range_values\", {\"range\": range_ref})\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        self._request(\"set_range_values\", {\"range\": range_ref, \"values\": values})\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        self._request(\"set_cell_value\", {\"range\": range_ref, \"value\": value})\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return self._request(\"get_cell_formula\", {\"range\": range_ref})\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        self._request(\"set_cell_formula\", {\"range\": range_ref, \"formula\": formula})\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        self._request(\"clear_range\", {\"range\": range_ref})\n\n    # Formatting operations\n    def set_range_format(self, range_ref: Dict[str, Any], format_obj: Any) -> None:\n        self._request(\"set_range_format\", {\"range\": range_ref, \"format\": format_obj})\n\n    def get_range_format(self, range_ref: Dict[str, Any]) -> Any:\n        return self._request(\"get_range_format\", {\"range\": range_ref})\n",
  "formula/runtime/__init__.py": "# Runtime helpers for Formula Python execution environments.\n\n",
  "formula/runtime/sandbox.py": "from __future__ import annotations\n\nimport builtins\nimport io\nimport os\nimport sys\nimport sysconfig\nfrom typing import Any, Dict\n\n# Capture original references at import time so apply_sandbox() can be called\n# repeatedly (Pyodide worker) and can both tighten and loosen restrictions.\n_ORIGINAL_OPEN = builtins.open\n_ORIGINAL_IMPORT = builtins.__import__\n\ntry:  # pragma: no cover - implementation dependent\n    import _io as _io_builtin  # type: ignore\nexcept Exception:  # pragma: no cover - native only\n    _io_builtin = None\n\n_ORIGINAL_IO_OPEN = getattr(io, \"open\", None)\n_ORIGINAL__IO_OPEN = getattr(_io_builtin, \"open\", None) if _io_builtin else None\n\n_ORIGINAL_SOCKET_CREATE_CONNECTION = None\n_ORIGINAL_SOCKET_CONNECT = None\n_ORIGINAL_SOCKET_CONNECT_EX = None\n_ORIGINAL_SOCKET_SENDTO = None\n_ORIGINAL_SOCKET_SENDMSG = None\n_ORIGINAL_SOCKET_GETADDRINFO = None\n_ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT = None\n_ORIGINAL_SOCKET_SOCKET_CLASS = None\n_ORIGINAL__SOCKET_SOCKET = None\n_ORIGINAL__SOCKET_SOCKETTYPE = None\n\n_AUDIT_HOOK_INSTALLED = False\n_AUDIT_NETWORK_MODE = \"full\"\n_AUDIT_NETWORK_ALLOWLIST_EXACT: set[str] = set()\n_AUDIT_NETWORK_ALLOWLIST_WILDCARDS: tuple[str, ...] = ()\n\ntry:  # pragma: no cover - environment dependent\n    _IMPORT_ALLOWLIST_ROOTS = tuple(\n        sorted(\n            {\n                os.path.abspath(path)\n                for path in (\n                    sysconfig.get_path(\"stdlib\"),\n                    sysconfig.get_path(\"platstdlib\"),\n                    sysconfig.get_path(\"purelib\"),\n                    sysconfig.get_path(\"platlib\"),\n                )\n                if path\n            }\n        )\n    )\nexcept Exception:  # pragma: no cover - environment dependent\n    _IMPORT_ALLOWLIST_ROOTS = ()\n\n_OS_FS_FUNCS = (\n    # File descriptor based access.\n    \"open\",\n    \"fdopen\",\n    # Directory enumeration.\n    \"listdir\",\n    \"scandir\",\n    # Destructive operations / mutations.\n    \"remove\",\n    \"unlink\",\n    \"rmdir\",\n    \"mkdir\",\n    \"makedirs\",\n    \"rename\",\n    \"replace\",\n    \"link\",\n    \"symlink\",\n    \"readlink\",\n    # Platform-specific helpers.\n    \"startfile\",\n)\n\n_OS_PROCESS_FUNCS = (\n    \"system\",\n    \"popen\",\n    \"fork\",\n    \"forkpty\",\n    \"posix_spawn\",\n    \"posix_spawnp\",\n    \"spawnl\",\n    \"spawnle\",\n    \"spawnlp\",\n    \"spawnlpe\",\n    \"spawnv\",\n    \"spawnve\",\n    \"spawnvp\",\n    \"spawnvpe\",\n    \"execl\",\n    \"execle\",\n    \"execlp\",\n    \"execlpe\",\n    \"execv\",\n    \"execve\",\n    \"execvp\",\n    \"execvpe\",\n    \"startfile\",\n)\n\n_ORIGINAL_OS = {name: getattr(os, name) for name in set(_OS_FS_FUNCS + _OS_PROCESS_FUNCS) if hasattr(os, name)}\n\n\ndef _normalize_permission(value: Any, allowed: set[str], default: str) -> str:\n    if not isinstance(value, str):\n        return default\n    lowered = value.lower()\n    return lowered if lowered in allowed else default\n\n\ndef _filesystem_permission(permissions: Dict[str, Any]) -> str:\n    # Support the docs/08-macro-compatibility.md key casing as well.\n    raw = permissions.get(\"filesystem\", permissions.get(\"fileSystem\", \"none\"))\n    return _normalize_permission(raw, {\"none\", \"read\", \"readwrite\"}, \"none\")\n\n\ndef _network_permission(permissions: Dict[str, Any]) -> str:\n    raw = permissions.get(\"network\", \"none\")\n    return _normalize_permission(raw, {\"none\", \"allowlist\", \"full\"}, \"none\")\n\n\ndef _is_write_mode(mode: str) -> bool:\n    return any(ch in mode for ch in (\"w\", \"a\", \"x\", \"+\"))\n\n\ndef _extract_mode(args: tuple[Any, ...], kwargs: dict[str, Any]) -> str:\n    if \"mode\" in kwargs:\n        mode = kwargs.get(\"mode\")\n        return mode if isinstance(mode, str) else \"r\"\n    if len(args) >= 2 and isinstance(args[1], str):\n        return args[1]\n    return \"r\"\n\n\ndef _is_allowed_import_path(path: Any) -> bool:\n    \"\"\"Allow Python's import system to read stdlib/site-packages when filesystem='none'.\"\"\"\n\n    if not _IMPORT_ALLOWLIST_ROOTS:\n        return False\n\n    try:\n        fs_path = os.fspath(path)\n    except Exception:\n        return False\n\n    if isinstance(fs_path, bytes):\n        try:\n            fs_path = fs_path.decode(\"utf-8\", errors=\"ignore\")\n        except Exception:\n            return False\n\n    if not isinstance(fs_path, str) or not fs_path:\n        return False\n\n    abs_path = os.path.abspath(fs_path)\n    for root in _IMPORT_ALLOWLIST_ROOTS:\n        if abs_path == root or abs_path.startswith(root + os.sep):\n            return True\n    return False\n\n\ndef apply_memory_limit(max_memory_bytes: int | None) -> None:\n    \"\"\"Best-effort address space limit (native Python only).\"\"\"\n\n    if not max_memory_bytes:\n        return\n\n    try:\n        import resource  # Unix only\n\n        # RLIMIT_AS limits the total available address space.\n        resource.setrlimit(resource.RLIMIT_AS, (max_memory_bytes, max_memory_bytes))\n    except Exception:\n        # Best-effort: not all platforms support resource or RLIMIT_AS.\n        pass\n\n\ndef apply_cpu_time_limit(*, max_cpu_seconds: int | None = None, timeout_ms: int | None = None) -> None:\n    \"\"\"Best-effort CPU time limit (native Python only).\n\n    Notes:\n    - `resource.RLIMIT_CPU` is Unix-specific and uses seconds granularity.\n    - This is complementary to host-side wall clock timeouts (timeoutMs). CPU time\n      limits protect against tight loops that burn CPU while still making some\n      progress (e.g. printing / RPC).\n    \"\"\"\n\n    if max_cpu_seconds is None and timeout_ms is None:\n        return\n\n    limit_seconds = None\n    if isinstance(max_cpu_seconds, int) and max_cpu_seconds > 0:\n        limit_seconds = max_cpu_seconds\n    elif isinstance(timeout_ms, int) and timeout_ms > 0:\n        # RLIMIT_CPU is integer seconds; clamp to 1s minimum.\n        limit_seconds = max(1, (timeout_ms + 999) // 1000)\n\n    if not limit_seconds:\n        return\n\n    try:\n        import resource  # Unix only\n\n        # Provide a small grace window between soft/hard limits so the runtime\n        # can exit cleanly after SIGXCPU (default action is termination).\n        resource.setrlimit(resource.RLIMIT_CPU, (limit_seconds, limit_seconds + 1))\n    except Exception:\n        # Best-effort: not all platforms support resource or RLIMIT_CPU.\n        pass\n\n\ndef _normalize_hostname(host: str) -> str:\n    host = host.strip().lower()\n    if host.startswith(\"[\") and host.endswith(\"]\"):\n        host = host[1:-1]\n    return host.rstrip(\".\")\n\n\ndef _extract_hostname(address: Any) -> str | None:\n    host: Any\n    if isinstance(address, (tuple, list)):\n        if not address:\n            return None\n        host = address[0]\n    else:\n        host = address\n\n    if isinstance(host, bytes):\n        try:\n            host = host.decode(\"utf-8\", errors=\"ignore\")\n        except Exception:\n            return None\n\n    if isinstance(host, str):\n        normalized = _normalize_hostname(host)\n        return normalized or None\n\n    return None\n\n\ndef _parse_network_allowlist(raw: Any) -> tuple[set[str], tuple[str, ...]]:\n    \"\"\"Return (exact_matches, wildcard_suffixes).\"\"\"\n\n    if not isinstance(raw, (list, tuple, set)):\n        return set(), ()\n\n    exact: set[str] = set()\n    wildcard_suffixes: list[str] = []\n\n    for item in raw:\n        if not isinstance(item, str):\n            continue\n        entry = _normalize_hostname(item)\n        if not entry:\n            continue\n        if entry.startswith(\"*.\") and len(entry) > 2:\n            suffix = entry[2:]\n            if suffix:\n                wildcard_suffixes.append(suffix)\n        else:\n            exact.add(entry)\n\n    # Keep deterministic ordering for easier debugging.\n    return exact, tuple(sorted(set(wildcard_suffixes)))\n\n\ndef _hostname_in_allowlist(hostname: str, exact: set[str], wildcard_suffixes: tuple[str, ...]) -> bool:\n    if hostname in exact:\n        return True\n    for suffix in wildcard_suffixes:\n        # \"*.example.com\" should match \"api.example.com\" (and deeper), but not\n        # the bare \"example.com\".\n        if hostname != suffix and hostname.endswith(f\".{suffix}\"):\n            return True\n    return False\n\n\ndef _apply_network_audit_policy(network: str, permissions: Dict[str, Any]) -> None:\n    \"\"\"Best-effort network enforcement via Python audit hooks (native only).\"\"\"\n\n    global _AUDIT_HOOK_INSTALLED\n    global _AUDIT_NETWORK_MODE\n    global _AUDIT_NETWORK_ALLOWLIST_EXACT\n    global _AUDIT_NETWORK_ALLOWLIST_WILDCARDS\n\n    _AUDIT_NETWORK_MODE = network\n\n    raw_allowlist = permissions.get(\"networkAllowlist\", permissions.get(\"network_allowlist\", []))\n    if network == \"allowlist\":\n        exact, wildcard_suffixes = _parse_network_allowlist(raw_allowlist)\n        _AUDIT_NETWORK_ALLOWLIST_EXACT = exact\n        _AUDIT_NETWORK_ALLOWLIST_WILDCARDS = wildcard_suffixes\n    else:\n        _AUDIT_NETWORK_ALLOWLIST_EXACT = set()\n        _AUDIT_NETWORK_ALLOWLIST_WILDCARDS = ()\n\n    if _AUDIT_HOOK_INSTALLED or not hasattr(sys, \"addaudithook\"):\n        return\n\n    def audit_hook(event: str, args: Any) -> None:\n        mode = _AUDIT_NETWORK_MODE\n        if mode == \"full\":\n            return\n        if not isinstance(event, str) or not event.startswith(\"socket.\"):\n            return\n\n        if mode == \"none\":\n            raise PermissionError(\"Network access is not permitted\")\n\n        if mode != \"allowlist\":\n            return\n\n        hostname: str | None = None\n        if event in {\"socket.connect\", \"socket.sendto\", \"socket.sendmsg\", \"socket.getnameinfo\"}:\n            if isinstance(args, tuple) and len(args) >= 2:\n                hostname = _extract_hostname(args[1])\n            elif event == \"socket.getnameinfo\" and isinstance(args, tuple) and args:\n                hostname = _extract_hostname(args[0])\n        elif event == \"socket.getaddrinfo\":\n            if isinstance(args, tuple) and args:\n                host = args[0]\n                if isinstance(host, bytes):\n                    try:\n                        host = host.decode(\"utf-8\", errors=\"ignore\")\n                    except Exception:\n                        host = None\n                if isinstance(host, str):\n                    hostname = _normalize_hostname(host)\n        elif event in {\"socket.gethostbyname\", \"socket.gethostbyaddr\"}:\n            if isinstance(args, tuple) and args:\n                host = args[0]\n                if isinstance(host, bytes):\n                    try:\n                        host = host.decode(\"utf-8\", errors=\"ignore\")\n                    except Exception:\n                        host = None\n                if isinstance(host, str):\n                    hostname = _normalize_hostname(host)\n        else:\n            return\n\n        if hostname is None or not _hostname_in_allowlist(\n            hostname, _AUDIT_NETWORK_ALLOWLIST_EXACT, _AUDIT_NETWORK_ALLOWLIST_WILDCARDS\n        ):\n            raise PermissionError(f\"Network access to {hostname!r} is not permitted\")\n\n    try:\n        sys.addaudithook(audit_hook)\n        _AUDIT_HOOK_INSTALLED = True\n    except Exception:\n        # Best-effort: audit hooks are not available on all platforms/runtimes.\n        pass\n\n\ndef _apply_socket_network_policy(network: str, permissions: Dict[str, Any]) -> None:\n    \"\"\"Patch socket connection APIs for network allowlist enforcement.\"\"\"\n\n    global _ORIGINAL_SOCKET_CREATE_CONNECTION\n    global _ORIGINAL_SOCKET_CONNECT\n    global _ORIGINAL_SOCKET_CONNECT_EX\n    global _ORIGINAL_SOCKET_SENDTO\n    global _ORIGINAL_SOCKET_SENDMSG\n    global _ORIGINAL_SOCKET_GETADDRINFO\n    global _ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT\n    global _ORIGINAL_SOCKET_SOCKET_CLASS\n    global _ORIGINAL__SOCKET_SOCKET\n    global _ORIGINAL__SOCKET_SOCKETTYPE\n\n    try:\n        import sys\n\n        socket = sys.modules.get(\"socket\")\n        if socket is None:\n            # Avoid importing `socket` when `network=\"none\"` so scripts cannot\n            # bypass the import hook by grabbing a pre-imported module from\n            # sys.modules (e.g. to call `socket.socket.sendto`).\n            if network == \"none\":\n                return\n            import socket as socket  # type: ignore\n    except Exception:\n        return\n\n    if _ORIGINAL_SOCKET_CREATE_CONNECTION is None:\n        _ORIGINAL_SOCKET_CREATE_CONNECTION = getattr(socket, \"create_connection\", None)\n    if _ORIGINAL_SOCKET_CONNECT is None:\n        _ORIGINAL_SOCKET_CONNECT = getattr(socket.socket, \"connect\", None)\n    if _ORIGINAL_SOCKET_CONNECT_EX is None:\n        _ORIGINAL_SOCKET_CONNECT_EX = getattr(socket.socket, \"connect_ex\", None)\n    if _ORIGINAL_SOCKET_SENDTO is None:\n        _ORIGINAL_SOCKET_SENDTO = getattr(socket.socket, \"sendto\", None)\n    if _ORIGINAL_SOCKET_SENDMSG is None:\n        _ORIGINAL_SOCKET_SENDMSG = getattr(socket.socket, \"sendmsg\", None)\n    if _ORIGINAL_SOCKET_GETADDRINFO is None:\n        _ORIGINAL_SOCKET_GETADDRINFO = getattr(socket, \"getaddrinfo\", None)\n    if _ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT is None:\n        _ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT = getattr(socket, \"_GLOBAL_DEFAULT_TIMEOUT\", object())\n    if _ORIGINAL_SOCKET_SOCKET_CLASS is None:\n        _ORIGINAL_SOCKET_SOCKET_CLASS = getattr(socket, \"socket\", None)\n\n    _socket_mod = getattr(socket, \"_socket\", None)\n    if _socket_mod is not None:\n        if _ORIGINAL__SOCKET_SOCKET is None:\n            _ORIGINAL__SOCKET_SOCKET = getattr(_socket_mod, \"socket\", None)\n        if _ORIGINAL__SOCKET_SOCKETTYPE is None:\n            _ORIGINAL__SOCKET_SOCKETTYPE = getattr(_socket_mod, \"SocketType\", None)\n\n    # Restore first so apply_sandbox() can both tighten and loosen restrictions.\n    if _ORIGINAL_SOCKET_CREATE_CONNECTION is not None:\n        try:\n            socket.create_connection = _ORIGINAL_SOCKET_CREATE_CONNECTION  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_CONNECT is not None:\n        try:\n            socket.socket.connect = _ORIGINAL_SOCKET_CONNECT  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_CONNECT_EX is not None:\n        try:\n            socket.socket.connect_ex = _ORIGINAL_SOCKET_CONNECT_EX  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_SENDTO is not None:\n        try:\n            socket.socket.sendto = _ORIGINAL_SOCKET_SENDTO  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_SENDMSG is not None:\n        try:\n            socket.socket.sendmsg = _ORIGINAL_SOCKET_SENDMSG  # type: ignore[assignment]\n        except Exception:\n            pass\n\n    if _socket_mod is not None:\n        if _ORIGINAL__SOCKET_SOCKET is not None:\n            try:\n                setattr(_socket_mod, \"socket\", _ORIGINAL__SOCKET_SOCKET)\n            except Exception:\n                pass\n        if _ORIGINAL__SOCKET_SOCKETTYPE is not None:\n            try:\n                setattr(_socket_mod, \"SocketType\", _ORIGINAL__SOCKET_SOCKETTYPE)\n            except Exception:\n                pass\n\n    if network == \"full\":\n        return\n\n    raw_allowlist = permissions.get(\"networkAllowlist\", permissions.get(\"network_allowlist\", []))\n    exact, wildcard_suffixes = _parse_network_allowlist(raw_allowlist) if network == \"allowlist\" else (set(), ())\n\n    def enforce_hostname(hostname: str | None) -> None:\n        if hostname is None or not _hostname_in_allowlist(hostname, exact, wildcard_suffixes):\n            raise PermissionError(f\"Network access to {hostname!r} is not permitted\")\n\n    def guarded_connect(self, address):  # type: ignore[no-untyped-def]\n        enforce_hostname(_extract_hostname(address))\n        return _ORIGINAL_SOCKET_CONNECT(self, address)  # type: ignore[misc]\n\n    def guarded_connect_ex(self, address):  # type: ignore[no-untyped-def]\n        enforce_hostname(_extract_hostname(address))\n        return _ORIGINAL_SOCKET_CONNECT_EX(self, address)  # type: ignore[misc]\n\n    def guarded_sendto(self, data, *args, **kwargs):  # type: ignore[no-untyped-def]\n        # Signature: sendto(bytes[, flags], address)\n        address = None\n        if \"address\" in kwargs:\n            address = kwargs.get(\"address\")\n        elif len(args) == 1:\n            address = args[0]\n        elif len(args) >= 2:\n            address = args[1]\n\n        enforce_hostname(_extract_hostname(address))\n        return _ORIGINAL_SOCKET_SENDTO(self, data, *args, **kwargs)  # type: ignore[misc]\n\n    def guarded_sendmsg(self, *args, **kwargs):  # type: ignore[no-untyped-def]\n        # Signature: sendmsg(buffers[, ancdata[, flags[, address]]])\n        address = None\n        if \"address\" in kwargs:\n            address = kwargs.get(\"address\")\n        elif len(args) >= 4:\n            address = args[3]\n\n        if address is not None:\n            enforce_hostname(_extract_hostname(address))\n        return _ORIGINAL_SOCKET_SENDMSG(self, *args, **kwargs)  # type: ignore[misc]\n\n    def guarded_create_connection(\n        address, timeout=_ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT, source_address=None, all_errors=False\n    ):  # type: ignore[no-untyped-def]\n        \"\"\"\n        Re-implementation of socket.create_connection with allowlist enforcement.\n\n        We avoid delegating to the stdlib implementation directly because it can be\n        influenced by user monkeypatching (e.g. overriding socket.getaddrinfo),\n        which can otherwise be abused to bypass allowlist checks.\n        \"\"\"\n\n        enforce_hostname(_extract_hostname(address))\n\n        if (\n            _ORIGINAL_SOCKET_GETADDRINFO is None\n            or _ORIGINAL_SOCKET_SOCKET_CLASS is None\n            or not isinstance(address, (tuple, list))\n            or len(address) < 2\n        ):\n            # Fallback to the original implementation (best-effort).\n            return _ORIGINAL_SOCKET_CREATE_CONNECTION(address, timeout=timeout, source_address=source_address)  # type: ignore[misc]\n\n        host, port = address[0], address[1]\n        errors: list[BaseException] = []\n\n        try:\n            addr_infos = _ORIGINAL_SOCKET_GETADDRINFO(host, port, 0, getattr(socket, \"SOCK_STREAM\", 1))  # type: ignore[misc]\n        except Exception as err:\n            raise err\n\n        for res in addr_infos:\n            af, socktype, proto, _canonname, sa = res\n            sock_obj = None\n            try:\n                sock_obj = _ORIGINAL_SOCKET_SOCKET_CLASS(af, socktype, proto)\n                if timeout is not _ORIGINAL_SOCKET_GLOBAL_DEFAULT_TIMEOUT:\n                    sock_obj.settimeout(timeout)\n                if source_address:\n                    sock_obj.bind(source_address)\n                _ORIGINAL_SOCKET_CONNECT(sock_obj, (host, port))  # type: ignore[misc]\n                return sock_obj\n            except BaseException as err:\n                errors.append(err)\n                if sock_obj is not None:\n                    try:\n                        sock_obj.close()\n                    except Exception:\n                        pass\n\n        if all_errors:\n            try:\n                raise ExceptionGroup(\"create_connection failed\", errors)  # type: ignore[name-defined]\n            except NameError:\n                # Python < 3.11; fall back to the last error.\n                pass\n\n        if errors:\n            raise errors[-1]\n        raise OSError(\"getaddrinfo returns an empty list\")\n\n    if _ORIGINAL_SOCKET_CREATE_CONNECTION is not None:\n        try:\n            socket.create_connection = guarded_create_connection  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_CONNECT is not None:\n        try:\n            socket.socket.connect = guarded_connect  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_CONNECT_EX is not None:\n        try:\n            socket.socket.connect_ex = guarded_connect_ex  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_SENDTO is not None:\n        try:\n            socket.socket.sendto = guarded_sendto  # type: ignore[assignment]\n        except Exception:\n            pass\n    if _ORIGINAL_SOCKET_SENDMSG is not None:\n        try:\n            socket.socket.sendmsg = guarded_sendmsg  # type: ignore[assignment]\n        except Exception:\n            pass\n\n    # Prevent trivial allowlist bypasses via `import _socket; _socket.socket(...)`.\n    #\n    # We cannot monkeypatch methods on the builtin `_socket.socket` type itself\n    # (it's immutable), but we can replace the module-level constructor aliases\n    # with a guarded subclass that enforces the same allowlist policy.\n    if _socket_mod is not None and isinstance(_ORIGINAL__SOCKET_SOCKET, type):\n        BaseSocketType = _ORIGINAL__SOCKET_SOCKET\n\n        class GuardedSocketType(BaseSocketType):  # type: ignore[misc,valid-type]\n            __slots__ = ()\n\n            def connect(self, address):  # type: ignore[no-untyped-def]\n                enforce_hostname(_extract_hostname(address))\n                return super().connect(address)\n\n            def connect_ex(self, address):  # type: ignore[no-untyped-def]\n                enforce_hostname(_extract_hostname(address))\n                return super().connect_ex(address)\n\n            def sendto(self, data, *args, **kwargs):  # type: ignore[no-untyped-def]\n                address = None\n                if \"address\" in kwargs:\n                    address = kwargs.get(\"address\")\n                elif len(args) == 1:\n                    address = args[0]\n                elif len(args) >= 2:\n                    address = args[1]\n\n                enforce_hostname(_extract_hostname(address))\n                return super().sendto(data, *args, **kwargs)\n\n            def sendmsg(self, *args, **kwargs):  # type: ignore[no-untyped-def]\n                address = None\n                if \"address\" in kwargs:\n                    address = kwargs.get(\"address\")\n                elif len(args) >= 4:\n                    address = args[3]\n\n                if address is not None:\n                    enforce_hostname(_extract_hostname(address))\n                return super().sendmsg(*args, **kwargs)\n\n        try:\n            setattr(_socket_mod, \"socket\", GuardedSocketType)\n        except Exception:\n            pass\n        try:\n            setattr(_socket_mod, \"SocketType\", GuardedSocketType)\n        except Exception:\n            pass\n\n\ndef apply_sandbox(permissions: Dict[str, Any]) -> None:\n    \"\"\"\n    Apply lightweight sandbox restrictions for Python scripts.\n\n    Notes:\n    - This is not a hardened security boundary.\n    - In native Python, stdin is used for RPC, so input() is always disabled.\n    - Process execution is treated as an escape hatch and is only permitted when\n      both filesystem + network are fully enabled.\n    \"\"\"\n\n    filesystem = _filesystem_permission(permissions)\n    network = _network_permission(permissions)\n\n    _apply_network_audit_policy(network, permissions)\n\n    # Process execution is a common escape hatch for both filesystem and network\n    # restrictions (e.g. spawning `curl` or using shell redirection). Only allow\n    # it when both network + filesystem are explicitly fully enabled.\n    block_process_execution = not (filesystem == \"readwrite\" and network == \"full\")\n\n    def blocked_input(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Interactive input is not permitted\")\n\n    builtins.input = blocked_input  # type: ignore[assignment]\n\n    # Reset import hook first so we can reconfigure it based on current permissions.\n    builtins.__import__ = _ORIGINAL_IMPORT  # type: ignore[assignment]\n\n    # Network allowlist enforcement may need to import socket modules. Apply it\n    # after restoring the original import hook and before tightening filesystem\n    # restrictions so the standard library can load.\n    _apply_socket_network_policy(network, permissions)\n\n    def blocked_fs(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Filesystem access is not permitted\")\n\n    def blocked_fs_write(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Filesystem write access is not permitted\")\n\n    def blocked_process(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Process execution is not permitted\")\n\n    # ---- open() policy -----------------------------------------------------\n    if filesystem == \"readwrite\":\n        builtins.open = _ORIGINAL_OPEN  # type: ignore[assignment]\n        if _ORIGINAL_IO_OPEN is not None:\n            io.open = _ORIGINAL_IO_OPEN  # type: ignore[assignment]\n        if _io_builtin is not None and _ORIGINAL__IO_OPEN is not None:\n            _io_builtin.open = _ORIGINAL__IO_OPEN  # type: ignore[attr-defined]\n    elif filesystem == \"read\":\n\n        def guarded_open(*args: Any, **kwargs: Any) -> Any:\n            mode = _extract_mode(args, kwargs)\n            if _is_write_mode(mode):\n                raise PermissionError(\"Filesystem write access is not permitted\")\n            return _ORIGINAL_OPEN(*args, **kwargs)\n\n        builtins.open = guarded_open  # type: ignore[assignment]\n        io.open = guarded_open  # type: ignore[assignment]\n        if _io_builtin is not None:\n            _io_builtin.open = guarded_open  # type: ignore[attr-defined]\n    else:\n\n        def guarded_open(*args: Any, **kwargs: Any) -> Any:\n            mode = _extract_mode(args, kwargs)\n            if _is_write_mode(mode):\n                raise PermissionError(\"Filesystem access is not permitted\")\n\n            target = None\n            if args:\n                target = args[0]\n            elif \"file\" in kwargs:\n                target = kwargs.get(\"file\")\n\n            if not _is_allowed_import_path(target):\n                raise PermissionError(\"Filesystem access is not permitted\")\n\n            return _ORIGINAL_OPEN(*args, **kwargs)\n\n        builtins.open = guarded_open  # type: ignore[assignment]\n        io.open = guarded_open  # type: ignore[assignment]\n        if _io_builtin is not None:\n            _io_builtin.open = guarded_open  # type: ignore[attr-defined]\n\n    # ---- os.* filesystem policy -------------------------------------------\n    # Restore patched functions first so repeated apply_sandbox() calls can\n    # loosen restrictions.\n    for name, fn in _ORIGINAL_OS.items():\n        try:\n            setattr(os, name, fn)\n        except Exception:\n            pass\n\n    if filesystem == \"none\":\n        if \"listdir\" in _ORIGINAL_OS:\n\n            def guarded_listdir(path: Any = None) -> Any:\n                target = \".\" if path is None else path\n                if not _is_allowed_import_path(target):\n                    raise PermissionError(\"Filesystem access is not permitted\")\n                return _ORIGINAL_OS[\"listdir\"](target)\n\n            os.listdir = guarded_listdir  # type: ignore[assignment]\n\n        if \"scandir\" in _ORIGINAL_OS:\n\n            def guarded_scandir(path: Any = None) -> Any:\n                target = \".\" if path is None else path\n                if not _is_allowed_import_path(target):\n                    raise PermissionError(\"Filesystem access is not permitted\")\n                return _ORIGINAL_OS[\"scandir\"](target)\n\n            os.scandir = guarded_scandir  # type: ignore[assignment]\n\n        for name in _OS_FS_FUNCS:\n            if name in {\"listdir\", \"scandir\"}:\n                continue\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_fs)\n                except Exception:\n                    pass\n    elif filesystem == \"read\":\n        # Directory enumeration is permitted in read-only mode, but destructive\n        # operations are not.\n        for name in (\n            \"remove\",\n            \"unlink\",\n            \"rmdir\",\n            \"mkdir\",\n            \"makedirs\",\n            \"rename\",\n            \"replace\",\n            \"link\",\n            \"symlink\",\n        ):\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_fs_write)\n                except Exception:\n                    pass\n\n        if \"open\" in _ORIGINAL_OS:\n\n            def guarded_os_open(path: Any, flags: Any, *args: Any, **kwargs: Any) -> Any:\n                try:\n                    flags_i = int(flags)\n                except Exception:\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n\n                write_bits = (\n                    os.O_WRONLY\n                    | os.O_RDWR\n                    | getattr(os, \"O_APPEND\", 0)\n                    | getattr(os, \"O_CREAT\", 0)\n                    | getattr(os, \"O_TRUNC\", 0)\n                    | getattr(os, \"O_EXCL\", 0)\n                )\n                if flags_i & write_bits:\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n                return _ORIGINAL_OS[\"open\"](path, flags, *args, **kwargs)\n\n            os.open = guarded_os_open  # type: ignore[assignment]\n\n        if \"fdopen\" in _ORIGINAL_OS:\n\n            def guarded_fdopen(fd: Any, *args: Any, **kwargs: Any) -> Any:\n                mode = _extract_mode(args, kwargs)\n                if _is_write_mode(mode):\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n                return _ORIGINAL_OS[\"fdopen\"](fd, *args, **kwargs)\n\n            os.fdopen = guarded_fdopen  # type: ignore[assignment]\n\n    # ---- os.* process execution policy ------------------------------------\n    if block_process_execution:\n        for name in _OS_PROCESS_FUNCS:\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_process)\n                except Exception:\n                    pass\n\n    blocked_roots = set()\n    if block_process_execution:\n        blocked_roots.add(\"subprocess\")\n    if network == \"none\":\n        blocked_roots.update({\"socket\", \"_socket\", \"ssl\", \"_ssl\", \"http\", \"urllib\", \"requests\"})\n\n    if blocked_roots:\n\n        def guarded_import(name: str, globals=None, locals=None, fromlist=(), level: int = 0):\n            root = name.split(\".\", 1)[0]\n            if root in blocked_roots:\n                raise PermissionError(f\"Import of {root!r} is not permitted\")\n            return _ORIGINAL_IMPORT(name, globals, locals, fromlist, level)\n\n        builtins.__import__ = guarded_import  # type: ignore[assignment]\n",
  "formula/runtime/stdio_runner.py": "from __future__ import annotations\n\nimport builtins\nimport importlib.machinery\nimport importlib._bootstrap\nimport json\nimport sys\nimport traceback\nimport types\nfrom typing import Any, Dict\n\nimport formula\nfrom formula._rpc_bridge import StdioRpcBridge\nfrom formula.runtime.sandbox import apply_cpu_time_limit, apply_memory_limit, apply_sandbox\n\n_ORIGINAL_IMPORT = builtins.__import__\n\n\ndef _normalize_permission(value: Any, allowed: set[str], default: str) -> str:\n    if not isinstance(value, str):\n        return default\n    lowered = value.lower()\n    return lowered if lowered in allowed else default\n\n\ndef _filesystem_permission(permissions: Dict[str, Any]) -> str:\n    raw = permissions.get(\"filesystem\", permissions.get(\"fileSystem\", \"none\"))\n    return _normalize_permission(raw, {\"none\", \"read\", \"readwrite\"}, \"none\")\n\n\ndef _network_permission(permissions: Dict[str, Any]) -> str:\n    raw = permissions.get(\"network\", \"none\")\n    return _normalize_permission(raw, {\"none\", \"allowlist\", \"full\"}, \"none\")\n\n\ndef _normalize_hostname(host: str) -> str:\n    host = host.strip().lower()\n    if host.startswith(\"[\") and host.endswith(\"]\"):\n        host = host[1:-1]\n    return host.rstrip(\".\")\n\n\ndef _parse_network_allowlist(raw: Any) -> tuple[set[str], tuple[str, ...]]:\n    if not isinstance(raw, (list, tuple, set)):\n        return set(), ()\n\n    exact: set[str] = set()\n    wildcard_suffixes: set[str] = set()\n\n    for item in raw:\n        if not isinstance(item, str):\n            continue\n        entry = _normalize_hostname(item)\n        if not entry:\n            continue\n        if entry.startswith(\"*.\") and len(entry) > 2:\n            wildcard_suffixes.add(entry[2:])\n        else:\n            exact.add(entry)\n\n    return exact, tuple(sorted(wildcard_suffixes))\n\n\ndef _hostname_in_allowlist(hostname: str, exact: set[str], wildcard_suffixes: tuple[str, ...]) -> bool:\n    if hostname in exact:\n        return True\n    for suffix in wildcard_suffixes:\n        if hostname != suffix and hostname.endswith(f\".{suffix}\"):\n            return True\n    return False\n\n\ndef _extract_hostname(value: Any) -> str | None:\n    host: Any\n    if isinstance(value, (tuple, list)):\n        if not value:\n            return None\n        host = value[0]\n    else:\n        host = value\n\n    if isinstance(host, bytes):\n        try:\n            host = host.decode(\"utf-8\", errors=\"ignore\")\n        except Exception:\n            return None\n\n    if isinstance(host, str):\n        normalized = _normalize_hostname(host)\n        return normalized or None\n\n    return None\n\n\ndef _install_network_audit_hook(network: str, permissions: Dict[str, Any]) -> None:\n    \"\"\"Best-effort network enforcement via sys.addaudithook (native only).\"\"\"\n\n    if network == \"full\" or not hasattr(sys, \"addaudithook\"):\n        return\n\n    raw_allowlist = permissions.get(\"networkAllowlist\", permissions.get(\"network_allowlist\", []))\n    exact, wildcard_suffixes = _parse_network_allowlist(raw_allowlist)\n\n    def audit_hook(event: str, args: Any) -> None:\n        if not isinstance(event, str) or not event.startswith(\"socket.\"):\n            return\n\n        if network == \"none\":\n            raise PermissionError(\"Network access is not permitted\")\n\n        # allowlist enforcement\n        hostname: str | None = None\n        if event in {\"socket.connect\", \"socket.sendto\", \"socket.sendmsg\"}:\n            if isinstance(args, tuple) and len(args) >= 2:\n                hostname = _extract_hostname(args[1])\n        elif event == \"socket.getaddrinfo\":\n            if isinstance(args, tuple) and args:\n                hostname = _extract_hostname(args[0])\n        elif event in {\"socket.gethostbyname\", \"socket.gethostbyaddr\"}:\n            if isinstance(args, tuple) and args:\n                hostname = _extract_hostname(args[0])\n        elif event == \"socket.getnameinfo\":\n            if isinstance(args, tuple) and args:\n                hostname = _extract_hostname(args[0])\n        else:\n            return\n\n        if hostname is None or not _hostname_in_allowlist(hostname, exact, wildcard_suffixes):\n            raise PermissionError(f\"Network access to {hostname!r} is not permitted\")\n\n    try:\n        sys.addaudithook(audit_hook)\n    except Exception:\n        pass\n\n\ndef main() -> None:\n    # Stdout is reserved for protocol messages. Redirect user output to stderr so\n    # prints don't corrupt the JSON stream.\n    protocol_out = sys.stdout\n    sys.stdout = sys.stderr  # type: ignore[assignment]\n    sys.__stdout__ = sys.stderr  # type: ignore[assignment]\n\n    first_line = sys.stdin.readline()\n    if not first_line:\n        return\n\n    cmd = json.loads(first_line)\n    if cmd.get(\"type\") != \"execute\":\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": False, \"error\": \"Invalid command\"}) + \"\\n\")\n        protocol_out.flush()\n        return\n\n    apply_memory_limit(cmd.get(\"max_memory_bytes\"))\n    apply_cpu_time_limit(\n        max_cpu_seconds=cmd.get(\"max_cpu_seconds\"),\n        timeout_ms=cmd.get(\"timeout_ms\", cmd.get(\"timeoutMs\")),\n    )\n\n    permissions = cmd.get(\"permissions\", {}) if isinstance(cmd.get(\"permissions\", {}), dict) else {}\n    filesystem = _filesystem_permission(permissions)\n    network = _network_permission(permissions)\n\n    _install_network_audit_hook(network, permissions)\n\n    # Configure the bridge before applying sandbox restrictions so our own\n    # imports aren't blocked.\n    bridge = StdioRpcBridge(protocol_in=sys.stdin, protocol_out=protocol_out)\n    formula.set_bridge(bridge)\n\n    apply_sandbox(permissions)\n\n    try:\n        block_process_execution = not (filesystem == \"readwrite\" and network == \"full\")\n\n        blocked_import_roots = set()\n        if block_process_execution:\n            blocked_import_roots.add(\"subprocess\")\n        if network == \"none\":\n            blocked_import_roots.update({\"socket\", \"_socket\", \"ssl\", \"_ssl\", \"http\", \"urllib\", \"requests\"})\n\n        # This runner is executed as `__main__` (via `python -m`). If user code imports\n        # `__main__`, it should see its own module, not the stdio runner internals.\n        #\n        # Also, removing the runner + sandbox modules from `sys.modules` reduces the\n        # chance that a script can bypass restrictions by restoring captured original\n        # functions (best-effort; not a hardened security boundary).\n        user_main = types.ModuleType(\"__main__\")\n        user_main.__dict__.update({\"__name__\": \"__main__\", \"__file__\": \"<formula_script>\", \"__package__\": None})\n        sys.modules[\"__main__\"] = user_main\n\n        # Restore the builtin import function (avoid exposing the pre-sandbox import\n        # callable via `builtins.__import__.__globals__`) and block imports via a\n        # meta_path finder instead.\n        builtins.__import__ = _ORIGINAL_IMPORT  # type: ignore[assignment]\n\n        class _ImportBlocker:\n            def find_spec(self, fullname: str, path=None, target=None):  # type: ignore[no-untyped-def]\n                if fullname == \"formula.runtime\" or fullname.startswith(\"formula.runtime.\"):\n                    raise PermissionError(\"Import of 'formula.runtime' is not permitted\")\n\n                root = fullname.split(\".\", 1)[0]\n                if root in blocked_import_roots:\n                    raise PermissionError(f\"Import of {root!r} is not permitted\")\n                return None\n\n        if blocked_import_roots:\n            # Purge already-imported modules so import statements consult meta_path.\n            for name in list(sys.modules.keys()):\n                root = name.split(\".\", 1)[0]\n                if root in blocked_import_roots:\n                    sys.modules.pop(name, None)\n\n            sys.meta_path.insert(0, _ImportBlocker())\n\n            # Best-effort: disallow module reloads while sandboxing is active.\n            # Reloading core modules like `socket` can restore unpatched connection\n            # methods and bypass the allowlist policy.\n            try:\n                def blocked_reload(module):  # type: ignore[no-untyped-def]\n                    name = getattr(module, \"__name__\", \"<unknown>\")\n                    raise PermissionError(f\"Reload of {name!r} is not permitted\")\n\n                importlib.reload = blocked_reload  # type: ignore[assignment]\n            except Exception:\n                pass\n\n            # Best-effort: block common importlib escape hatches that can load\n            # built-in modules directly without consulting sys.meta_path.\n            try:\n                original_builtin_from_name = importlib._bootstrap._builtin_from_name  # type: ignore[attr-defined]\n\n                def guarded_builtin_from_name(name: str):  # type: ignore[no-untyped-def]\n                    root = name.split(\".\", 1)[0]\n                    if root in blocked_import_roots:\n                        raise PermissionError(f\"Import of {root!r} is not permitted\")\n                    return original_builtin_from_name(name)\n\n                importlib._bootstrap._builtin_from_name = guarded_builtin_from_name  # type: ignore[attr-defined]\n            except Exception:\n                pass\n\n            try:\n                original_load_module = importlib.machinery.BuiltinImporter.load_module\n\n                def guarded_load_module(name: str):  # type: ignore[no-untyped-def]\n                    root = name.split(\".\", 1)[0]\n                    if root in blocked_import_roots:\n                        raise PermissionError(f\"Import of {root!r} is not permitted\")\n                    return original_load_module(name)\n\n                importlib.machinery.BuiltinImporter.load_module = guarded_load_module  # type: ignore[assignment]\n            except Exception:\n                pass\n\n            try:\n                original_find_spec = importlib.machinery.BuiltinImporter.find_spec\n\n                def guarded_find_spec(fullname: str, path=None, target=None):  # type: ignore[no-untyped-def]\n                    root = fullname.split(\".\", 1)[0]\n                    if root in blocked_import_roots:\n                        raise PermissionError(f\"Import of {root!r} is not permitted\")\n                    return original_find_spec(fullname, path, target)\n\n                importlib.machinery.BuiltinImporter.find_spec = guarded_find_spec  # type: ignore[assignment]\n            except Exception:\n                pass\n\n            try:\n                original_create_module = importlib.machinery.BuiltinImporter.create_module\n\n                def guarded_create_module(spec):  # type: ignore[no-untyped-def]\n                    name = getattr(spec, \"name\", \"\")\n                    root = name.split(\".\", 1)[0] if isinstance(name, str) else \"\"\n                    if root in blocked_import_roots:\n                        raise PermissionError(f\"Import of {root!r} is not permitted\")\n                    return original_create_module(spec)\n\n                importlib.machinery.BuiltinImporter.create_module = guarded_create_module  # type: ignore[assignment]\n            except Exception:\n                pass\n\n            try:\n                original_exec_module = importlib.machinery.BuiltinImporter.exec_module\n\n                def guarded_exec_module(module):  # type: ignore[no-untyped-def]\n                    name = getattr(module, \"__name__\", \"\")\n                    root = name.split(\".\", 1)[0] if isinstance(name, str) else \"\"\n                    if root in blocked_import_roots:\n                        raise PermissionError(f\"Import of {root!r} is not permitted\")\n                    return original_exec_module(module)\n\n                importlib.machinery.BuiltinImporter.exec_module = guarded_exec_module  # type: ignore[assignment]\n            except Exception:\n                pass\n\n        # Drop references to the runner + sandbox modules so scripts can't fetch them\n        # directly from sys.modules (e.g. to restore original import/open functions).\n        for name in list(sys.modules.keys()):\n            if name == \"formula.runtime\" or name.startswith(\"formula.runtime.\"):\n                sys.modules.pop(name, None)\n\n        formula_mod = sys.modules.get(\"formula\")\n        if formula_mod is not None and hasattr(formula_mod, \"runtime\"):\n            try:\n                delattr(formula_mod, \"runtime\")\n            except Exception:\n                pass\n\n        globals_dict: Dict[str, Any] = user_main.__dict__\n        exec(cmd.get(\"code\", \"\"), globals_dict, globals_dict)\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": True}) + \"\\n\")\n        protocol_out.flush()\n    except Exception as err:\n        protocol_out.write(\n            json.dumps(\n                {\n                    \"type\": \"result\",\n                    \"success\": False,\n                    \"error\": str(err),\n                    \"traceback\": traceback.format_exc(),\n                }\n            )\n            + \"\\n\"\n        )\n        protocol_out.flush()\n\n\nif __name__ == \"__main__\":\n    main()\n"
};
