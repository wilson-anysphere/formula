// THIS FILE IS AUTO-GENERATED
// Run: node packages/python-runtime/scripts/generate-formula-files.js
//
// It bundles the in-repo python/formula_api package into a JS object so the
// Pyodide worker can install it into its virtual filesystem.

export const formulaFiles = {
  "formula/__init__.py": "\"\"\"\n`formula` â€“ Python scripting API for Formula spreadsheets.\n\nThis module is designed to run in two environments:\n\n1. Pyodide (browser/webview): spreadsheet operations are bridged via a JS module\n   injected into the Pyodide runtime.\n2. Native Python (desktop): spreadsheet operations are bridged via a JSON-RPC\n   transport (stdio/IPC).\n\nThe public API intentionally mirrors the conceptual model from\ndocs/08-macro-compatibility.md:\n\n- `active_sheet` (dynamic attribute)\n- `get_sheet(name)`\n- `create_sheet(name)`\n- Sheet and Range objects with convenient cell/range accessors\n- Optional pandas helpers (`to_dataframe`, `from_dataframe`)\n- `@custom_function` decorator for UDF registration\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union\n\nfrom ._a1 import parse_a1\nfrom ._bridge import Bridge\n\n_bridge: Optional[Bridge] = None\n\n\ndef set_bridge(bridge: Bridge) -> None:\n    \"\"\"Configure the runtime bridge used to talk to the host spreadsheet.\"\"\"\n\n    global _bridge\n    _bridge = bridge\n\n\ndef _require_bridge() -> Bridge:\n    if _bridge is None:\n        raise RuntimeError(\n            \"formula bridge is not configured. \"\n            \"If you're running natively, use formula.runtime.stdio_runner. \"\n            \"If you're running in Pyodide, inject a `formula_bridge` module and \"\n            \"call formula.set_bridge(...) from your runtime.\"\n        )\n    return _bridge\n\n\ndef __getattr__(name: str) -> Any:\n    # PEP 562: module-level dynamic attributes.\n    if name == \"active_sheet\":\n        bridge = _require_bridge()\n        sheet_id = bridge.get_active_sheet_id()\n        return Sheet(sheet_id=sheet_id, bridge=bridge)\n    raise AttributeError(name)\n\n\ndef get_sheet(name: str) -> \"Sheet\":\n    bridge = _require_bridge()\n    sheet_id = bridge.get_sheet_id(name)\n    if sheet_id is None:\n        raise KeyError(f\"Sheet not found: {name!r}\")\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef create_sheet(name: str) -> \"Sheet\":\n    bridge = _require_bridge()\n    sheet_id = bridge.create_sheet(name)\n    return Sheet(sheet_id=sheet_id, bridge=bridge)\n\n\ndef _pandas() -> Any:\n    try:\n        import pandas as pd  # type: ignore\n\n        return pd\n    except Exception:  # pragma: no cover - environment dependent\n        return None\n\n\n@dataclass(frozen=True)\nclass RangeRef:\n    sheet_id: str\n    start_row: int\n    start_col: int\n    end_row: int\n    end_col: int\n\n    @property\n    def is_single_cell(self) -> bool:\n        return self.start_row == self.end_row and self.start_col == self.end_col\n\n\nclass Sheet:\n    \"\"\"Represents a worksheet in the spreadsheet.\"\"\"\n\n    def __init__(self, sheet_id: str, bridge: Bridge):\n        self._id = sheet_id\n        self._bridge = bridge\n\n    @property\n    def id(self) -> str:\n        return self._id\n\n    @property\n    def name(self) -> str:\n        return self._bridge.get_sheet_name(self._id)\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self._bridge.rename_sheet(self._id, value)\n\n    def __getitem__(self, key: str) -> \"Range\":\n        # Access cells via sheet[\"A1\"] or sheet[\"A1:B10\"].\n        start_row, start_col, end_row, end_col = parse_a1(key)\n        return Range(\n            ref=RangeRef(\n                sheet_id=self._id,\n                start_row=start_row,\n                start_col=start_col,\n                end_row=end_row,\n                end_col=end_col,\n            ),\n            bridge=self._bridge,\n        )\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        self[key].value = value\n\n\nclass Range:\n    \"\"\"Represents a range of cells.\"\"\"\n\n    def __init__(self, ref: RangeRef, bridge: Bridge):\n        self._ref = ref\n        self._bridge = bridge\n\n    @property\n    def ref(self) -> RangeRef:\n        return self._ref\n\n    @property\n    def value(self) -> Any:\n        values = self._bridge.get_range_values(self._ref.__dict__)\n        if self._ref.is_single_cell:\n            return values[0][0] if values and values[0] else None\n        return values\n\n    @value.setter\n    def value(self, val: Any) -> None:\n        pd = _pandas()\n        if pd is not None and isinstance(val, pd.DataFrame):\n            self.from_dataframe(val)\n            return\n\n        if self._ref.is_single_cell and isinstance(val, str) and val.startswith(\"=\"):\n            self.formula = val\n            return\n\n        if self._ref.is_single_cell and not isinstance(val, (list, tuple)):\n            self._bridge.set_cell_value(self._ref.__dict__, val)\n            return\n\n        # Convenience: allow 1D sequences for single-row or single-column ranges.\n        if (\n            not self._ref.is_single_cell\n            and isinstance(val, (list, tuple))\n            and (len(val) == 0 or not isinstance(val[0], (list, tuple)))\n        ):\n            row_count = self._ref.end_row - self._ref.start_row + 1\n            col_count = self._ref.end_col - self._ref.start_col + 1\n            if row_count == 1:\n                if len(val) != col_count:\n                    raise ValueError(\n                        f\"Range expects {col_count} values for a 1x{col_count} row range, got {len(val)}\"\n                    )\n                val = [list(val)]\n            elif col_count == 1:\n                if len(val) != row_count:\n                    raise ValueError(\n                        f\"Range expects {row_count} values for a {row_count}x1 column range, got {len(val)}\"\n                    )\n                val = [[v] for v in val]\n            else:\n                raise TypeError(\n                    \"Range.value expects a 2D list for multi-cell ranges \"\n                    \"(a 1D list is only allowed for single-row or single-column ranges)\"\n                )\n\n        self._bridge.set_range_values(self._ref.__dict__, val)\n\n    @property\n    def formula(self) -> Optional[str]:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        return self._bridge.get_cell_formula(self._ref.__dict__)\n\n    @formula.setter\n    def formula(self, val: str) -> None:\n        if not self._ref.is_single_cell:\n            raise ValueError(\"Range.formula is only available for a single cell range\")\n        self._bridge.set_cell_formula(self._ref.__dict__, val)\n\n    def clear(self) -> None:\n        self._bridge.clear_range(self._ref.__dict__)\n\n    def to_dataframe(self, header: bool = True) -> Any:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n\n        values = self.value\n        if not isinstance(values, list):\n            return pd.DataFrame([[values]])\n\n        if header and values:\n            return pd.DataFrame(values[1:], columns=values[0])\n        return pd.DataFrame(values)\n\n    def from_dataframe(self, df: Any, include_header: bool = True) -> None:\n        pd = _pandas()\n        if pd is None:  # pragma: no cover - environment dependent\n            raise ImportError(\"pandas is not available in this Python runtime\")\n        if not isinstance(df, pd.DataFrame):  # type: ignore[attr-defined]\n            raise TypeError(\"from_dataframe expects a pandas.DataFrame\")\n\n        values: List[List[Any]] = []\n        if include_header:\n            values.append([str(col) for col in df.columns.tolist()])\n        values.extend(df.values.tolist())\n\n        self._bridge.set_range_values(self._ref.__dict__, values)\n\n\n_function_registry: Dict[str, Callable[..., Any]] = {}\n\n\ndef custom_function(func: Optional[Callable[..., Any]] = None, *, name: Optional[str] = None) -> Any:\n    \"\"\"Decorator to register a Python function as a spreadsheet custom function.\"\"\"\n\n    def register(fn: Callable[..., Any]) -> Callable[..., Any]:\n        _function_registry[name or fn.__name__] = fn\n        return fn\n\n    return register(func) if func is not None else register\n\n\ndef list_custom_functions() -> List[str]:\n    return sorted(_function_registry.keys())\n",
  "formula/_a1.py": "from __future__ import annotations\n\nimport re\nfrom typing import Tuple\n\n_CELL_RE = re.compile(r\"^([A-Za-z]+)([0-9]+)$\")\n_RANGE_RE = re.compile(r\"^([A-Za-z]+[0-9]+)(?::([A-Za-z]+[0-9]+))?$\")\n\n\ndef _col_letters_to_index(letters: str) -> int:\n    col = 0\n    for ch in letters.upper():\n        if ch < \"A\" or ch > \"Z\":\n            raise ValueError(f\"Invalid column letter: {ch!r}\")\n        col = col * 26 + (ord(ch) - ord(\"A\") + 1)\n    return col - 1\n\n\ndef _parse_cell(cell: str) -> Tuple[int, int]:\n    m = _CELL_RE.match(cell)\n    if not m:\n        raise ValueError(f\"Invalid A1 cell reference: {cell!r}\")\n    col_letters, row_digits = m.groups()\n    row = int(row_digits) - 1\n    col = _col_letters_to_index(col_letters)\n    if row < 0:\n        raise ValueError(f\"Invalid row in A1 reference: {cell!r}\")\n    return row, col\n\n\ndef parse_a1(ref: str) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parse an A1-style range like \"A1\" or \"A1:B10\".\n\n    Returns a tuple: (start_row, start_col, end_row, end_col) with 0-indexed\n    coordinates.\n    \"\"\"\n\n    m = _RANGE_RE.match(ref.strip())\n    if not m:\n        raise ValueError(f\"Invalid A1 reference: {ref!r}\")\n\n    start_cell, end_cell = m.groups()\n    start_row, start_col = _parse_cell(start_cell)\n    if end_cell is None:\n        return start_row, start_col, start_row, start_col\n\n    end_row, end_col = _parse_cell(end_cell)\n    if end_row < start_row or end_col < start_col:\n        raise ValueError(f\"Invalid A1 range (end before start): {ref!r}\")\n\n    return start_row, start_col, end_row, end_col\n\n",
  "formula/_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional, Protocol\n\n\nclass Bridge(Protocol):\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str: ...\n\n    def get_sheet_id(self, name: str) -> Optional[str]: ...\n\n    def create_sheet(self, name: str) -> str: ...\n\n    def get_sheet_name(self, sheet_id: str) -> str: ...\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None: ...\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]: ...\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None: ...\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None: ...\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]: ...\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None: ...\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None: ...\n\n",
  "formula/_js_bridge.py": "from __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\n# When running under Pyodide, the JS runtime registers a `formula_bridge` module\n# (via `pyodide.registerJsModule`). Importing it here provides the host callback\n# surface for spreadsheet operations.\nimport formula_bridge  # type: ignore\n\ntry:  # pragma: no cover - only available in Pyodide\n    from pyodide.ffi import to_py  # type: ignore\nexcept Exception:  # pragma: no cover - native Python\n\n    def to_py(value: Any) -> Any:\n        return value\n\n\nclass JsBridge:\n    \"\"\"Bridge implementation backed by a JS module (Pyodide/WebView).\"\"\"\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(formula_bridge.get_active_sheet_id())\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return to_py(formula_bridge.get_sheet_id(name))\n\n    def create_sheet(self, name: str) -> str:\n        return str(formula_bridge.create_sheet(name))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(formula_bridge.get_sheet_name(sheet_id))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        formula_bridge.rename_sheet(sheet_id, name)\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return to_py(formula_bridge.get_range_values(range_ref))\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        formula_bridge.set_range_values(range_ref, values)\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        formula_bridge.set_cell_value(range_ref, value)\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return to_py(formula_bridge.get_cell_formula(range_ref))\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        formula_bridge.set_cell_formula(range_ref, formula)\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        formula_bridge.clear_range(range_ref)\n\n",
  "formula/_rpc_bridge.py": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Optional, TextIO\n\n\nclass StdioRpcBridge:\n    \"\"\"\n    JSON-RPC-ish bridge over stdio.\n\n    The host (Formula app) is expected to read request messages from stdout and\n    write response messages to stdin.\n\n    Stdout is reserved for protocol messages; user script stdout should be\n    redirected to stderr by the runner to avoid corrupting the stream.\n    \"\"\"\n\n    def __init__(self, protocol_in: TextIO, protocol_out: TextIO):\n        self._in = protocol_in\n        self._out = protocol_out\n        self._next_id = 1\n\n    def _request(self, method: str, params: Any) -> Any:\n        msg_id = self._next_id\n        self._next_id += 1\n\n        self._out.write(json.dumps({\"type\": \"rpc\", \"id\": msg_id, \"method\": method, \"params\": params}) + \"\\n\")\n        self._out.flush()\n\n        while True:\n            line = self._in.readline()\n            if not line:\n                raise RuntimeError(f\"RPC connection closed while waiting for {method!r}\")\n            msg = json.loads(line)\n            if msg.get(\"type\") != \"rpc_response\":\n                continue\n            if msg.get(\"id\") != msg_id:\n                continue\n            if msg.get(\"error\"):\n                raise RuntimeError(msg[\"error\"])\n            return msg.get(\"result\")\n\n    # Workbook/sheet operations\n    def get_active_sheet_id(self) -> str:\n        return str(self._request(\"get_active_sheet_id\", None))\n\n    def get_sheet_id(self, name: str) -> Optional[str]:\n        return self._request(\"get_sheet_id\", {\"name\": name})\n\n    def create_sheet(self, name: str) -> str:\n        return str(self._request(\"create_sheet\", {\"name\": name}))\n\n    def get_sheet_name(self, sheet_id: str) -> str:\n        return str(self._request(\"get_sheet_name\", {\"sheet_id\": sheet_id}))\n\n    def rename_sheet(self, sheet_id: str, name: str) -> None:\n        self._request(\"rename_sheet\", {\"sheet_id\": sheet_id, \"name\": name})\n\n    # Range/cell operations\n    def get_range_values(self, range_ref: Dict[str, Any]) -> List[List[Any]]:\n        return self._request(\"get_range_values\", {\"range\": range_ref})\n\n    def set_range_values(self, range_ref: Dict[str, Any], values: Any) -> None:\n        self._request(\"set_range_values\", {\"range\": range_ref, \"values\": values})\n\n    def set_cell_value(self, range_ref: Dict[str, Any], value: Any) -> None:\n        self._request(\"set_cell_value\", {\"range\": range_ref, \"value\": value})\n\n    def get_cell_formula(self, range_ref: Dict[str, Any]) -> Optional[str]:\n        return self._request(\"get_cell_formula\", {\"range\": range_ref})\n\n    def set_cell_formula(self, range_ref: Dict[str, Any], formula: str) -> None:\n        self._request(\"set_cell_formula\", {\"range\": range_ref, \"formula\": formula})\n\n    def clear_range(self, range_ref: Dict[str, Any]) -> None:\n        self._request(\"clear_range\", {\"range\": range_ref})\n\n",
  "formula/runtime/__init__.py": "# Runtime helpers for Formula Python execution environments.\n\n",
  "formula/runtime/sandbox.py": "from __future__ import annotations\n\nimport builtins\nimport io\nimport os\nfrom typing import Any, Dict\n\n# Capture original references at import time so apply_sandbox() can be called\n# repeatedly (Pyodide worker) and can both tighten and loosen restrictions.\n_ORIGINAL_OPEN = builtins.open\n_ORIGINAL_IMPORT = builtins.__import__\n\ntry:  # pragma: no cover - implementation dependent\n    import _io as _io_builtin  # type: ignore\nexcept Exception:  # pragma: no cover - native only\n    _io_builtin = None\n\n_ORIGINAL_IO_OPEN = getattr(io, \"open\", None)\n_ORIGINAL__IO_OPEN = getattr(_io_builtin, \"open\", None) if _io_builtin else None\n\n_OS_FS_FUNCS = (\n    # File descriptor based access.\n    \"open\",\n    \"fdopen\",\n    # Directory enumeration.\n    \"listdir\",\n    \"scandir\",\n    # Destructive operations / mutations.\n    \"remove\",\n    \"unlink\",\n    \"rmdir\",\n    \"mkdir\",\n    \"makedirs\",\n    \"rename\",\n    \"replace\",\n    \"link\",\n    \"symlink\",\n    \"readlink\",\n    # Platform-specific helpers.\n    \"startfile\",\n)\n\n_OS_PROCESS_FUNCS = (\n    \"system\",\n    \"popen\",\n    \"spawnl\",\n    \"spawnle\",\n    \"spawnlp\",\n    \"spawnlpe\",\n    \"spawnv\",\n    \"spawnve\",\n    \"spawnvp\",\n    \"spawnvpe\",\n    \"execl\",\n    \"execle\",\n    \"execlp\",\n    \"execlpe\",\n    \"execv\",\n    \"execve\",\n    \"execvp\",\n    \"execvpe\",\n    \"startfile\",\n)\n\n_ORIGINAL_OS = {name: getattr(os, name) for name in set(_OS_FS_FUNCS + _OS_PROCESS_FUNCS) if hasattr(os, name)}\n\n\ndef _normalize_permission(value: Any, allowed: set[str], default: str) -> str:\n    if not isinstance(value, str):\n        return default\n    lowered = value.lower()\n    return lowered if lowered in allowed else default\n\n\ndef _filesystem_permission(permissions: Dict[str, Any]) -> str:\n    # Support the docs/08-macro-compatibility.md key casing as well.\n    raw = permissions.get(\"filesystem\", permissions.get(\"fileSystem\", \"none\"))\n    return _normalize_permission(raw, {\"none\", \"read\", \"readwrite\"}, \"none\")\n\n\ndef _network_permission(permissions: Dict[str, Any]) -> str:\n    raw = permissions.get(\"network\", \"none\")\n    return _normalize_permission(raw, {\"none\", \"allowlist\", \"full\"}, \"none\")\n\n\ndef _is_write_mode(mode: str) -> bool:\n    return any(ch in mode for ch in (\"w\", \"a\", \"x\", \"+\"))\n\n\ndef _extract_mode(args: tuple[Any, ...], kwargs: dict[str, Any]) -> str:\n    if \"mode\" in kwargs:\n        mode = kwargs.get(\"mode\")\n        return mode if isinstance(mode, str) else \"r\"\n    if len(args) >= 2 and isinstance(args[1], str):\n        return args[1]\n    return \"r\"\n\n\ndef apply_memory_limit(max_memory_bytes: int | None) -> None:\n    \"\"\"Best-effort address space limit (native Python only).\"\"\"\n\n    if not max_memory_bytes:\n        return\n\n    try:\n        import resource  # Unix only\n\n        # RLIMIT_AS limits the total available address space.\n        resource.setrlimit(resource.RLIMIT_AS, (max_memory_bytes, max_memory_bytes))\n    except Exception:\n        # Best-effort: not all platforms support resource or RLIMIT_AS.\n        pass\n\n\ndef apply_sandbox(permissions: Dict[str, Any]) -> None:\n    \"\"\"\n    Apply lightweight sandbox restrictions for Python scripts.\n\n    Notes:\n    - This is not a hardened security boundary.\n    - In native Python, stdin is used for RPC, so input() is always disabled.\n    - Process execution is treated as an escape hatch and is only permitted when\n      both filesystem + network are fully enabled.\n    \"\"\"\n\n    filesystem = _filesystem_permission(permissions)\n    network = _network_permission(permissions)\n\n    # Process execution is a common escape hatch for both filesystem and network\n    # restrictions (e.g. spawning `curl` or using shell redirection). Only allow\n    # it when both network + filesystem are explicitly fully enabled.\n    block_process_execution = not (filesystem == \"readwrite\" and network == \"full\")\n\n    def blocked_input(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Interactive input is not permitted\")\n\n    builtins.input = blocked_input  # type: ignore[assignment]\n\n    # Reset import hook first so we can reconfigure it based on current permissions.\n    builtins.__import__ = _ORIGINAL_IMPORT  # type: ignore[assignment]\n\n    def blocked_fs(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Filesystem access is not permitted\")\n\n    def blocked_fs_write(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Filesystem write access is not permitted\")\n\n    def blocked_process(*_args: Any, **_kwargs: Any) -> Any:\n        raise PermissionError(\"Process execution is not permitted\")\n\n    # ---- open() policy -----------------------------------------------------\n    if filesystem == \"readwrite\":\n        builtins.open = _ORIGINAL_OPEN  # type: ignore[assignment]\n        if _ORIGINAL_IO_OPEN is not None:\n            io.open = _ORIGINAL_IO_OPEN  # type: ignore[assignment]\n        if _io_builtin is not None and _ORIGINAL__IO_OPEN is not None:\n            _io_builtin.open = _ORIGINAL__IO_OPEN  # type: ignore[attr-defined]\n    elif filesystem == \"read\":\n\n        def guarded_open(*args: Any, **kwargs: Any) -> Any:\n            mode = _extract_mode(args, kwargs)\n            if _is_write_mode(mode):\n                raise PermissionError(\"Filesystem write access is not permitted\")\n            return _ORIGINAL_OPEN(*args, **kwargs)\n\n        builtins.open = guarded_open  # type: ignore[assignment]\n        io.open = guarded_open  # type: ignore[assignment]\n        if _io_builtin is not None:\n            _io_builtin.open = guarded_open  # type: ignore[attr-defined]\n    else:\n        builtins.open = blocked_fs  # type: ignore[assignment]\n        io.open = blocked_fs  # type: ignore[assignment]\n        if _io_builtin is not None:\n            _io_builtin.open = blocked_fs  # type: ignore[attr-defined]\n\n    # ---- os.* filesystem policy -------------------------------------------\n    # Restore patched functions first so repeated apply_sandbox() calls can\n    # loosen restrictions.\n    for name, fn in _ORIGINAL_OS.items():\n        try:\n            setattr(os, name, fn)\n        except Exception:\n            pass\n\n    if filesystem == \"none\":\n        for name in _OS_FS_FUNCS:\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_fs)\n                except Exception:\n                    pass\n    elif filesystem == \"read\":\n        # Directory enumeration is permitted in read-only mode, but destructive\n        # operations are not.\n        for name in (\n            \"remove\",\n            \"unlink\",\n            \"rmdir\",\n            \"mkdir\",\n            \"makedirs\",\n            \"rename\",\n            \"replace\",\n            \"link\",\n            \"symlink\",\n        ):\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_fs_write)\n                except Exception:\n                    pass\n\n        if \"open\" in _ORIGINAL_OS:\n\n            def guarded_os_open(path: Any, flags: Any, *args: Any, **kwargs: Any) -> Any:\n                try:\n                    flags_i = int(flags)\n                except Exception:\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n\n                write_bits = (\n                    os.O_WRONLY\n                    | os.O_RDWR\n                    | getattr(os, \"O_APPEND\", 0)\n                    | getattr(os, \"O_CREAT\", 0)\n                    | getattr(os, \"O_TRUNC\", 0)\n                    | getattr(os, \"O_EXCL\", 0)\n                )\n                if flags_i & write_bits:\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n                return _ORIGINAL_OS[\"open\"](path, flags, *args, **kwargs)\n\n            os.open = guarded_os_open  # type: ignore[assignment]\n\n        if \"fdopen\" in _ORIGINAL_OS:\n\n            def guarded_fdopen(fd: Any, *args: Any, **kwargs: Any) -> Any:\n                mode = _extract_mode(args, kwargs)\n                if _is_write_mode(mode):\n                    raise PermissionError(\"Filesystem write access is not permitted\")\n                return _ORIGINAL_OS[\"fdopen\"](fd, *args, **kwargs)\n\n            os.fdopen = guarded_fdopen  # type: ignore[assignment]\n\n    # ---- os.* process execution policy ------------------------------------\n    if block_process_execution:\n        for name in _OS_PROCESS_FUNCS:\n            if hasattr(os, name):\n                try:\n                    setattr(os, name, blocked_process)\n                except Exception:\n                    pass\n\n    blocked_roots = set()\n    if block_process_execution:\n        blocked_roots.add(\"subprocess\")\n    if network == \"none\":\n        blocked_roots.update({\"socket\", \"ssl\", \"http\", \"urllib\", \"requests\"})\n\n    if blocked_roots:\n\n        def guarded_import(name: str, globals=None, locals=None, fromlist=(), level: int = 0):\n            root = name.split(\".\", 1)[0]\n            if root in blocked_roots:\n                raise PermissionError(f\"Import of {root!r} is not permitted\")\n            return _ORIGINAL_IMPORT(name, globals, locals, fromlist, level)\n\n        builtins.__import__ = guarded_import  # type: ignore[assignment]\n",
  "formula/runtime/stdio_runner.py": "from __future__ import annotations\n\nimport json\nimport sys\nimport traceback\nfrom typing import Any, Dict\n\nimport formula\nfrom formula._rpc_bridge import StdioRpcBridge\nfrom formula.runtime.sandbox import apply_memory_limit, apply_sandbox\n\n\ndef main() -> None:\n    # Stdout is reserved for protocol messages. Redirect user output to stderr so\n    # prints don't corrupt the JSON stream.\n    protocol_out = sys.stdout\n    sys.stdout = sys.stderr  # type: ignore[assignment]\n    sys.__stdout__ = sys.stderr  # type: ignore[assignment]\n\n    first_line = sys.stdin.readline()\n    if not first_line:\n        return\n\n    cmd = json.loads(first_line)\n    if cmd.get(\"type\") != \"execute\":\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": False, \"error\": \"Invalid command\"}) + \"\\n\")\n        protocol_out.flush()\n        return\n\n    apply_memory_limit(cmd.get(\"max_memory_bytes\"))\n\n    # Configure the bridge before applying sandbox restrictions so our own\n    # imports aren't blocked.\n    bridge = StdioRpcBridge(protocol_in=sys.stdin, protocol_out=protocol_out)\n    formula.set_bridge(bridge)\n\n    apply_sandbox(cmd.get(\"permissions\", {}))\n\n    try:\n        globals_dict: Dict[str, Any] = {\"__name__\": \"__main__\"}\n        exec(cmd.get(\"code\", \"\"), globals_dict, globals_dict)\n        protocol_out.write(json.dumps({\"type\": \"result\", \"success\": True}) + \"\\n\")\n        protocol_out.flush()\n    except Exception as err:\n        protocol_out.write(\n            json.dumps(\n                {\n                    \"type\": \"result\",\n                    \"success\": False,\n                    \"error\": str(err),\n                    \"traceback\": traceback.format_exc(),\n                }\n            )\n            + \"\\n\"\n        )\n        protocol_out.flush()\n\n\nif __name__ == \"__main__\":\n    main()\n"
};
