import { DataTable } from "../table.js";
import { buildODataUrl } from "../folding/odata.js";

/**
 * @typedef {import("./types.js").ConnectorExecuteOptions} ConnectorExecuteOptions
 * @typedef {import("./types.js").ConnectorResult} ConnectorResult
 */

/**
 * @typedef {import("../folding/odata.js").ODataQueryOptions} ODataQueryOptions
 */

/**
 * @typedef {Object} ODataConnectorRequest
 * @property {string} url Entity set endpoint URL.
 * @property {Record<string, string> | undefined} [headers]
 * @property {{ type: "oauth2"; providerId: string; scopes?: string[] | string } | undefined} [auth]
 * @property {string | undefined} [rowsPath] JSON path selecting the row array (defaults to `"value"`).
 * @property {string | undefined} [jsonPath] Alias for `rowsPath` (for parity with `HttpConnector`).
 * @property {ODataQueryOptions | undefined} [query] Query options generated by the folding engine.
 * @property {number | undefined} [limit] Optional max row count for pagination short-circuiting.
 */

/**
 * @param {unknown} input
 * @param {string} path
 * @returns {unknown}
 */
function jsonPathSelect(input, path) {
  if (!path) return input;
  const parts = path.split(".").filter(Boolean);
  let current = input;
  for (const part of parts) {
    if (current == null) return undefined;
    const bracketMatch = part.match(/^(.+)\[(\d+)\]$/);
    if (bracketMatch) {
      const prop = bracketMatch[1];
      const index = Number(bracketMatch[2]);
      // @ts-ignore - runtime traversal
      current = current[prop];
      if (!Array.isArray(current)) return undefined;
      current = current[index];
    } else {
      // @ts-ignore - runtime traversal
      current = current[part];
    }
  }
  return current;
}

/**
 * @param {unknown[]} rows
 * @returns {DataTable}
 */
function tableFromRows(rows) {
  if (!Array.isArray(rows) || rows.length === 0) {
    return new DataTable([], []);
  }

  if (Array.isArray(rows[0])) {
    return DataTable.fromGrid(/** @type {unknown[][]} */ (rows), { hasHeaders: true, inferTypes: true });
  }

  if (rows[0] && typeof rows[0] === "object" && !Array.isArray(rows[0])) {
    /** @type {Set<string>} */
    const keySet = new Set();
    for (const row of rows) {
      if (row && typeof row === "object" && !Array.isArray(row)) {
        Object.keys(row).forEach((k) => keySet.add(k));
      }
    }
    const keys = Array.from(keySet);
    const grid = [
      keys,
      ...rows.map((row) => {
        if (!row || typeof row !== "object" || Array.isArray(row)) return keys.map(() => null);
        // @ts-ignore - runtime access
        return keys.map((k) => row[k] ?? null);
      }),
    ];
    return DataTable.fromGrid(grid, { hasHeaders: true, inferTypes: true });
  }

  const grid = [["Value"], ...rows.map((value) => [value])];
  return DataTable.fromGrid(grid, { hasHeaders: true, inferTypes: true });
}

/**
 * @param {unknown} payload
 * @param {string} rowsPath
 * @returns {{ rows: unknown[]; nextLink: string | null }}
 */
function parseODataPayload(payload, rowsPath) {
  if (Array.isArray(payload)) {
    return { rows: payload, nextLink: null };
  }

  if (payload && typeof payload === "object") {
    // @ts-ignore - OData metadata key
    const nextLinkRaw = payload["@odata.nextLink"] ?? payload["odata.nextLink"] ?? null;
    let nextLink = typeof nextLinkRaw === "string" ? nextLinkRaw : null;

    const selected = jsonPathSelect(payload, rowsPath);
    if (Array.isArray(selected)) return { rows: selected, nextLink };
    if (selected != null) return { rows: [selected], nextLink };

    // Best-effort support for older (v2/v3-ish) payload shapes:
    //   { d: { results: [...] , __next: "..." } }
    // If `rowsPath` didn't resolve, fall back to `d.results` when present.
    // @ts-ignore - runtime access
    const d = payload.d;
    if (d && typeof d === "object") {
      // @ts-ignore - runtime access
      const results = d.results;
      if (Array.isArray(results)) {
        // @ts-ignore - runtime access
        const nextRaw = d.__next;
        if (!nextLink && typeof nextRaw === "string") nextLink = nextRaw;
        return { rows: results, nextLink };
      }
    }

    // Fall back to treating the payload as a single row (e.g. entity-by-key responses).
    return { rows: [payload], nextLink };
  }

  return { rows: [payload], nextLink: null };
}

/**
 * @typedef {Object} ODataConnectorOptions
 * @property {typeof fetch | undefined} [fetch]
 * @property {import("../oauth2/manager.js").OAuth2Manager | undefined} [oauth2Manager]
 * @property {number[] | undefined} [oauth2RetryStatusCodes]
 */

export class ODataConnector {
  /**
   * @param {ODataConnectorOptions} [options]
   */
  constructor(options = {}) {
    this.id = "odata";
    this.permissionKind = "http:request";
    this.fetchFn = options.fetch ?? (typeof fetch === "function" ? fetch.bind(globalThis) : null);
    this.oauth2Manager = options.oauth2Manager ?? null;
    this.oauth2RetryStatusCodes = Array.isArray(options.oauth2RetryStatusCodes) ? options.oauth2RetryStatusCodes : [401, 403];
  }

  /**
   * @param {ODataConnectorRequest} request
   * @returns {unknown}
   */
  getCacheKey(request) {
    const normalizedScopes = (scopes) => {
      const raw = Array.isArray(scopes) ? scopes : typeof scopes === "string" ? scopes.split(/[\s,]+/).filter(Boolean) : [];
      const cleaned = raw
        .filter((s) => typeof s === "string")
        .map((s) => s.trim())
        .filter((s) => s.length > 0);
      cleaned.sort();
      return Array.from(new Set(cleaned));
    };

    const auth =
      request.auth?.type === "oauth2"
        ? { type: "oauth2", providerId: request.auth.providerId, scopes: normalizedScopes(request.auth.scopes) }
        : null;

    /** @type {any} */
    const key = {
      connector: "odata",
      url: request.url,
      headers: request.headers ?? {},
      rowsPath: request.rowsPath ?? request.jsonPath ?? "value",
      query: request.query ?? null,
      limit: typeof request.limit === "number" ? request.limit : null,
    };

    if (auth) {
      key.auth = auth;
    }
    return key;
  }

  /**
   * Lightweight source-state probe for cache validation.
   *
   * Uses a best-effort HTTP HEAD request to capture `etag` and `last-modified`.
   *
   * @param {ODataConnectorRequest} request
   * @param {ConnectorExecuteOptions} [options]
   * @returns {Promise<import("./types.js").SourceState>}
   */
  async getSourceState(request, options = {}) {
    const now = options.now ?? (() => Date.now());
    const signal = options.signal;
    if (signal?.aborted) {
      const err = new Error("Aborted");
      err.name = "AbortError";
      throw err;
    }

    if (!this.fetchFn) return {};

    /** @type {Record<string, string>} */
    const headers = { ...(request.headers ?? {}) };

    /**
     * @param {unknown} scopes
     * @returns {string[] | undefined}
     */
    const coerceScopes = (scopes) => {
      if (Array.isArray(scopes)) return scopes;
      if (typeof scopes === "string") {
        const parts = scopes
          .split(/[\s,]+/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        return parts.length > 0 ? parts : undefined;
      }
      return undefined;
    };

    let credentials = options.credentials;
    if (
      credentials &&
      typeof credentials === "object" &&
      !Array.isArray(credentials) &&
      // @ts-ignore - runtime access
      typeof credentials.getSecret === "function"
    ) {
      // @ts-ignore - runtime call
      credentials = await credentials.getSecret();
    }

    /** @type {{ providerId: string; scopes?: string[] } | null} */
    let credentialOAuth2 = null;
    if (credentials && typeof credentials === "object" && !Array.isArray(credentials)) {
      // @ts-ignore - runtime merge
      const extraHeaders = credentials.headers;
      if (extraHeaders && typeof extraHeaders === "object") {
        Object.assign(headers, extraHeaders);
      }

      // @ts-ignore - runtime access
      const oauth2 = credentials.oauth2;
      if (oauth2 && typeof oauth2 === "object") {
        // @ts-ignore - runtime access
        const providerId = oauth2.providerId;
        // @ts-ignore - runtime access
        const scopes = coerceScopes(oauth2.scopes);
        if (typeof providerId === "string" && providerId) {
          credentialOAuth2 = { providerId, scopes };
        }
      }
    }

    if (!Object.keys(headers).some((k) => k.toLowerCase() === "accept")) {
      headers.Accept = "application/json";
    }

    /** @type {{ type: "oauth2"; providerId: string; scopes?: string[] } | null} */
    let oauth2Auth = null;
    if (request.auth?.type === "oauth2") {
      // @ts-ignore - tolerate `scopes` being encoded as a string in persisted JSON.
      oauth2Auth = { ...request.auth, scopes: coerceScopes(request.auth.scopes) };
    } else if (credentialOAuth2) {
      oauth2Auth = { type: "oauth2", ...credentialOAuth2 };
    }

    const applyOAuthHeader = async (forceRefresh = false) => {
      if (!oauth2Auth) return;
      if (!this.oauth2Manager) {
        throw new Error("OData OAuth2 requests require configuring ODataConnector with an OAuth2Manager");
      }
      const token = await this.oauth2Manager.getAccessToken({
        providerId: oauth2Auth.providerId,
        scopes: oauth2Auth.scopes,
        signal,
        now,
        forceRefresh,
      });
      headers.Authorization = `Bearer ${token.accessToken}`;
    };

    const url = buildODataUrl(request.url, request.query);

    await applyOAuthHeader(false);

    let response;
    try {
      response = await this.fetchFn(url, { method: "HEAD", headers, signal });
    } catch {
      return {};
    }

    if (!response.ok && oauth2Auth && this.oauth2RetryStatusCodes.includes(response.status)) {
      await applyOAuthHeader(true);
      try {
        response = await this.fetchFn(url, { method: "HEAD", headers, signal });
      } catch {
        return {};
      }
    }

    if (!response.ok) return {};

    const etag = response.headers.get("etag") ?? undefined;

    /** @type {Date | undefined} */
    let sourceTimestamp;
    const lastModified = response.headers.get("last-modified");
    if (lastModified) {
      const parsed = new Date(lastModified);
      if (!Number.isNaN(parsed.getTime())) sourceTimestamp = parsed;
    }

    return { etag, sourceTimestamp };
  }

  /**
   * @param {ODataConnectorRequest} request
   * @param {ConnectorExecuteOptions} [options]
   * @returns {Promise<ConnectorResult>}
   */
  async execute(request, options = {}) {
    const now = options.now ?? (() => Date.now());
    const signal = options.signal;

    if (!this.fetchFn) {
      throw new Error("OData source requires a global fetch implementation or an ODataConnector fetch adapter");
    }

    /** @type {Record<string, string>} */
    const headers = { ...(request.headers ?? {}) };

    let credentials = options.credentials;
    if (
      credentials &&
      typeof credentials === "object" &&
      !Array.isArray(credentials) &&
      // @ts-ignore - runtime access
      typeof credentials.getSecret === "function"
    ) {
      // @ts-ignore - runtime call
      credentials = await credentials.getSecret();
    }

    /**
     * @param {unknown} scopes
     * @returns {string[] | undefined}
     */
    const coerceScopes = (scopes) => {
      if (Array.isArray(scopes)) return scopes;
      if (typeof scopes === "string") {
        const parts = scopes
          .split(/[\s,]+/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        return parts.length > 0 ? parts : undefined;
      }
      return undefined;
    };

    /** @type {{ providerId: string; scopes?: string[] } | null} */
    let credentialOAuth2 = null;
    if (credentials && typeof credentials === "object" && !Array.isArray(credentials)) {
      // Generic convention: host apps can return `{ headers }` as credentials for HTTP APIs.
      // @ts-ignore - runtime merge
      const extraHeaders = credentials.headers;
      if (extraHeaders && typeof extraHeaders === "object") {
        Object.assign(headers, extraHeaders);
      }

      // Standard convention: host apps can return `{ oauth2: { providerId, scopes? } }`.
      // @ts-ignore - runtime access
      const oauth2 = credentials.oauth2;
      if (oauth2 && typeof oauth2 === "object") {
        // @ts-ignore - runtime access
        const providerId = oauth2.providerId;
        // @ts-ignore - runtime access
        const scopes = coerceScopes(oauth2.scopes);
        if (typeof providerId === "string" && providerId) {
          credentialOAuth2 = { providerId, scopes };
        }
      }
    }

    if (!Object.keys(headers).some((k) => k.toLowerCase() === "accept")) {
      headers.Accept = "application/json";
    }

    /** @type {{ type: "oauth2"; providerId: string; scopes?: string[] } | null} */
    let oauth2Auth = null;
    if (request.auth?.type === "oauth2") {
      // @ts-ignore - tolerate `scopes` being encoded as a string in persisted JSON.
      oauth2Auth = { ...request.auth, scopes: coerceScopes(request.auth.scopes) };
    } else if (credentialOAuth2) {
      oauth2Auth = { type: "oauth2", ...credentialOAuth2 };
    }

    const applyOAuthHeader = async (forceRefresh = false) => {
      if (!oauth2Auth) return;
      if (!this.oauth2Manager) {
        throw new Error("OData OAuth2 requests require configuring ODataConnector with an OAuth2Manager");
      }
      const token = await this.oauth2Manager.getAccessToken({
        providerId: oauth2Auth.providerId,
        scopes: oauth2Auth.scopes,
        signal,
        now,
        forceRefresh,
      });
      headers.Authorization = `Bearer ${token.accessToken}`;
    };

    await applyOAuthHeader(false);

    const rowsPath = request.rowsPath ?? request.jsonPath ?? "value";

    const limitRaw = typeof request.limit === "number" && Number.isFinite(request.limit) ? Math.max(0, Math.trunc(request.limit)) : null;
    const topRaw =
      typeof request.query?.top === "number" && Number.isFinite(request.query.top) ? Math.max(0, Math.trunc(request.query.top)) : null;
    const limit = limitRaw == null ? topRaw : topRaw == null ? limitRaw : Math.min(limitRaw, topRaw);

    const initialUrl = buildODataUrl(request.url, request.query);

    /** @type {unknown[]} */
    const allRows = [];

    /** @type {Date | undefined} */
    let sourceTimestamp;

    /** @type {string | null} */
    let nextUrl = initialUrl;

    const fetchOnce = async (url) => {
      const response = await this.fetchFn(url, { method: "GET", headers, signal });
      return response;
    };

    while (nextUrl) {
      let response = await fetchOnce(nextUrl);
      if (!response.ok && oauth2Auth && this.oauth2RetryStatusCodes.includes(response.status)) {
        await applyOAuthHeader(true);
        response = await fetchOnce(nextUrl);
      }

      if (!response.ok) {
        throw new Error(`HTTP ${response.status} for ${nextUrl}`);
      }

      if (!sourceTimestamp) {
        const lastModified = response.headers.get("last-modified");
        if (lastModified) {
          const parsed = new Date(lastModified);
          if (!Number.isNaN(parsed.getTime())) sourceTimestamp = parsed;
        }
      }

      const payload = await response.json();
      const parsed = parseODataPayload(payload, rowsPath);

      allRows.push(...parsed.rows);
      if (limit != null && allRows.length >= limit) {
        allRows.length = limit;
        break;
      }

      if (!parsed.nextLink) break;
      nextUrl = new URL(parsed.nextLink, nextUrl).toString();
    }

    const table = tableFromRows(allRows);
    return {
      table,
      meta: {
        refreshedAt: new Date(now()),
        sourceTimestamp,
        schema: { columns: table.columns, inferred: true },
        rowCount: table.rows.length,
        rowCountEstimate: table.rows.length,
        provenance: { kind: "odata", url: initialUrl, method: "GET" },
      },
    };
  }
}
