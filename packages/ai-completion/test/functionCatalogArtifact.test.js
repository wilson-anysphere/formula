import assert from "node:assert/strict";
import { spawnSync } from "node:child_process";
import test from "node:test";
import { readFile } from "node:fs/promises";
import { fileURLToPath } from "node:url";

import FUNCTION_CATALOG from "../../../shared/functionCatalog.mjs";
import FUNCTION_NAMES from "../../../shared/functionNames.mjs";

test("function catalog artifact matches committed JSON and is sorted", async () => {
  const jsonPath = fileURLToPath(new URL("../../../shared/functionCatalog.json", import.meta.url));
  const mjsPath = fileURLToPath(new URL("../../../shared/functionCatalog.mjs", import.meta.url));
  const dtsPath = fileURLToPath(new URL("../../../shared/functionCatalog.d.mts", import.meta.url));
  const raw = await readFile(jsonPath, "utf8");
  const parsed = JSON.parse(raw);

  assert.deepEqual(parsed, FUNCTION_CATALOG, "Expected functionCatalog.mjs to match functionCatalog.json");

  const rawMjs = await readFile(mjsPath, "utf8");
  assert.ok(
    rawMjs.startsWith("// This file is generated by scripts/generate-function-catalog.js. Do not edit.\n"),
    "Expected functionCatalog.mjs to be a generated artifact (missing header)",
  );
  assert.ok(rawMjs.includes("\nexport default "), "Expected functionCatalog.mjs to export default the catalog");
  assert.ok(rawMjs.trimEnd().endsWith(";"), "Expected functionCatalog.mjs to end with a semicolon");

  const rawDts = await readFile(dtsPath, "utf8");
  const expectedDts = `// This file is generated by scripts/generate-function-catalog.js. Do not edit.
declare const catalog: {
  functions: Array<{
    name: string;
    min_args: number;
    max_args: number;
    arg_types: Array<"any" | "number" | "text" | "bool">;
    volatility: "non_volatile" | "volatile";
    return_type: "any" | "number" | "text" | "bool";
  }>;
};
export default catalog;
`;
  assert.equal(rawDts, expectedDts, "Expected functionCatalog.d.mts to match generator template");

  const allowedTypes = new Set(["any", "number", "text", "bool"]);
  const allowedVolatility = new Set(["non_volatile", "volatile"]);

  const names = FUNCTION_CATALOG.functions.map((fn) => fn.name);
  assert.ok(names.length > 20, `Expected a non-trivial catalog, got ${names.length} functions`);

  for (const fn of FUNCTION_CATALOG.functions) {
    assert.equal(fn.name, fn.name.toUpperCase(), `Expected function name to be uppercase, got ${fn.name}`);
    assert.ok(Number.isInteger(fn.min_args) && fn.min_args >= 0, `Expected min_args to be >= 0 for ${fn.name}`);
    assert.ok(Number.isInteger(fn.max_args) && fn.max_args >= fn.min_args, `Expected max_args >= min_args for ${fn.name}`);
    assert.ok(allowedVolatility.has(fn.volatility), `Expected volatility to be valid for ${fn.name}`);
    assert.ok(allowedTypes.has(fn.return_type), `Expected return_type to be valid for ${fn.name}`);
    assert.ok(Array.isArray(fn.arg_types), `Expected arg_types to be an array for ${fn.name}`);
    for (const t of fn.arg_types) {
      assert.ok(allowedTypes.has(t), `Expected arg_types entry to be valid for ${fn.name}: ${t}`);
    }
    if (fn.max_args === 0) {
      assert.equal(fn.arg_types.length, 0, `Expected zero-arg functions to have empty arg_types for ${fn.name}`);
    }
  }

  const sorted = [...names].sort();
  assert.deepEqual(names, sorted, "Expected function catalog to be sorted by name for deterministic diffs");
  assert.equal(new Set(names).size, names.length, "Expected function catalog to contain unique names");

  assert.ok(names.includes("XLOOKUP"), "Expected XLOOKUP to be present in the catalog");
});

test("function names artifact matches catalog and is sorted", async () => {
  const namesMjsPath = fileURLToPath(new URL("../../../shared/functionNames.mjs", import.meta.url));
  const namesDtsPath = fileURLToPath(new URL("../../../shared/functionNames.d.mts", import.meta.url));

  const rawMjs = await readFile(namesMjsPath, "utf8");
  assert.ok(
    rawMjs.startsWith("// This file is generated by scripts/generate-function-catalog.js. Do not edit.\n"),
    "Expected functionNames.mjs to be a generated artifact (missing header)",
  );
  assert.ok(rawMjs.includes("\nexport default "), "Expected functionNames.mjs to export default the name list");
  assert.ok(rawMjs.trimEnd().endsWith(";"), "Expected functionNames.mjs to end with a semicolon");

  const rawDts = await readFile(namesDtsPath, "utf8");
  const expectedDts = `// This file is generated by scripts/generate-function-catalog.js. Do not edit.
declare const names: string[];
export default names;
`;
  assert.equal(rawDts, expectedDts, "Expected functionNames.d.mts to match generator template");

  assert.ok(Array.isArray(FUNCTION_NAMES), "Expected functionNames.mjs to default-export an array");
  assert.ok(FUNCTION_NAMES.length > 20, `Expected a non-trivial functionNames list, got ${FUNCTION_NAMES.length} functions`);

  const fromCatalog = FUNCTION_CATALOG.functions.map((fn) => fn.name).sort();
  assert.deepEqual(FUNCTION_NAMES, fromCatalog, "Expected functionNames.mjs to match functionCatalog.mjs names");
  assert.deepEqual(FUNCTION_NAMES, [...FUNCTION_NAMES].sort(), "Expected functionNames list to be sorted");
  assert.equal(new Set(FUNCTION_NAMES).size, FUNCTION_NAMES.length, "Expected functionNames list to contain unique names");
  assert.ok(FUNCTION_NAMES.includes("XLOOKUP"), "Expected XLOOKUP to be present in the functionNames list");
});

test("function catalog generator script parses (node --check)", () => {
  const scriptPath = fileURLToPath(
    new URL("../../../scripts/generate-function-catalog.js", import.meta.url),
  );
  const result = spawnSync(process.execPath, ["--check", scriptPath], { encoding: "utf8" });
  assert.equal(
    result.status,
    0,
    `Expected node --check to succeed for scripts/generate-function-catalog.js.\nstdout:\n${result.stdout}\nstderr:\n${result.stderr}`,
  );
});
