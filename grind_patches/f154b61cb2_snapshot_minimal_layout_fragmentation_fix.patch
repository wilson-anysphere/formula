From f154b61cb2bf93ba9281040ae1d4edf975576a09 Mon Sep 17 00:00:00 2001
From: Wilson Lin <code@wilsonl.in>
Date: Sun, 18 Jan 2026 08:03:23 -0800
Subject: [PATCH] fix: sync minimal layout + fragmentation with grid/style
 changes

- Normalize mirrored grid track metadata into fragmentation flow order and map grid line indices to avoid debug panics.
- Teach minimal grid layout to apply row/column gaps when computing track ranges so pagination doesn't emit gap-only fragments.
- Plumb percentage bases through minimal layout constraints/config for correct %/calc sizing.
- Add non-macOS style_minimal::computed::PositionedStyle alias and refresh layout_engine compile harness.
- Update Cargo.lock to include css-wpt-runner workspace member.
---
 Cargo.lock                                    |  22 ++
 crates/css-syntax/src/tokenizer.rs            |   9 +-
 .../css_selectors_rs_no_servo_deps_guard.rs   |   6 +-
 .../tests/network_process_client_compile.rs   |  30 ++
 src/css/syntax/component_values.rs            |   2 +-
 src/layout/fragmentation.rs                   | 161 ++++++++--
 src/layout_minimal/constraints.rs             |  10 +-
 src/layout_minimal/contexts/block.rs          |  12 +-
 src/layout_minimal/contexts/flex.rs           |  12 +-
 src/layout_minimal/contexts/grid.rs           |  11 +-
 src/layout_minimal/engine.rs                  | 265 +++++++++++------
 src/net/websocket/mod.rs                      |   3 +-
 src/net/websocket/stream.rs                   |   2 +-
 .../core_graphics_rasterizer/renderer.rs      | 274 +++++++++++-------
 src/style_minimal/computed.rs                 |   8 +
 src/style_minimal/mod.rs                      |   1 +
 16 files changed, 614 insertions(+), 214 deletions(-)
 create mode 100644 src/style_minimal/computed.rs

diff --git a/Cargo.lock b/Cargo.lock
index c4023a9fd..2cacc1b52 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -789,6 +789,28 @@ dependencies = [
  "css-syntax",
 ]
 
+[[package]]
+name = "css-wpt-runner"
+version = "0.1.0"
+dependencies = [
+ "anyhow",
+ "chrono",
+ "clap 4.5.54",
+ "conformance-harness",
+ "css-cascade",
+ "css-selectors",
+ "css-syntax",
+ "globset",
+ "rayon",
+ "regex",
+ "serde",
+ "serde_json",
+ "tempfile",
+ "toml",
+ "walkdir",
+ "winapi-util",
+]
+
 [[package]]
 name = "ctr"
 version = "0.9.2"
diff --git a/crates/css-syntax/src/tokenizer.rs b/crates/css-syntax/src/tokenizer.rs
index 5cc0dd7d0..ee16e5b3d 100644
--- a/crates/css-syntax/src/tokenizer.rs
+++ b/crates/css-syntax/src/tokenizer.rs
@@ -322,10 +322,11 @@ impl<'i> Tokenizer<'i> {
             // decision, but *comments are not whitespace* here: `url(/*x*/"foo")` must become a
             // `bad-url` token, not a `function-token` + string.
             if matches!(bytes.get(ws_end), Some(b'"') | Some(b'\'')) {
-              // Consume the whitespace we just scanned while disambiguating so `url(  "foo")` does
-              // not emit a standalone whitespace token before the quoted string.
-              // Keep the token span ending at the `(` so downstream consumers can detect the
-              // whitespace via the span gap (for example, opaque-url collapsing).
+              // CSS Syntax consumes the whitespace while deciding between `url-token` and the
+              // `url(` function form. If we take the function branch, skip the scanned whitespace
+              // so callers don't see a standalone whitespace token between `url(` and the quoted
+              // string. Keep the token span ending at the `(` so downstream consumers can still
+              // infer the whitespace via the span gap if needed.
               self.pos = ws_end;
               return Some(TokenWithSpan {
                 token: Token::Function(name),
diff --git a/crates/layout_engine/tests/css_selectors_rs_no_servo_deps_guard.rs b/crates/layout_engine/tests/css_selectors_rs_no_servo_deps_guard.rs
index a0fd1daf8..0715e2c65 100644
--- a/crates/layout_engine/tests/css_selectors_rs_no_servo_deps_guard.rs
+++ b/crates/layout_engine/tests/css_selectors_rs_no_servo_deps_guard.rs
@@ -133,10 +133,12 @@ fn css_selector_sources_do_not_reference_blocked_servo_selector_crates() {
   if legacy_path.is_file() {
     files.push(legacy_path);
   }
-
+  let dom_selector_path = repo_root.join("src/css/dom_selector.rs");
+  if dom_selector_path.is_file() {
+    files.push(dom_selector_path);
+  }
   let selector_dir = repo_root.join("src/css/selector");
   collect_rust_files(&selector_dir, &mut files);
-  files.push(repo_root.join("src/css/dom_selector.rs"));
   let crate_root = repo_root.join("crates/css-selectors/src");
   collect_rust_files(&crate_root, &mut files);
   files.sort();
diff --git a/crates/layout_engine/tests/network_process_client_compile.rs b/crates/layout_engine/tests/network_process_client_compile.rs
index 95e6f955d..e6bf0cf85 100644
--- a/crates/layout_engine/tests/network_process_client_compile.rs
+++ b/crates/layout_engine/tests/network_process_client_compile.rs
@@ -692,12 +692,29 @@ mod style {
       }
     }
 
+    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
+    pub enum CalcSizeBasis {
+      Auto,
+      MinContent,
+      MaxContent,
+      FillAvailable,
+      FitContent { limit: Option<Length> },
+      Length(Length),
+    }
+
+    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
+    pub struct CalcSize {
+      pub basis: CalcSizeBasis,
+      pub expr: super::values::CalcSizeExprId,
+    }
+
     #[derive(Debug, Clone, Copy, PartialEq, Eq)]
     pub enum IntrinsicSizeKeyword {
       MinContent,
       MaxContent,
       FillAvailable,
       FitContent { limit: Option<Length> },
+      CalcSize(CalcSize),
     }
 
     #[derive(Debug, Clone, Copy, Default, Eq, PartialEq)]
@@ -730,6 +747,15 @@ mod style {
     }
   }
 
+  pub mod values {
+    #[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]
+    pub struct CalcSizeExprId(pub u32);
+
+    pub fn intern_calc_size_expr(_expr: &str) -> CalcSizeExprId {
+      CalcSizeExprId(0)
+    }
+  }
+
   use types::{IntrinsicSizeKeyword, WritingMode};
 
   #[derive(Debug, Clone, Copy, Default)]
@@ -737,6 +763,10 @@ mod style {
     pub writing_mode: WritingMode,
     pub width_keyword: Option<IntrinsicSizeKeyword>,
     pub height_keyword: Option<IntrinsicSizeKeyword>,
+    pub min_width_keyword: Option<IntrinsicSizeKeyword>,
+    pub max_width_keyword: Option<IntrinsicSizeKeyword>,
+    pub min_height_keyword: Option<IntrinsicSizeKeyword>,
+    pub max_height_keyword: Option<IntrinsicSizeKeyword>,
   }
 
   pub fn inline_axis_is_horizontal(writing_mode: WritingMode) -> bool {
diff --git a/src/css/syntax/component_values.rs b/src/css/syntax/component_values.rs
index 3315b31f6..d7f60fb8e 100644
--- a/src/css/syntax/component_values.rs
+++ b/src/css/syntax/component_values.rs
@@ -572,7 +572,7 @@ impl<'i> Parser<'i> {
 
   #[inline]
   pub fn is_exhausted(&self) -> bool {
-    // Mirror legacy CSS parser semantics: trailing whitespace/comments do not count as "remaining input".
+    // Mirror the legacy parser semantics: trailing whitespace/comments do not count as "remaining input".
     let mut idx = self.idx;
     while idx < self.end {
       match &self.stream.tokens[idx].token {
diff --git a/src/layout/fragmentation.rs b/src/layout/fragmentation.rs
index 83243b7b1..1f4e7750c 100644
--- a/src/layout/fragmentation.rs
+++ b/src/layout/fragmentation.rs
@@ -1362,6 +1362,123 @@ fn grid_tracks_in_fragmentation_axis<'a>(
   }
 }
 
+/// View of a grid track slice ordered in non-decreasing fragmentation flow direction.
+///
+/// `GridTrackRanges` keeps its vectors in logical track order and mirrors coordinates when the
+/// writing mode or direction flips an axis (see `tree::fragment_tree::GridTrackRanges`). That means
+/// the raw coordinate values may be decreasing even when the fragmentation flow is increasing.
+///
+/// Fragmentation logic (gutter absorption, track-band atomicity, and mapping break hints to track
+/// boundaries) operates in the *fragmentation flow* coordinate system, so normalize any track slice
+/// to flow order and provide a matching line-index mapping.
+#[derive(Clone, Copy, Debug)]
+struct FlowOrderedGridTracks<'a> {
+  tracks: &'a [(f32, f32)],
+  reversed: bool,
+}
+
+impl<'a> FlowOrderedGridTracks<'a> {
+  fn new(tracks: &'a [(f32, f32)], axis: &FragmentAxis, parent_block_size: f32) -> Self {
+    if tracks.len() < 2 || !parent_block_size.is_finite() {
+      return Self {
+        tracks,
+        reversed: false,
+      };
+    }
+
+    let mut prev: Option<f32> = None;
+    let mut saw_increase = false;
+    let mut saw_decrease = false;
+
+    for (track_start, track_end) in tracks.iter().copied() {
+      let track_size = (track_end - track_start).max(0.0);
+      let flow_start = axis.flow_offset(track_start, track_size, parent_block_size);
+      if !flow_start.is_finite() {
+        prev = None;
+        continue;
+      }
+
+      if let Some(prev) = prev {
+        if flow_start > prev + BREAK_EPSILON {
+          saw_increase = true;
+        } else if flow_start + BREAK_EPSILON < prev {
+          saw_decrease = true;
+        }
+      }
+      prev = Some(flow_start);
+    }
+
+    Self {
+      tracks,
+      reversed: saw_decrease && !saw_increase,
+    }
+  }
+
+  fn len(self) -> usize {
+    self.tracks.len()
+  }
+
+  fn is_empty(self) -> bool {
+    self.tracks.is_empty()
+  }
+
+  fn get(self, idx: usize) -> Option<(f32, f32)> {
+    if !self.reversed {
+      return self.tracks.get(idx).copied();
+    }
+
+    let len = self.tracks.len();
+    if idx >= len {
+      return None;
+    }
+    self.tracks.get(len - 1 - idx).copied()
+  }
+
+  fn iter(self) -> FlowOrderedGridTracksIter<'a> {
+    if self.reversed {
+      FlowOrderedGridTracksIter::Reverse(self.tracks.iter().rev().copied())
+    } else {
+      FlowOrderedGridTracksIter::Forward(self.tracks.iter().copied())
+    }
+  }
+
+  fn map_line(self, line: u16) -> u16 {
+    if !self.reversed {
+      return line;
+    }
+
+    // There are `track_count + 1` grid lines. Reversing track order reverses the line numbering.
+    // Example with 2 tracks: lines 1..=3 map 1â†”3 and keep 2 fixed.
+    let track_count = u16::try_from(self.tracks.len()).unwrap_or(u16::MAX.saturating_sub(1));
+    track_count.saturating_add(2).saturating_sub(line)
+  }
+
+  fn map_line_span(self, start: u16, end: u16) -> (u16, u16) {
+    let mut start = self.map_line(start);
+    let mut end = self.map_line(end);
+    if start > end {
+      std::mem::swap(&mut start, &mut end);
+    }
+    (start, end)
+  }
+}
+
+enum FlowOrderedGridTracksIter<'a> {
+  Forward(std::iter::Copied<std::slice::Iter<'a, (f32, f32)>>),
+  Reverse(std::iter::Copied<std::iter::Rev<std::slice::Iter<'a, (f32, f32)>>>),
+}
+
+impl<'a> Iterator for FlowOrderedGridTracksIter<'a> {
+  type Item = (f32, f32);
+
+  fn next(&mut self) -> Option<Self::Item> {
+    match self {
+      Self::Forward(iter) => iter.next(),
+      Self::Reverse(iter) => iter.next(),
+    }
+  }
+}
+
 #[cfg(debug_assertions)]
 pub(crate) fn debug_assert_grid_tracks_in_flow_order(
   tracks: &[(f32, f32)],
@@ -1373,7 +1490,9 @@ pub(crate) fn debug_assert_grid_tracks_in_flow_order(
   }
 
   let mut prev_flow_start: Option<(usize, f32)> = None;
-  for (idx, (track_start, track_end)) in tracks.iter().copied().enumerate() {
+  let tracks = FlowOrderedGridTracks::new(tracks, axis, parent_block_size);
+  let reversed = tracks.reversed;
+  for (idx, (track_start, track_end)) in tracks.iter().enumerate() {
     let track_size = (track_end - track_start).max(0.0);
     let flow_start = axis.flow_offset(track_start, track_size, parent_block_size);
     if !flow_start.is_finite() {
@@ -1384,7 +1503,7 @@ pub(crate) fn debug_assert_grid_tracks_in_flow_order(
     if let Some((prev_idx, prev)) = prev_flow_start {
       debug_assert!(
         flow_start + BREAK_EPSILON >= prev,
-        "GridTrackRanges must be ordered in non-decreasing flow direction for fragmentation (idx={idx} flow_start={flow_start} prev_idx={prev_idx} prev_flow_start={prev} block_is_horizontal={} block_positive={})",
+        "GridTrackRanges must be ordered in non-decreasing flow direction for fragmentation (idx={idx} flow_start={flow_start} prev_idx={prev_idx} prev_flow_start={prev} block_is_horizontal={} block_positive={} reversed={reversed})",
         axis.block_is_horizontal,
         axis.block_positive,
       );
@@ -1435,8 +1554,11 @@ fn grid_item_lines_in_fragmentation_axis(
   placement: &GridItemFragmentationData,
   axis: &FragmentAxis,
 ) -> (u16, u16) {
-  let _ = axis;
-  (placement.row_start, placement.row_end)
+  if axis.block_is_horizontal {
+    (placement.column_start, placement.column_end)
+  } else {
+    (placement.row_start, placement.row_end)
+  }
 }
 
 fn grid_item_spans_single_track(
@@ -4401,9 +4523,10 @@ fn collect_break_opportunities(
     grid_item_count_break_hint_suppression = grid_item_count_parallel_flow;
   }
 
-  if let (Some(tracks), Some(grid_items)) = (grid_tracks, grid_items) {
+  if let (Some(tracks_slice), Some(grid_items)) = (grid_tracks, grid_items) {
     if grid_item_break_hints_use_tracks {
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      debug_assert_grid_tracks_in_flow_order(tracks_slice, axis, node_block_size);
+      let tracks = FlowOrderedGridTracks::new(tracks_slice, axis, node_block_size);
       let in_flow_count = grid_item_count_parallel_flow;
 
       // One slot per grid line (track_count + 1). Index `i` corresponds to the boundary at line
@@ -4419,6 +4542,7 @@ fn collect_break_opportunities(
           .unwrap_or(default_style);
         let placement = &grid_items.items[idx];
         let (start_line, end_line) = grid_item_lines_in_fragmentation_axis(placement, axis);
+        let (start_line, end_line) = tracks.map_line_span(start_line, end_line);
 
         let child_break_before = if child_style.position.is_absolutely_positioned() {
           BreakBetween::Auto
@@ -4469,8 +4593,7 @@ fn collect_break_opportunities(
         } else if boundary_idx == tracks.len() {
           abs_end
         } else {
-          let Some((track_start, track_end)) = tracks.get(boundary_idx.saturating_sub(1)).copied()
-          else {
+          let Some((track_start, track_end)) = tracks.get(boundary_idx.saturating_sub(1)) else {
             continue;
           };
           let track_size = (track_end - track_start).max(0.0);
@@ -5113,8 +5236,9 @@ fn collect_forced_boundaries_with_axes_internal(
     let mut grid_item_count = 0usize;
     if matches!(node_style.display, Display::Grid | Display::InlineGrid) {
       if let (Some(grid_tracks), Some(grid_items)) = (node.grid_tracks.as_deref(), grid_items) {
-        let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-        debug_assert_grid_tracks_in_flow_order(tracks, axis, parent_block_size);
+        let tracks_slice = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
+        debug_assert_grid_tracks_in_flow_order(tracks_slice, axis, parent_block_size);
+        let tracks = FlowOrderedGridTracks::new(tracks_slice, axis, parent_block_size);
         if !tracks.is_empty() && !grid_items.items.is_empty() {
           let in_flow_count = grid_items.items.len().min(node.children.len());
           // One slot per grid line (track_count + 1). Index `i` corresponds to the boundary at line
@@ -5130,6 +5254,7 @@ fn collect_forced_boundaries_with_axes_internal(
               .unwrap_or(default_style);
             let placement = &grid_items.items[idx];
             let (start_line, end_line) = grid_item_lines_in_fragmentation_axis(placement, axis);
+            let (start_line, end_line) = tracks.map_line_span(start_line, end_line);
 
             let child_break_before = if child_style.position.is_absolutely_positioned() {
               BreakBetween::Auto
@@ -5169,7 +5294,7 @@ fn collect_forced_boundaries_with_axes_internal(
             // of track `i + 1`, which would land after the gutter and can create gap-only pages when
             // page sizes line up exactly with track ends).
             let mut track_flow_ends = Vec::with_capacity(tracks.len());
-            for (track_start, track_end) in tracks.iter().copied() {
+            for (track_start, track_end) in tracks.iter() {
               let track_size = (track_end - track_start).max(0.0);
               if !track_start.is_finite() {
                 track_flow_ends.push(abs_start);
@@ -5654,8 +5779,9 @@ fn collect_atomic_candidate_for_node(
 
   if matches!(style.display, Display::Grid | Display::InlineGrid) {
     if let Some(grid_tracks) = node.grid_tracks.as_deref() {
-      let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      let tracks_slice = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
+      debug_assert_grid_tracks_in_flow_order(tracks_slice, axis, node_block_size);
+      let tracks = FlowOrderedGridTracks::new(tracks_slice, axis, node_block_size);
 
       // Treat each grid track as indivisible. Additionally, treat the inter-track gutter preceding
       // each track as part of the following track so pagination never splits a `row-gap`/`column-gap`
@@ -5665,7 +5791,7 @@ fn collect_atomic_candidate_for_node(
       // gutter). The gutter is empty space; it may force a fragmentainer to under-fill, but should
       // not cause a track band that otherwise fits to become breakable.
       let mut prev_flow_end: Option<f32> = None;
-      for (track_start, track_end) in tracks.iter().copied() {
+      for (track_start, track_end) in tracks.iter() {
         let track_size = (track_end - track_start).max(0.0);
         let flow_offset = axis.flow_offset(track_start, track_size, node_block_size);
         let mut start = abs_start + flow_offset;
@@ -5887,14 +6013,15 @@ fn collect_atomic_range_for_node(
 
   if matches!(style.display, Display::Grid | Display::InlineGrid) {
     if let Some(grid_tracks) = node.grid_tracks.as_deref() {
-      let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      let tracks_slice = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
+      debug_assert_grid_tracks_in_flow_order(tracks_slice, axis, node_block_size);
+      let tracks = FlowOrderedGridTracks::new(tracks_slice, axis, node_block_size);
 
       // Treat each grid track as indivisible. Additionally, treat the inter-track gutter preceding
       // each track as part of the following track so pagination never splits a `row-gap`/`column-gap`
       // across fragmentainers (and avoids producing a fragmentainer that contains only the gap).
       let mut prev_flow_end: Option<f32> = None;
-      for (track_start, track_end) in tracks.iter().copied() {
+      for (track_start, track_end) in tracks.iter() {
         let track_size = (track_end - track_start).max(0.0);
         let flow_offset = axis.flow_offset(track_start, track_size, node_block_size);
         let mut start = abs_start + flow_offset;
diff --git a/src/layout_minimal/constraints.rs b/src/layout_minimal/constraints.rs
index e6a12299a..224599482 100644
--- a/src/layout_minimal/constraints.rs
+++ b/src/layout_minimal/constraints.rs
@@ -30,6 +30,8 @@ impl AvailableSpace {
 pub struct LayoutConstraints {
   pub available_width: AvailableSpace,
   pub available_height: AvailableSpace,
+  pub inline_percentage_base: Option<f32>,
+  pub block_percentage_base: Option<f32>,
 }
 
 impl LayoutConstraints {
@@ -37,6 +39,8 @@ impl LayoutConstraints {
     Self {
       available_width,
       available_height,
+      inline_percentage_base: None,
+      block_percentage_base: None,
     }
   }
 
@@ -55,11 +59,13 @@ impl LayoutConstraints {
     )
   }
 
-  pub fn with_block_percentage_base(self, _base: Option<f32>) -> Self {
+  pub fn with_block_percentage_base(mut self, base: Option<f32>) -> Self {
+    self.block_percentage_base = base;
     self
   }
 
-  pub fn with_inline_percentage_base(self, _base: Option<f32>) -> Self {
+  pub fn with_inline_percentage_base(mut self, base: Option<f32>) -> Self {
+    self.inline_percentage_base = base;
     self
   }
 }
diff --git a/src/layout_minimal/contexts/block.rs b/src/layout_minimal/contexts/block.rs
index 89a75b40b..a6e957410 100644
--- a/src/layout_minimal/contexts/block.rs
+++ b/src/layout_minimal/contexts/block.rs
@@ -1,3 +1,4 @@
+use crate::layout::axis::{FragmentAxes, PhysicalAxis};
 use crate::layout::constraints::LayoutConstraints;
 use crate::layout::engine::{LayoutConfig, LayoutEngine, LayoutParallelism};
 use crate::layout::formatting_context::{FormattingContext, LayoutError};
@@ -23,7 +24,16 @@ impl BlockFormattingContext {
 
   pub fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints) -> Result<FragmentNode, LayoutError> {
     let _ = self.parallelism;
-    let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let (width_base, height_base) = if axes.inline_axis() == PhysicalAxis::X {
+      (constraints.inline_percentage_base, constraints.block_percentage_base)
+    } else {
+      (constraints.block_percentage_base, constraints.inline_percentage_base)
+    };
+    let config =
+      LayoutConfig::new(constraints.available_size()).with_percentage_bases(width_base, height_base);
+    let engine = LayoutEngine::new(config);
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree).map(|tree| tree.root)
   }
diff --git a/src/layout_minimal/contexts/flex.rs b/src/layout_minimal/contexts/flex.rs
index 49d88080c..94d0e8669 100644
--- a/src/layout_minimal/contexts/flex.rs
+++ b/src/layout_minimal/contexts/flex.rs
@@ -15,6 +15,7 @@ pub mod baseline;
 #[path = "../../layout/contexts/flex/gap.rs"]
 pub mod gap;
 
+use crate::layout::axis::{FragmentAxes, PhysicalAxis};
 use crate::layout::constraints::LayoutConstraints;
 use crate::layout::engine::{LayoutConfig, LayoutEngine, LayoutParallelism};
 use crate::layout::formatting_context::{FormattingContext, LayoutError};
@@ -44,7 +45,16 @@ impl FlexFormattingContext {
 
   pub fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints) -> Result<FragmentNode, LayoutError> {
     let _ = self.parallelism;
-    let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let (width_base, height_base) = if axes.inline_axis() == PhysicalAxis::X {
+      (constraints.inline_percentage_base, constraints.block_percentage_base)
+    } else {
+      (constraints.block_percentage_base, constraints.inline_percentage_base)
+    };
+    let config =
+      LayoutConfig::new(constraints.available_size()).with_percentage_bases(width_base, height_base);
+    let engine = LayoutEngine::new(config);
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree).map(|tree| tree.root)
   }
diff --git a/src/layout_minimal/contexts/grid.rs b/src/layout_minimal/contexts/grid.rs
index 4a431aca3..df5b8c782 100644
--- a/src/layout_minimal/contexts/grid.rs
+++ b/src/layout_minimal/contexts/grid.rs
@@ -37,7 +37,16 @@ impl GridFormattingContext {
     constraints: &LayoutConstraints,
   ) -> Result<FragmentTree, LayoutError> {
     let _ = self.parallelism;
-    let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let (width_base, height_base) = if axes.inline_axis() == PhysicalAxis::X {
+      (constraints.inline_percentage_base, constraints.block_percentage_base)
+    } else {
+      (constraints.block_percentage_base, constraints.inline_percentage_base)
+    };
+    let config =
+      LayoutConfig::new(constraints.available_size()).with_percentage_bases(width_base, height_base);
+    let engine = LayoutEngine::new(config);
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree)
   }
diff --git a/src/layout_minimal/engine.rs b/src/layout_minimal/engine.rs
index 842409a05..e93ad78ef 100644
--- a/src/layout_minimal/engine.rs
+++ b/src/layout_minimal/engine.rs
@@ -34,6 +34,8 @@ use crate::tree::fragment_tree::{FragmentContent, FragmentNode, FragmentTree, Gr
 pub struct LayoutConfig {
   pub initial_containing_block: Size,
   pub fragmentation: Option<FragmentationOptions>,
+  percentage_base_width: Option<f32>,
+  percentage_base_height: Option<f32>,
   /// When true, treat the fragmentainer block-size as the initial containing block's block-axis
   /// size (width for vertical writing modes, height for horizontal writing modes).
   ///
@@ -44,9 +46,19 @@ pub struct LayoutConfig {
 
 impl LayoutConfig {
   pub fn new(initial_containing_block: Size) -> Self {
+    let percentage_base_width = initial_containing_block
+      .width
+      .is_finite()
+      .then_some(initial_containing_block.width.max(0.0));
+    let percentage_base_height = initial_containing_block
+      .height
+      .is_finite()
+      .then_some(initial_containing_block.height.max(0.0));
     Self {
       initial_containing_block,
       fragmentation: None,
+      percentage_base_width,
+      percentage_base_height,
       pagination_fragmentainer_size_from_icb: false,
     }
   }
@@ -57,11 +69,9 @@ impl LayoutConfig {
 
   pub fn for_pagination(page_size: Size, gap: f32) -> Self {
     let fragmentation = FragmentationOptions::new(page_size.height).with_gap(gap);
-    Self {
-      initial_containing_block: page_size,
-      fragmentation: Some(fragmentation),
-      pagination_fragmentainer_size_from_icb: true,
-    }
+    LayoutConfig::new(page_size)
+      .with_fragmentation(fragmentation)
+      .with_pagination_fragmentainer_size_from_icb(true)
   }
 
   pub fn with_fragmentation(mut self, fragmentation: FragmentationOptions) -> Self {
@@ -69,6 +79,21 @@ impl LayoutConfig {
     self.pagination_fragmentainer_size_from_icb = false;
     self
   }
+
+  pub fn with_percentage_bases(mut self, width: Option<f32>, height: Option<f32>) -> Self {
+    if let Some(width) = width.filter(|base| base.is_finite()) {
+      self.percentage_base_width = Some(width.max(0.0));
+    }
+    if let Some(height) = height.filter(|base| base.is_finite()) {
+      self.percentage_base_height = Some(height.max(0.0));
+    }
+    self
+  }
+
+  fn with_pagination_fragmentainer_size_from_icb(mut self, enabled: bool) -> Self {
+    self.pagination_fragmentainer_size_from_icb = enabled;
+    self
+  }
 }
 
 impl Default for LayoutConfig {
@@ -134,7 +159,10 @@ impl LayoutEngine {
       .as_ref()
       .map(|_| set_fragmentainer_block_offset_hint(0.0));
 
-    let root_fragment = layout_box(&box_tree.root, self.config.initial_containing_block);
+    let mut root_input = LayoutInput::from_available(self.config.initial_containing_block);
+    root_input.percentage_base_width = self.config.percentage_base_width;
+    root_input.percentage_base_height = self.config.percentage_base_height;
+    let root_fragment = layout_box(&box_tree.root, root_input);
     drop(offset_hint);
     drop(axes_hint);
     drop(size_hint);
@@ -483,6 +511,28 @@ fn remaining_fragmentainer_block_size(fallback: f32) -> f32 {
   }
 }
 
+#[derive(Debug, Clone, Copy)]
+struct LayoutInput {
+  available: Size,
+  percentage_base_width: Option<f32>,
+  percentage_base_height: Option<f32>,
+}
+
+impl LayoutInput {
+  fn from_available(available: Size) -> Self {
+    Self {
+      available,
+      percentage_base_width: available.width.is_finite().then_some(available.width.max(0.0)),
+      percentage_base_height: available.height.is_finite().then_some(available.height.max(0.0)),
+    }
+  }
+
+  fn for_child(self, available: Size) -> Self {
+    let _ = self;
+    Self::from_available(available)
+  }
+}
+
 #[derive(Debug, Clone, Copy)]
 struct LayoutBoxContext {
   /// When true, treat the box as establishing an independent formatting context for its children.
@@ -506,15 +556,15 @@ impl LayoutBoxContext {
   }
 }
 
-fn layout_box(node: &BoxNode, available: Size) -> FragmentNode {
-  layout_box_with_context(node, available, LayoutBoxContext::normal())
+fn layout_box(node: &BoxNode, input: LayoutInput) -> FragmentNode {
+  layout_box_with_context(node, input, LayoutBoxContext::normal())
 }
 
-fn layout_box_with_context(node: &BoxNode, available: Size, context: LayoutBoxContext) -> FragmentNode {
+fn layout_box_with_context(node: &BoxNode, input: LayoutInput, context: LayoutBoxContext) -> FragmentNode {
   match node.formatting_context_type {
-    FormattingContextType::Flex => layout_flex(node, available),
-    FormattingContextType::Grid => layout_grid(node, available),
-    FormattingContextType::Block => layout_block(node, available, context),
+    FormattingContextType::Flex => layout_flex(node, input),
+    FormattingContextType::Grid => layout_grid(node, input),
+    FormattingContextType::Block => layout_block(node, input, context),
   }
 }
 
@@ -545,22 +595,23 @@ fn clear_running_position_in_box_tree(node: &mut BoxNode) {
   }
 }
 
-fn snapshot_running_element(node: &BoxNode, available: Size) -> FragmentNode {
+fn snapshot_running_element(node: &BoxNode, input: LayoutInput) -> FragmentNode {
   let mut snapshot_node = node.clone();
   let mut root_style = snapshot_node.style.as_ref().clone();
   root_style.running_position = None;
   root_style.position = Position::Static;
   snapshot_node.style = Arc::new(root_style);
   clear_running_position_in_box_tree(&mut snapshot_node);
-  layout_box(&snapshot_node, available)
+  layout_box(&snapshot_node, input)
 }
 
-fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> FragmentNode {
+fn layout_block(node: &BoxNode, input: LayoutInput, context: LayoutBoxContext) -> FragmentNode {
   let style = node.style.as_ref();
+  let available = input.available;
   let mut width = resolve_length(
     style.width,
     available.width,
-    Some(available.width),
+    input.percentage_base_width,
     style.font_size,
     style.root_font_size,
   );
@@ -571,7 +622,10 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   if style.running_position.is_some() {
     let name = Arc::<str>::from(style.running_position.clone().unwrap_or_default());
     let mut anchor = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 0.0, 0.0), Vec::new());
-    let snapshot = snapshot_running_element(node, Size::new(width, f32::INFINITY));
+    let mut snapshot_input = input;
+    snapshot_input.available = Size::new(width, f32::INFINITY);
+    snapshot_input.percentage_base_height = None;
+    let snapshot = snapshot_running_element(node, snapshot_input);
     anchor.style = Some(node.style.clone());
     anchor.content = FragmentContent::RunningAnchor {
       name,
@@ -581,7 +635,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   }
 
   if style.column_count.unwrap_or(1) > 1 {
-    return layout_multicol_block(node, available, width);
+    return layout_multicol_block(node, input, width);
   }
 
   let fragmented_context =
@@ -603,7 +657,8 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
       let _offset_guard = fragmented_context
         .then(|| set_fragmentainer_block_offset_hint(parent_offset + cursor_block.max(0.0)));
 
-      let mut frag = layout_box(child, Size::new(width, available.height));
+      let child_available = Size::new(width, available.height);
+      let mut frag = layout_box(child, input.for_child(child_available));
       let child_block_size = frag.bounds.width();
       let child_inline_size = frag.bounds.height();
 
@@ -629,7 +684,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
     let mut height = resolve_length(
       style.height,
       max_inline_end,
-      Some(available.height),
+      input.percentage_base_height,
       style.font_size,
       style.root_font_size,
     );
@@ -674,7 +729,8 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
 
     let _offset_guard =
       fragmented_context.then(|| set_fragmentainer_block_offset_hint(parent_offset + cursor_y.max(0.0)));
-    let mut frag = layout_box(child, Size::new(width, available.height));
+    let child_available = Size::new(width, available.height);
+    let mut frag = layout_box(child, input.for_child(child_available));
     frag.bounds = Rect::from_xywh(0.0, cursor_y, frag.bounds.width(), frag.bounds.height());
     cursor_y += frag.bounds.height();
     prev_margin_bottom = margin_bottom;
@@ -688,7 +744,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   let mut height = resolve_length(
     style.height,
     cursor_y,
-    Some(available.height),
+    input.percentage_base_height,
     style.font_size,
     style.root_font_size,
   );
@@ -702,8 +758,9 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   fragment
 }
 
-fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> FragmentNode {
+fn layout_multicol_block(node: &BoxNode, input: LayoutInput, width: f32) -> FragmentNode {
   let style = node.style.as_ref();
+  let available = input.available;
   let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
   let block_is_horizontal = axes.block_axis() == PhysicalAxis::X;
 
@@ -711,7 +768,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
     resolve_length(
       style.height,
       available.height,
-      Some(available.height),
+      input.percentage_base_height,
       style.font_size,
       style.root_font_size,
     )
@@ -727,7 +784,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
     resolve_length(
       style.height,
       available.height,
-      Some(available.height),
+      input.percentage_base_height,
       style.font_size,
       style.root_font_size,
     )
@@ -803,7 +860,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
 
       let _offset_guard =
         fragmented_context.then(|| set_fragmentainer_block_offset_hint(parent_offset + child_block_start));
-      let fragment = layout_box(child, child_available);
+      let fragment = layout_box(child, input.for_child(child_available));
 
       let child_block_size = axes.block_size(&fragment.bounds);
       let needs_wrap = column_cursor > 0.0
@@ -955,7 +1012,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
   let mut height = resolve_length(
     style.height,
     default_height,
-    Some(available.height),
+    input.percentage_base_height,
     style.font_size,
     style.root_font_size,
   );
@@ -1452,8 +1509,9 @@ fn auto_place_row_flow(
   Some(out)
 }
 
-fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
+fn layout_grid(node: &BoxNode, input: LayoutInput) -> FragmentNode {
   let style = node.style.as_ref();
+  let available = input.available;
   let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
   let viewport = viewport_size_hint().unwrap_or(available);
 
@@ -1527,7 +1585,11 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     } else {
       Size::new(cell_inline, f32::INFINITY)
     };
-    let fragment = layout_box_with_context(child, measure_available, LayoutBoxContext::independent());
+    let fragment = layout_box_with_context(
+      child,
+      LayoutInput::from_available(measure_available),
+      LayoutBoxContext::independent(),
+    );
     let block_size = if axes.block_axis() == PhysicalAxis::X {
       fragment.bounds.width()
     } else {
@@ -1600,13 +1662,13 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
   let mut width = style
     .width
     .and_then(|length| {
-      length.resolve_px_with_fonts(Some(available.width), style.font_size, style.root_font_size)
+      length.resolve_px_with_fonts(input.percentage_base_width, style.font_size, style.root_font_size)
     })
     .unwrap_or_else(|| if track_width > 0.0 { track_width } else { available.width });
   let mut height = style
     .height
     .and_then(|length| {
-      length.resolve_px_with_fonts(Some(available.height), style.font_size, style.root_font_size)
+      length.resolve_px_with_fonts(input.percentage_base_height, style.font_size, style.root_font_size)
     })
     .unwrap_or_else(|| if track_height > 0.0 { track_height } else { 0.0 });
 
@@ -1644,11 +1706,13 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
   //
   // Grid tracks and item placement operate in the grid container's content box.
   // ---------------------------------------------------------------------------
-  let percentage_base = if available.width.is_finite() {
-    Some(available.width.max(0.0))
-  } else {
-    Some(0.0)
-  };
+  let percentage_base = Some(
+    input
+      .percentage_base_width
+      .filter(|base| base.is_finite())
+      .unwrap_or(0.0)
+      .max(0.0),
+  );
   let padding_left = style
     .padding_left
     .resolve_px_with_fonts(percentage_base, style.font_size, style.root_font_size)
@@ -1859,10 +1923,37 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
 
   let stretch_block = matches!(style.align_items, AlignItems::Stretch);
 
+  // CSS Box Alignment / `gap`: percentage gaps resolve against the container's inline size.
+  let gap_base = if container_inline_size.is_finite() {
+    container_inline_size.max(0.0)
+  } else {
+    0.0
+  };
+  let resolve_gap = |len: Length| {
+    len
+      .resolve_px_with_fonts(Some(gap_base), style.font_size, style.root_font_size)
+      .unwrap_or(0.0)
+      .max(0.0)
+  };
+  let row_gap = if style.grid_row_gap_is_normal {
+    0.0
+  } else {
+    resolve_gap(style.grid_row_gap)
+  };
+  let column_gap = if style.grid_column_gap_is_normal {
+    0.0
+  } else {
+    resolve_gap(style.grid_column_gap)
+  };
+  let row_gap = if row_gap.is_finite() { row_gap } else { 0.0 };
+  let column_gap = if column_gap.is_finite() { column_gap } else { 0.0 };
+  let row_gap_total = row_gap * (row_count.saturating_sub(1) as f32);
+  let column_gap_total = column_gap * (column_count.saturating_sub(1) as f32);
+
   let track_block_sum: f32 = row_sizes.iter().sum();
   let track_inline_sum: f32 = column_sizes.iter().sum();
-  let mut block_free = (container_block_size - track_block_sum).max(0.0);
-  let mut inline_free = (container_inline_size - track_inline_sum).max(0.0);
+  let mut block_free = (container_block_size - track_block_sum - row_gap_total).max(0.0);
+  let mut inline_free = (container_inline_size - track_inline_sum - column_gap_total).max(0.0);
 
   // `align-content: stretch` distributes any remaining free space across the grid tracks. The
   // minimal layout harness only needs the simplest behavior: grow each row equally.
@@ -1913,18 +2004,30 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     | JustifyContent::SpaceEvenly => 0.0,
   };
 
-  let mut row_edges: Vec<f32> = Vec::with_capacity(row_count + 1);
-  row_edges.push(block_offset);
-  for size in row_sizes.iter().copied() {
-    let next = row_edges.last().copied().unwrap_or(block_offset) + size;
-    row_edges.push(next);
+  let mut row_ranges_layout = Vec::with_capacity(row_count);
+  let mut block_cursor = block_offset;
+  for (idx, size) in row_sizes.iter().copied().enumerate() {
+    let size = if size.is_finite() { size.max(0.0) } else { 0.0 };
+    let start = block_cursor;
+    let end = start + size;
+    row_ranges_layout.push((start, end));
+    block_cursor = end;
+    if idx + 1 < row_count {
+      block_cursor += row_gap;
+    }
   }
 
-  let mut column_edges: Vec<f32> = Vec::with_capacity(column_count + 1);
-  column_edges.push(inline_offset);
-  for size in column_sizes.iter().copied() {
-    let next = column_edges.last().copied().unwrap_or(inline_offset) + size;
-    column_edges.push(next);
+  let mut col_ranges_layout = Vec::with_capacity(column_count);
+  let mut inline_cursor = inline_offset;
+  for (idx, size) in column_sizes.iter().copied().enumerate() {
+    let size = if size.is_finite() { size.max(0.0) } else { 0.0 };
+    let start = inline_cursor;
+    let end = start + size;
+    col_ranges_layout.push((start, end));
+    inline_cursor = end;
+    if idx + 1 < column_count {
+      inline_cursor += column_gap;
+    }
   }
 
   fn mirror_ranges(ranges: &mut [(f32, f32)], span_start: f32, span_end: f32) {
@@ -1947,22 +2050,8 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     }
   }
 
-  let mut row_ranges = Vec::with_capacity(row_count);
-  for window in row_edges.windows(2) {
-    let start = window[0];
-    let end = window[1];
-    if start.is_finite() && end.is_finite() && end >= start {
-      row_ranges.push((start, end));
-    }
-  }
-  let mut col_ranges = Vec::with_capacity(column_count);
-  for window in column_edges.windows(2) {
-    let start = window[0];
-    let end = window[1];
-    if start.is_finite() && end.is_finite() && end >= start {
-      col_ranges.push((start, end));
-    }
-  }
+  let mut row_ranges = row_ranges_layout.clone();
+  let mut col_ranges = col_ranges_layout.clone();
   if !axes.block_positive() {
     mirror_ranges(&mut row_ranges, 0.0, container_block_size.max(0.0));
   }
@@ -2009,20 +2098,26 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
       )
     };
 
-    let row_start_edge = row_start.saturating_sub(1) as usize;
-    let col_start_edge = col_start.saturating_sub(1) as usize;
-    let row_end_edge = row_end.saturating_sub(1) as usize;
-    let col_end_edge = col_end.saturating_sub(1) as usize;
+    let row_start_track = row_start.saturating_sub(1) as usize;
+    let col_start_track = col_start.saturating_sub(1) as usize;
+    let row_end_track = row_end.saturating_sub(2) as usize;
+    let col_end_track = col_end.saturating_sub(2) as usize;
 
-    let Some(&block_start) = row_edges.get(row_start_edge) else {
+    let Some(&(block_start, _)) = row_ranges_layout.get(row_start_track) else {
       continue;
     };
-    let Some(&inline_start) = column_edges.get(col_start_edge) else {
+    let Some(&(inline_start, _)) = col_ranges_layout.get(col_start_track) else {
       continue;
     };
 
-    let block_end = row_edges.get(row_end_edge).copied().unwrap_or(block_start);
-    let inline_end = column_edges.get(col_end_edge).copied().unwrap_or(inline_start);
+    let block_end = row_ranges_layout
+      .get(row_end_track)
+      .map(|(_, end)| *end)
+      .unwrap_or(block_start);
+    let inline_end = col_ranges_layout
+      .get(col_end_track)
+      .map(|(_, end)| *end)
+      .unwrap_or(inline_start);
     let cell_block = (block_end - block_start).max(0.0);
     let cell_inline = (inline_end - inline_start).max(0.0);
 
@@ -2036,7 +2131,11 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
       set_fragmentainer_block_offset_hint(parent_offset + block_start_padding + block_start.max(0.0))
     });
 
-    let mut fragment = layout_box_with_context(child, child_available, LayoutBoxContext::independent());
+    let mut fragment = layout_box_with_context(
+      child,
+      LayoutInput::from_available(child_available),
+      LayoutBoxContext::independent(),
+    );
     let child_style = child.style.as_ref();
     let item_axes =
       FragmentAxes::from_writing_mode_and_direction(child_style.writing_mode, child_style.direction);
@@ -2204,8 +2303,9 @@ fn flex_gap_px(style: &ComputedStyle, container_inline_size: f32) -> (f32, f32)
   (row_gap, column_gap)
 }
 
-fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
+fn layout_flex(node: &BoxNode, input: LayoutInput) -> FragmentNode {
   let style = node.style.as_ref();
+  let available = input.available;
   // Map writing mode to physical axes.
   let inline_positive = inline_axis_positive(style.writing_mode, style.direction);
   let block_positive = block_axis_positive(style.writing_mode);
@@ -2214,14 +2314,12 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
   let container_width = resolve_length(
     style.width,
     available.width,
-    Some(available.width),
+    input.percentage_base_width,
     style.font_size,
     style.root_font_size,
   );
   let mut container_height = style.height.and_then(|height| {
-    let base = available.height;
-    let base = base.is_finite().then_some(base);
-    height.resolve_px_with_fonts(base, style.font_size, style.root_font_size)
+    height.resolve_px_with_fonts(input.percentage_base_height, style.font_size, style.root_font_size)
   });
 
   #[derive(Clone, Copy)]
@@ -2294,7 +2392,7 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
   let mut items: Vec<FlexItem> = Vec::with_capacity(ordered_in_flow.len());
   for entry in ordered_in_flow.iter().filter(|entry| !entry.is_running) {
     let child = entry.node;
-    let fragment = layout_box(child, available);
+    let fragment = layout_box(child, input.for_child(available));
     let size = Size::new(fragment.bounds.width(), fragment.bounds.height());
     let main_size = if main_axis_is_x { size.width } else { size.height };
     let cross_size = if cross_axis_is_x { size.width } else { size.height };
@@ -2501,7 +2599,7 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
         set_fragmentainer_block_offset_hint(parent_offset + child_block_start)
       });
 
-      let mut fragment = layout_box(item.node, item.size);
+      let mut fragment = layout_box(item.node, LayoutInput::from_available(item.size));
       fragment.style = Some(item.node.style.clone());
       fragment.content = FragmentContent::Block {
         box_id: Some(item.node.id),
@@ -2593,7 +2691,10 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
     );
 
     let name = Arc::<str>::from(entry.node.style.running_position.clone().unwrap_or_default());
-    let snapshot = snapshot_running_element(entry.node, Size::new(container_width, f32::INFINITY));
+    let mut snapshot_input =
+      LayoutInput::from_available(Size::new(container_width, f32::INFINITY));
+    snapshot_input.percentage_base_width = input.percentage_base_width;
+    let snapshot = snapshot_running_element(entry.node, snapshot_input);
     let mut anchor = FragmentNode::new_block(anchor_bounds, Vec::new());
     anchor.style = Some(entry.node.style.clone());
     anchor.content = FragmentContent::RunningAnchor {
@@ -2614,7 +2715,7 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
     }
 
     if matches!(child.style.position, Position::Absolute | Position::Fixed) {
-      let mut fragment = layout_box(child, available);
+      let mut fragment = layout_box(child, input.for_child(available));
       fragment.style = Some(child.style.clone());
       fragment.content = FragmentContent::Block {
         box_id: Some(child.id),
diff --git a/src/net/websocket/mod.rs b/src/net/websocket/mod.rs
index 77a4ec243..784003165 100644
--- a/src/net/websocket/mod.rs
+++ b/src/net/websocket/mod.rs
@@ -14,7 +14,6 @@ pub mod handshake;
 pub mod handshake_client;
 pub mod http_response_head;
 pub mod http_headers;
-pub mod maybe_tls_stream;
 pub mod message;
 mod maybe_tls_stream;
 pub mod ws_url;
@@ -35,7 +34,6 @@ pub use connect::{client_handshake, HandshakeOptions, HandshakeResult};
 pub use frame::{Frame, FrameCodec, FrameDecodeError, FrameEncodeError, FrameLimits, OpCode, Role};
 pub use handshake::cookie_url_for_ws_url;
 pub use handshake::WebSocketHandshakeError as ClientHandshakeError;
-pub use maybe_tls_stream::MaybeTlsStream;
 pub use handshake::{
   build_client_handshake_request, compute_sec_websocket_accept, generate_sec_websocket_key,
   validate_server_handshake_response, ClientHandshake, Header as HandshakeHeader,
@@ -49,6 +47,7 @@ pub use message::{
   decode_close_payload, encode_close_payload, Message, MessageCodec, MessageDecodeError,
   MessageEncodeError, MessageLimits, MAX_CLOSE_REASON_BYTES,
 };
+pub use maybe_tls_stream::MaybeTlsStream;
 pub use origin::{is_secure_context_for_document_url, serialized_origin_for_document_url};
 pub use stream::{WebSocketStream, WebSocketStreamError, WsMessage};
 
diff --git a/src/net/websocket/stream.rs b/src/net/websocket/stream.rs
index c6661035a..b7ba2ef1e 100644
--- a/src/net/websocket/stream.rs
+++ b/src/net/websocket/stream.rs
@@ -16,10 +16,10 @@ use std::str;
 
 use thiserror::Error;
 use super::frame::close_code;
+pub use super::maybe_tls_stream::MaybeTlsStream;
 use super::{
   FrameCodec, FrameDecodeError, FrameEncodeError, FrameLimits, OpCode, Role, MAX_CLOSE_REASON_BYTES,
 };
-
 /// High-level WebSocket message/control event.
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum WsMessage {
diff --git a/src/platform/macos/core_graphics_rasterizer/renderer.rs b/src/platform/macos/core_graphics_rasterizer/renderer.rs
index a2165fa95..eb9c4ee77 100644
--- a/src/platform/macos/core_graphics_rasterizer/renderer.rs
+++ b/src/platform/macos/core_graphics_rasterizer/renderer.rs
@@ -12702,99 +12702,175 @@ pub(super) fn render_table_collapsed_borders(
             rotation,
             run_scale,
           );
-          if let Some(renderer) = color_renderer.as_ref() {
-            let Some(font) = font else {
-              unsafe {
-                sys::CGContextRestoreGState(self.context.ctx);
-              }
-              return Ok(());
-            };
-            let (fill_r, fill_g, fill_b, fill_a) = rgba_components(color);
-            let (stroke_r, stroke_g, stroke_b, stroke_a) = rgba_components(stroke_color);
-            if let Some(instance) = FontInstance::new(font, &scratch.variations) {
-              for (idx, glyph) in glyphs.iter().enumerate() {
-                let color_glyph = cached_color_glyph(
-                  renderer,
-                  font,
-                  &instance,
-                  glyph.glyph_id,
-                  font_size,
-                  palette_index,
-                  resolved_palette_overrides,
-                  resolved_palette_override_hash,
-                  variation_hash,
-                  color_for_glyph,
-                  synthetic_oblique,
-                  &scratch.variations,
-                  target_size,
-                );
-                if let Some(color_glyph) = color_glyph {
-                  let glyph_id = scratch.glyphs[idx];
-                  let position = scratch.positions[idx];
-                  if draw_synthetic_bold {
-                    unsafe {
-                      sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFillStroke);
-                      sys::CGContextSetRGBFillColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
-                      sys::CGContextSetRGBStrokeColor(
-                        self.context.ctx,
-                        fill_r,
-                        fill_g,
-                        fill_b,
-                        fill_a,
-                      );
-                      sys::CGContextSetLineWidth(
-                        self.context.ctx,
-                        synthetic_bold_width as sys::CGFloat,
-                      );
-                      sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
-                      sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
-                      sys::CTFontDrawGlyphs(
-                        ct_font.as_ptr(),
-                        &glyph_id,
-                        &position,
-                        1,
-                        self.context.ctx,
-                      );
+          let (fill_r, fill_g, fill_b, fill_a) = rgba_components(color);
+          let (stroke_r, stroke_g, stroke_b, stroke_a) = rgba_components(stroke_color);
+
+          if use_color_glyphs {
+            if let Some(renderer) = color_renderer.as_ref() {
+              let Some(font) = font else {
+                unsafe {
+                  sys::CGContextRestoreGState(self.context.ctx);
+                }
+                return Ok(());
+              };
+              if let Some(instance) = FontInstance::new(font, &scratch.variations) {
+                for (idx, glyph) in glyphs.iter().enumerate() {
+                  let color_glyph = cached_color_glyph(
+                    renderer,
+                    font,
+                    &instance,
+                    glyph.glyph_id,
+                    font_size,
+                    palette_index,
+                    resolved_palette_overrides,
+                    resolved_palette_override_hash,
+                    variation_hash,
+                    color_for_glyph,
+                    synthetic_oblique,
+                    &scratch.variations,
+                    target_size,
+                  );
+                  if let Some(color_glyph) = color_glyph {
+                    let glyph_id = scratch.glyphs[idx];
+                    let position = scratch.positions[idx];
+                    if draw_synthetic_bold {
+                      unsafe {
+                        sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFillStroke);
+                        sys::CGContextSetRGBFillColor(
+                          self.context.ctx,
+                          fill_r,
+                          fill_g,
+                          fill_b,
+                          fill_a,
+                        );
+                        sys::CGContextSetRGBStrokeColor(
+                          self.context.ctx,
+                          fill_r,
+                          fill_g,
+                          fill_b,
+                          fill_a,
+                        );
+                        sys::CGContextSetLineWidth(
+                          self.context.ctx,
+                          synthetic_bold_width as sys::CGFloat,
+                        );
+                        sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
+                        sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
+                        sys::CTFontDrawGlyphs(
+                          ct_font.as_ptr(),
+                          &glyph_id,
+                          &position,
+                          1,
+                          self.context.ctx,
+                        );
+                      }
                     }
-                  }
-                  if draw_stroke {
-                    unsafe {
-                      sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextStroke);
-                      sys::CGContextSetRGBStrokeColor(
-                        self.context.ctx,
-                        stroke_r,
-                        stroke_g,
-                        stroke_b,
-                        stroke_a,
-                      );
-                      sys::CGContextSetLineWidth(self.context.ctx, stroke_width as sys::CGFloat);
-                      sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
-                      sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
-                      sys::CTFontDrawGlyphs(
-                        ct_font.as_ptr(),
-                        &glyph_id,
-                        &position,
-                        1,
-                        self.context.ctx,
-                      );
+                    if draw_stroke {
+                      unsafe {
+                        sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextStroke);
+                        sys::CGContextSetRGBStrokeColor(
+                          self.context.ctx,
+                          stroke_r,
+                          stroke_g,
+                          stroke_b,
+                          stroke_a,
+                        );
+                        sys::CGContextSetLineWidth(self.context.ctx, stroke_width as sys::CGFloat);
+                        sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
+                        sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
+                        sys::CTFontDrawGlyphs(
+                          ct_font.as_ptr(),
+                          &glyph_id,
+                          &position,
+                          1,
+                          self.context.ctx,
+                        );
+                      }
+                    }
+                    if glyph_opacity > 0.0 {
+                      self.draw_color_glyph_image(&color_glyph, position, glyph_opacity)?;
                     }
+                  } else {
+                    scratch.outline_glyphs.push(scratch.glyphs[idx]);
+                    scratch.outline_positions.push(scratch.positions[idx]);
+                  }
+                }
+              } else {
+                scratch.outline_glyphs.extend(scratch.glyphs.iter().copied());
+                scratch
+                  .outline_positions
+                  .extend(scratch.positions.iter().copied());
+              }
+
+              if !scratch.outline_glyphs.is_empty() {
+                if draw_synthetic_bold {
+                  unsafe {
+                    sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFillStroke);
+                    sys::CGContextSetRGBFillColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
+                    sys::CGContextSetRGBStrokeColor(
+                      self.context.ctx,
+                      fill_r,
+                      fill_g,
+                      fill_b,
+                      fill_a,
+                    );
+                    sys::CGContextSetLineWidth(
+                      self.context.ctx,
+                      synthetic_bold_width as sys::CGFloat,
+                    );
+                    sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
+                    sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
+                    sys::CTFontDrawGlyphs(
+                      ct_font.as_ptr(),
+                      scratch.outline_glyphs.as_ptr(),
+                      scratch.outline_positions.as_ptr(),
+                      scratch.outline_glyphs.len(),
+                      self.context.ctx,
+                    );
                   }
-                  if glyph_opacity > 0.0 {
-                    self.draw_color_glyph_image(&color_glyph, position, glyph_opacity)?;
+                } else if draw_fill {
+                  unsafe {
+                    sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFill);
+                    sys::CGContextSetRGBFillColor(
+                      self.context.ctx,
+                      fill_r,
+                      fill_g,
+                      fill_b,
+                      fill_a,
+                    );
+                    sys::CTFontDrawGlyphs(
+                      ct_font.as_ptr(),
+                      scratch.outline_glyphs.as_ptr(),
+                      scratch.outline_positions.as_ptr(),
+                      scratch.outline_glyphs.len(),
+                      self.context.ctx,
+                    );
+                  }
+                }
+                if draw_stroke {
+                  unsafe {
+                    sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextStroke);
+                    sys::CGContextSetRGBStrokeColor(
+                      self.context.ctx,
+                      stroke_r,
+                      stroke_g,
+                      stroke_b,
+                      stroke_a,
+                    );
+                    sys::CGContextSetLineWidth(self.context.ctx, stroke_width as sys::CGFloat);
+                    sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
+                    sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
+                    sys::CTFontDrawGlyphs(
+                      ct_font.as_ptr(),
+                      scratch.outline_glyphs.as_ptr(),
+                      scratch.outline_positions.as_ptr(),
+                      scratch.outline_glyphs.len(),
+                      self.context.ctx,
+                    );
                   }
-                } else {
-                  scratch.outline_glyphs.push(scratch.glyphs[idx]);
-                  scratch.outline_positions.push(scratch.positions[idx]);
                 }
               }
             } else {
-              scratch.outline_glyphs.extend(scratch.glyphs.iter().copied());
-              scratch
-                .outline_positions
-                .extend(scratch.positions.iter().copied());
-            }
-
-            if !scratch.outline_glyphs.is_empty() {
               if draw_synthetic_bold {
                 unsafe {
                   sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFillStroke);
@@ -12808,9 +12884,9 @@ pub(super) fn render_table_collapsed_borders(
                   sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
                   sys::CTFontDrawGlyphs(
                     ct_font.as_ptr(),
-                    scratch.outline_glyphs.as_ptr(),
-                    scratch.outline_positions.as_ptr(),
-                    scratch.outline_glyphs.len(),
+                    scratch.glyphs.as_ptr(),
+                    scratch.positions.as_ptr(),
+                    scratch.glyphs.len(),
                     self.context.ctx,
                   );
                 }
@@ -12820,9 +12896,9 @@ pub(super) fn render_table_collapsed_borders(
                   sys::CGContextSetRGBFillColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
                   sys::CTFontDrawGlyphs(
                     ct_font.as_ptr(),
-                    scratch.outline_glyphs.as_ptr(),
-                    scratch.outline_positions.as_ptr(),
-                    scratch.outline_glyphs.len(),
+                    scratch.glyphs.as_ptr(),
+                    scratch.positions.as_ptr(),
+                    scratch.glyphs.len(),
                     self.context.ctx,
                   );
                 }
@@ -12842,19 +12918,18 @@ pub(super) fn render_table_collapsed_borders(
                   sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
                   sys::CTFontDrawGlyphs(
                     ct_font.as_ptr(),
-                    scratch.outline_glyphs.as_ptr(),
-                    scratch.outline_positions.as_ptr(),
-                    scratch.outline_glyphs.len(),
+                    scratch.glyphs.as_ptr(),
+                    scratch.positions.as_ptr(),
+                    scratch.glyphs.len(),
                     self.context.ctx,
                   );
                 }
               }
           } else if draw_synthetic_bold {
-            let (r, g, b, a) = rgba_components(color);
             unsafe {
               sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFillStroke);
-              sys::CGContextSetRGBFillColor(self.context.ctx, r, g, b, a);
-              sys::CGContextSetRGBStrokeColor(self.context.ctx, r, g, b, a);
+              sys::CGContextSetRGBFillColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
+              sys::CGContextSetRGBStrokeColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
               sys::CGContextSetLineWidth(self.context.ctx, synthetic_bold_width as sys::CGFloat);
               sys::CGContextSetLineJoin(self.context.ctx, sys::kCGLineJoinRound);
               sys::CGContextSetLineCap(self.context.ctx, sys::kCGLineCapRound);
@@ -12867,10 +12942,9 @@ pub(super) fn render_table_collapsed_borders(
               );
             }
           } else if draw_fill {
-            let (r, g, b, a) = rgba_components(color);
             unsafe {
               sys::CGContextSetTextDrawingMode(self.context.ctx, sys::kCGTextFill);
-              sys::CGContextSetRGBFillColor(self.context.ctx, r, g, b, a);
+              sys::CGContextSetRGBFillColor(self.context.ctx, fill_r, fill_g, fill_b, fill_a);
               sys::CTFontDrawGlyphs(
                 ct_font.as_ptr(),
                 scratch.glyphs.as_ptr(),
diff --git a/src/style_minimal/computed.rs b/src/style_minimal/computed.rs
new file mode 100644
index 000000000..b7157a1f9
--- /dev/null
+++ b/src/style_minimal/computed.rs
@@ -0,0 +1,8 @@
+//! Minimal `PositionedStyle` compatibility layer for non-macOS builds.
+//!
+//! The full renderer exposes `crate::style::computed::PositionedStyle`. The non-macOS snapshot
+//! builds use `style_minimal`, which only defines a `ComputedStyle` struct. Provide a type alias so
+//! shared test helpers can keep importing `crate::style::computed::PositionedStyle`.
+
+pub type PositionedStyle = super::ComputedStyle;
+
diff --git a/src/style_minimal/mod.rs b/src/style_minimal/mod.rs
index 26155e0f8..c4ba020de 100644
--- a/src/style_minimal/mod.rs
+++ b/src/style_minimal/mod.rs
@@ -1,6 +1,7 @@
 //! Minimal style system for layout/fragmentation unit tests.
 
 pub mod color;
+pub mod computed;
 pub mod display;
 pub mod float;
 pub mod media;
-- 
2.43.0

