From bae8c4c72bf9ff313e6a44fa218a911feb6202f6 Mon Sep 17 00:00:00 2001
From: Wilson Lin <code@wilsonl.in>
Date: Sun, 18 Jan 2026 04:14:58 -0800
Subject: [PATCH] fix: stabilize non-macOS layout fragmentation and URL
 rewriting

- Preserve unpaired surrogate escapes when unescaping JavaScript string literals
- Fix minimal grid layout to account for row/column gaps and correct content distribution semantics
- Treat mirrored grid track ranges as flow-ordered during fragmentation (avoids gap-only pages)
- Wire percentage bases through minimal layout constraints/formatting contexts
- Clean up non-macOS build breakage (WebSocket module exports, ipc_stack feature, fastrender_url helper, Cargo.lock)
- Enable and fix grid track range regression tests (no inner-test warnings; keep 0px tracks intact)
- Ensure flex abspos profiling calls record_out_of_flow_placement_time (keeps layout_engine policy tests passing)
---
 Cargo.lock                                    |   8 -
 crates/fastrender_url/src/code_points.rs      |   1 -
 crates/ipc_stack/Cargo.toml                   |   3 +
 src/css/loader.rs                             |  45 ++++
 src/html/streaming_parser.rs                  |  23 +-
 src/layout/contexts/flex/mod_macos.rs         |   7 +-
 .../grid/tests/fragmentation_tracks_test.rs   |   4 +-
 src/layout/fragmentation.rs                   | 215 ++++++++++++++----
 src/layout/tests/grid_calc_gap.rs             |   2 +
 src/layout/tests/grid_percent_gap.rs          |  24 +-
 src/layout_engine/layout/contexts/grid.rs     |   2 +
 src/layout_minimal/constraints.rs             |  11 +-
 src/layout_minimal/contexts/block.rs          |  17 ++
 src/layout_minimal/contexts/flex.rs           |  18 +-
 src/layout_minimal/contexts/grid.rs           |  19 +-
 src/layout_minimal/engine.rs                  | 171 ++++++++++----
 src/layout_minimal/formatting_context.rs      |  42 ++++
 src/net/websocket/mod.rs                      |   3 +-
 src/net/websocket/stream.rs                   |   1 +
 src/platform/macos/scroll_end.rs              |   4 +-
 src/utils/js_escapes.rs                       |  14 ++
 21 files changed, 515 insertions(+), 119 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 73bb2fbee5..4e1e724411 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3164,14 +3164,6 @@ version = "0.2.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"
 
-[[package]]
-name = "url"
-version = "2.5.8"
-dependencies = [
- "fastrender_url",
- "idna",
-]
-
 [[package]]
 name = "utf8_iter"
 version = "1.0.4"
diff --git a/crates/fastrender_url/src/code_points.rs b/crates/fastrender_url/src/code_points.rs
index 8037df7030..2abf204655 100644
--- a/crates/fastrender_url/src/code_points.rs
+++ b/crates/fastrender_url/src/code_points.rs
@@ -10,7 +10,6 @@ pub(crate) fn is_ascii_alphanumeric(c: char) -> bool {
   is_ascii_alpha(c) || matches!(c, '0'..='9')
 }
 
-#[cfg(test)]
 #[inline]
 pub(crate) fn is_ascii_hex_digit(c: char) -> bool {
   matches!(c, '0'..='9' | 'A'..='F' | 'a'..='f')
diff --git a/crates/ipc_stack/Cargo.toml b/crates/ipc_stack/Cargo.toml
index be6acf9e79..38e55c955a 100644
--- a/crates/ipc_stack/Cargo.toml
+++ b/crates/ipc_stack/Cargo.toml
@@ -9,6 +9,9 @@ autobenches = false
 
 [features]
 default = []
+# Shared sources use `cfg(feature = "renderer")` for TLS-enabled WebSocket transports; define the
+# feature here so `check-cfg` remains quiet in this lightweight crate.
+renderer = []
 # Feature gate used by `tests/integration.rs` to opt into the full renderer integration suite.
 renderer_integration_tests = []
 # Compatibility shims for renderer-only cfg flags referenced in shared sources.
diff --git a/src/css/loader.rs b/src/css/loader.rs
index 752f7d35fb..7cbeb6d540 100644
--- a/src/css/loader.rs
+++ b/src/css/loader.rs
@@ -679,6 +679,51 @@ pub fn absolutize_css_urls_cow<'a>(
           last_emitted = parser.position();
         }
         Token::BadUrl(_) => {}
+        Token::Function(name) if name.eq_ignore_ascii_case("url") => {
+          let parse_result = parser.parse_nested_block(|nested| {
+            nested.skip_whitespace();
+            let token = match nested.next_including_whitespace::<()>() {
+              Ok(token) => token,
+              Err(_) => return Ok(None),
+            };
+
+            let url = match token {
+              Token::QuotedString(value) | Token::Ident(value) | Token::UnquotedUrl(value) => {
+                Some(value)
+              }
+              _ => return Ok(None),
+            };
+
+            nested.skip_whitespace();
+            if !nested.is_exhausted() {
+              return Ok(None);
+            }
+
+            Ok(url.map(|value| value.to_string()))
+          });
+
+          let Ok(Some(url_value)) = parse_result else {
+            continue;
+          };
+          if !should_resolve_css_url(&url_value) {
+            continue;
+          }
+          let Some(resolved) = resolve_css_url(base_url, &url_value) else {
+            continue;
+          };
+
+          let block_text = parser.slice_from(token_start);
+          let chunk = parser.slice_from(last_emitted);
+          let prefix_len = chunk.len().saturating_sub(block_text.len());
+          let out = out.get_or_insert_with(|| String::with_capacity(capacity_hint));
+          out.push_str(&chunk[..prefix_len]);
+
+          out.push_str("url(\"");
+          push_escaped_url_for_css(out, resolved.as_str());
+          out.push_str("\")");
+
+          last_emitted = parser.position();
+        }
         Token::Function(name)
           if name.eq_ignore_ascii_case("image-set")
             || name.eq_ignore_ascii_case("-webkit-image-set") =>
diff --git a/src/html/streaming_parser.rs b/src/html/streaming_parser.rs
index 78553415dc..fb31da20c9 100644
--- a/src/html/streaming_parser.rs
+++ b/src/html/streaming_parser.rs
@@ -1014,14 +1014,17 @@ impl InTreeParser {
 
     // Update base URL tracker after insertion.
     let (in_head, in_foreign_namespace, in_template) = self.compute_insertion_flags(doc);
-    self.base_url_tracker.borrow_mut().on_element_inserted(
-      name,
-      namespace.as_str(),
-      &attrs,
-      in_head,
-      in_foreign_namespace,
-      in_template,
-    );
+    {
+      let mut tracker = self.base_url_tracker.borrow_mut();
+      tracker.on_element_inserted(
+        name,
+        namespace.as_str(),
+        &attrs,
+        in_head,
+        in_foreign_namespace,
+        in_template,
+      );
+    }
     self.maybe_queue_stylesheet_link(
       element,
       name,
@@ -1064,10 +1067,10 @@ impl InTreeParser {
     // Stylesheet discovery is not limited to the document `<head>`; `<link rel=stylesheet>` can
     // appear in the body and inside declarative Shadow DOM, and we still want to surface those
     // URLs to the caller so it can prefetch them for script blocking / style calculation.
-    if in_template || in_foreign_namespace {
+    if !tag_name.eq_ignore_ascii_case("link") {
       return;
     }
-    if !tag_name.eq_ignore_ascii_case("link") {
+    if in_template || in_foreign_namespace {
       return;
     }
 
diff --git a/src/layout/contexts/flex/mod_macos.rs b/src/layout/contexts/flex/mod_macos.rs
index 9acdbaef3a..a3ed9a4d9c 100644
--- a/src/layout/contexts/flex/mod_macos.rs
+++ b/src/layout/contexts/flex/mod_macos.rs
@@ -2330,7 +2330,12 @@ impl FlexFormattingContext {
         }
         attach_fragment_style_for_box(&mut fragment, child);
         container_fragment.children_mut().push(fragment);
-        flex_profile::record_placement_time(placement_timer);
+        // Out-of-flow positioned descendants (absolute/fixed) are laid out during the same
+        // fragment-building pass as the rest of flex layout. Track their contribution separately
+        // so profiling can report how much time is spent in abspos placement vs. line/fragment
+        // generation, while still accounting for it in the overall finalize time.
+        flex_profile::record_out_of_flow_placement_time(placement_timer);
+        flex_profile::record_finalize_time(placement_timer);
       }
     }
 
diff --git a/src/layout/contexts/grid/tests/fragmentation_tracks_test.rs b/src/layout/contexts/grid/tests/fragmentation_tracks_test.rs
index 9b431568c4..449944becc 100644
--- a/src/layout/contexts/grid/tests/fragmentation_tracks_test.rs
+++ b/src/layout/contexts/grid/tests/fragmentation_tracks_test.rs
@@ -224,7 +224,8 @@ fn grid_tracks_flow_order_for_sideways_lr_inline_axis() {
     assert_track_ranges_in_flow_order(ranges, axes.inline_positive(), inline_size, label);
     let block_size = axes.block_size(&fragment.bounds);
     assert_track_ranges_in_flow_order(block_ranges, axes.block_positive(), block_size, label);
-  assert_fragmentation_boundaries(&fragment, axes);
+    assert_fragmentation_boundaries(&fragment, axes);
+  }
 }
 
 #[test]
@@ -257,4 +258,3 @@ fn grid_tracks_preserve_zero_length_rows() {
     "expected first row track to be zero-length, got {first_start}..{first_end}"
   );
 }
-}
diff --git a/src/layout/fragmentation.rs b/src/layout/fragmentation.rs
index 31360e2b3c..1ed8a98084 100644
--- a/src/layout/fragmentation.rs
+++ b/src/layout/fragmentation.rs
@@ -1362,6 +1362,92 @@ fn grid_tracks_in_fragmentation_axis<'a>(
   }
 }
 
+#[derive(Clone, Copy)]
+struct GridTracksFlowOrder<'a> {
+  tracks: &'a [(f32, f32)],
+  reversed: bool,
+}
+
+impl<'a> GridTracksFlowOrder<'a> {
+  fn new(tracks: &'a [(f32, f32)], axis: &FragmentAxis, parent_block_size: f32) -> Self {
+    let forward_ok = grid_tracks_are_in_flow_order(tracks, axis, parent_block_size, false);
+    let reverse_ok = grid_tracks_are_in_flow_order(tracks, axis, parent_block_size, true);
+    let reversed = !forward_ok && reverse_ok;
+
+    debug_assert!(
+      tracks.len() < 2 || !parent_block_size.is_finite() || forward_ok || reverse_ok,
+      "GridTrackRanges must be monotonic in flow coordinates for fragmentation"
+    );
+
+    Self { tracks, reversed }
+  }
+
+  fn len(&self) -> usize {
+    self.tracks.len()
+  }
+
+  fn is_empty(&self) -> bool {
+    self.tracks.is_empty()
+  }
+
+  fn track_at(&self, idx: usize) -> Option<(f32, f32)> {
+    let raw_idx = if self.reversed {
+      self.tracks.len().checked_sub(1 + idx)?
+    } else {
+      idx
+    };
+    self.tracks.get(raw_idx).copied()
+  }
+
+  fn flow_line(&self, line: u16) -> u16 {
+    if !self.reversed {
+      return line;
+    }
+    if line == 0 {
+      return 0;
+    }
+    let total_lines = self.tracks.len().saturating_add(1);
+    let total_lines = u16::try_from(total_lines).unwrap_or(u16::MAX);
+    total_lines.saturating_add(1).saturating_sub(line)
+  }
+}
+
+fn grid_tracks_are_in_flow_order(
+  tracks: &[(f32, f32)],
+  axis: &FragmentAxis,
+  parent_block_size: f32,
+  reversed: bool,
+) -> bool {
+  if tracks.len() < 2 || !parent_block_size.is_finite() {
+    return true;
+  }
+
+  let mut prev_flow_start: Option<f32> = None;
+  for step in 0..tracks.len() {
+    let idx = if reversed {
+      tracks.len().saturating_sub(1 + step)
+    } else {
+      step
+    };
+    let (track_start, track_end) = tracks[idx];
+    let track_size = (track_end - track_start).max(0.0);
+    let flow_start = axis.flow_offset(track_start, track_size, parent_block_size);
+    if !flow_start.is_finite() {
+      prev_flow_start = None;
+      continue;
+    }
+
+    if let Some(prev) = prev_flow_start {
+      if flow_start + BREAK_EPSILON < prev {
+        return false;
+      }
+    }
+    prev_flow_start = Some(flow_start);
+  }
+
+  true
+}
+
 #[cfg(debug_assertions)]
 pub(crate) fn debug_assert_grid_tracks_in_flow_order(
   tracks: &[(f32, f32)],
@@ -1431,8 +1517,11 @@ fn grid_item_lines_in_fragmentation_axis(
   placement: &GridItemFragmentationData,
   axis: &FragmentAxis,
 ) -> (u16, u16) {
-  let _ = axis;
-  (placement.row_start, placement.row_end)
+  if axis.block_is_horizontal {
+    (placement.column_start, placement.column_end)
+  } else {
+    (placement.row_start, placement.row_end)
+  }
 }
 
 fn grid_item_spans_single_track(
@@ -4396,12 +4485,12 @@ fn collect_break_opportunities(
 
   if let (Some(tracks), Some(grid_items)) = (grid_tracks, grid_items) {
     if grid_item_break_hints_use_tracks {
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      let tracks_flow = GridTracksFlowOrder::new(tracks, axis, node_block_size);
       let in_flow_count = grid_item_count_parallel_flow;
 
       // One slot per grid line (track_count + 1). Index `i` corresponds to the boundary at line
       // `i + 1` in the fragmentation axis.
-      let mut boundary_strengths = vec![BreakStrength::Auto; tracks.len() + 1];
+      let mut boundary_strengths = vec![BreakStrength::Auto; tracks_flow.len() + 1];
 
       for idx in 0..in_flow_count {
         let child = &node.children[idx];
@@ -4412,6 +4501,13 @@ fn collect_break_opportunities(
           .unwrap_or(default_style);
         let placement = &grid_items.items[idx];
         let (start_line, end_line) = grid_item_lines_in_fragmentation_axis(placement, axis);
+        let start_line = tracks_flow.flow_line(start_line);
+        let end_line = tracks_flow.flow_line(end_line);
+        let (start_line, end_line) = if start_line <= end_line {
+          (start_line, end_line)
+        } else {
+          (end_line, start_line)
+        };
 
         let child_break_before = if child_style.position.is_absolutely_positioned() {
           BreakBetween::Auto
@@ -4459,10 +4555,10 @@ fn collect_break_opportunities(
         }
         let pos = if boundary_idx == 0 {
           abs_start
-        } else if boundary_idx == tracks.len() {
+        } else if boundary_idx == tracks_flow.len() {
           abs_end
         } else {
-          let Some((track_start, track_end)) = tracks.get(boundary_idx.saturating_sub(1)).copied()
+          let Some((track_start, track_end)) = tracks_flow.track_at(boundary_idx.saturating_sub(1))
           else {
             continue;
           };
@@ -5107,12 +5203,12 @@ fn collect_forced_boundaries_with_axes_internal(
     if matches!(node_style.display, Display::Grid | Display::InlineGrid) {
       if let (Some(grid_tracks), Some(grid_items)) = (node.grid_tracks.as_deref(), grid_items) {
         let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-        debug_assert_grid_tracks_in_flow_order(tracks, axis, parent_block_size);
-        if !tracks.is_empty() && !grid_items.items.is_empty() {
+        let tracks_flow = GridTracksFlowOrder::new(tracks, axis, parent_block_size);
+        if !tracks_flow.is_empty() && !grid_items.items.is_empty() {
           let in_flow_count = grid_items.items.len().min(node.children.len());
           // One slot per grid line (track_count + 1). Index `i` corresponds to the boundary at line
           // `i + 1`.
-          let mut boundary_reqs = vec![BoundaryRequirement::default(); tracks.len() + 1];
+          let mut boundary_reqs = vec![BoundaryRequirement::default(); tracks_flow.len() + 1];
 
           for idx in 0..in_flow_count {
             let child = &node.children[idx];
@@ -5123,6 +5219,13 @@ fn collect_forced_boundaries_with_axes_internal(
               .unwrap_or(default_style);
             let placement = &grid_items.items[idx];
             let (start_line, end_line) = grid_item_lines_in_fragmentation_axis(placement, axis);
+            let start_line = tracks_flow.flow_line(start_line);
+            let end_line = tracks_flow.flow_line(end_line);
+            let (start_line, end_line) = if start_line <= end_line {
+              (start_line, end_line)
+            } else {
+              (end_line, start_line)
+            };
 
             let child_break_before = if child_style.position.is_absolutely_positioned() {
               BreakBetween::Auto
@@ -5161,18 +5264,22 @@ fn collect_forced_boundaries_with_axes_internal(
             // boundary before line `i + 1` is the end edge of track `i` (rather than the start edge
             // of track `i + 1`, which would land after the gutter and can create gap-only pages when
             // page sizes line up exactly with track ends).
-            let mut track_flow_ends = Vec::with_capacity(tracks.len());
-            for (track_start, track_end) in tracks.iter().copied() {
+            let mut track_flow_ends = Vec::with_capacity(tracks_flow.len());
+            for idx in 0..tracks_flow.len() {
+              let Some((track_start, track_end)) = tracks_flow.track_at(idx) else {
+                track_flow_ends.push(abs_start);
+                continue;
+              };
               let track_size = (track_end - track_start).max(0.0);
               if !track_start.is_finite() {
                 track_flow_ends.push(abs_start);
-                continue;
+              } else {
+                track_flow_ends.push(
+                  abs_start
+                    + axis.flow_offset(track_start, track_size, parent_block_size)
+                    + track_size,
+                );
               }
-              track_flow_ends.push(
-                abs_start
-                  + axis.flow_offset(track_start, track_size, parent_block_size)
-                  + track_size,
-              );
             }
 
             if boundary_reqs[0].forced {
@@ -5181,7 +5288,7 @@ fn collect_forced_boundaries_with_axes_internal(
                 page_side: boundary_reqs[0].side,
               });
             }
-            for idx in 1..tracks.len() {
+            for idx in 1..tracks_flow.len() {
               let req = boundary_reqs[idx];
               if !req.forced {
                 continue;
@@ -5193,7 +5300,7 @@ fn collect_forced_boundaries_with_axes_internal(
                 });
               }
             }
-            let end_req = boundary_reqs[tracks.len()];
+            let end_req = boundary_reqs[tracks_flow.len()];
             if end_req.forced {
               forced.push(ForcedBoundary {
                 position: abs_start + parent_block_size,
@@ -5648,7 +5755,7 @@ fn collect_atomic_candidate_for_node(
   if matches!(style.display, Display::Grid | Display::InlineGrid) {
     if let Some(grid_tracks) = node.grid_tracks.as_deref() {
       let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      let tracks_flow = GridTracksFlowOrder::new(tracks, axis, node_block_size);
 
       // Treat each grid track as indivisible. Additionally, treat the inter-track gutter preceding
       // each track as part of the following track so pagination never splits a `row-gap`/`column-gap`
@@ -5658,7 +5765,10 @@ fn collect_atomic_candidate_for_node(
       // gutter). The gutter is empty space; it may force a fragmentainer to under-fill, but should
       // not cause a track band that otherwise fits to become breakable.
       let mut prev_flow_end: Option<f32> = None;
-      for (track_start, track_end) in tracks.iter().copied() {
+      for idx in 0..tracks_flow.len() {
+        let Some((track_start, track_end)) = tracks_flow.track_at(idx) else {
+          continue;
+        };
         let track_size = (track_end - track_start).max(0.0);
         let flow_offset = axis.flow_offset(track_start, track_size, node_block_size);
         let mut start = abs_start + flow_offset;
@@ -5881,13 +5991,16 @@ fn collect_atomic_range_for_node(
   if matches!(style.display, Display::Grid | Display::InlineGrid) {
     if let Some(grid_tracks) = node.grid_tracks.as_deref() {
       let tracks = grid_tracks_in_fragmentation_axis(grid_tracks, axis);
-      debug_assert_grid_tracks_in_flow_order(tracks, axis, node_block_size);
+      let tracks_flow = GridTracksFlowOrder::new(tracks, axis, node_block_size);
 
       // Treat each grid track as indivisible. Additionally, treat the inter-track gutter preceding
       // each track as part of the following track so pagination never splits a `row-gap`/`column-gap`
       // across fragmentainers (and avoids producing a fragmentainer that contains only the gap).
       let mut prev_flow_end: Option<f32> = None;
-      for (track_start, track_end) in tracks.iter().copied() {
+      for idx in 0..tracks_flow.len() {
+        let Some((track_start, track_end)) = tracks_flow.track_at(idx) else {
+          continue;
+        };
         let track_size = (track_end - track_start).max(0.0);
         let flow_offset = axis.flow_offset(track_start, track_size, node_block_size);
         let mut start = abs_start + flow_offset;
@@ -6920,16 +7033,20 @@ mod tests {
     second_style.break_before = BreakBetween::Left;
     let second_style = Arc::new(second_style);
 
+    let mut first =
+      FragmentNode::new_block_styled(Rect::from_xywh(0.0, 0.0, 100.0, 60.0), vec![], first_style);
+    first.content = FragmentContent::Block { box_id: Some(1) };
+
+    let mut second = FragmentNode::new_block_styled(
+      Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
+      vec![],
+      second_style,
+    );
+    second.content = FragmentContent::Block { box_id: Some(2) };
+
     let mut grid = FragmentNode::new_block_styled(
       Rect::from_xywh(0.0, 0.0, 100.0, 120.0),
-      vec![
-        FragmentNode::new_block_styled(Rect::from_xywh(0.0, 0.0, 100.0, 60.0), vec![], first_style),
-        FragmentNode::new_block_styled(
-          Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
-          vec![],
-          second_style,
-        ),
-      ],
+      vec![first, second],
       grid_style,
     );
     grid.grid_tracks = Some(Arc::new(GridTrackRanges {
@@ -7498,21 +7615,27 @@ mod tests {
     left_again_style.break_before = BreakBetween::Left;
     let left_again_style = Arc::new(left_again_style);
 
+    let mut left =
+      FragmentNode::new_block_styled(Rect::from_xywh(0.0, 0.0, 100.0, 60.0), vec![], left_style);
+    left.content = FragmentContent::Block { box_id: Some(1) };
+
+    let mut right = FragmentNode::new_block_styled(
+      Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
+      vec![],
+      right_style,
+    );
+    right.content = FragmentContent::Block { box_id: Some(2) };
+
+    let mut left_again = FragmentNode::new_block_styled(
+      Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
+      vec![],
+      left_again_style,
+    );
+    left_again.content = FragmentContent::Block { box_id: Some(3) };
+
     let mut grid = FragmentNode::new_block_styled(
       Rect::from_xywh(0.0, 0.0, 100.0, 120.0),
-      vec![
-        FragmentNode::new_block_styled(Rect::from_xywh(0.0, 0.0, 100.0, 60.0), vec![], left_style),
-        FragmentNode::new_block_styled(
-          Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
-          vec![],
-          right_style,
-        ),
-        FragmentNode::new_block_styled(
-          Rect::from_xywh(0.0, 60.0, 100.0, 60.0),
-          vec![],
-          left_again_style,
-        ),
-      ],
+      vec![left, right, left_again],
       grid_style,
     );
     grid.grid_tracks = Some(Arc::new(GridTrackRanges {
@@ -8839,7 +8962,9 @@ mod tests {
     let mut first = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 100.0, 10.0), vec![]);
     first.style = Some(break_style);
     let second = FragmentNode::new_block(Rect::from_xywh(0.0, 10.0, 100.0, 10.0), vec![]);
-    let item = FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 100.0, 20.0), vec![first, second]);
+    let mut item =
+      FragmentNode::new_block(Rect::from_xywh(0.0, 0.0, 100.0, 20.0), vec![first, second]);
+    item.content = FragmentContent::Block { box_id: Some(1) };
 
     let mut grid_style = ComputedStyle::default();
     grid_style.display = Display::Grid;
diff --git a/src/layout/tests/grid_calc_gap.rs b/src/layout/tests/grid_calc_gap.rs
index 48f77d5698..f112cdc62c 100644
--- a/src/layout/tests/grid_calc_gap.rs
+++ b/src/layout/tests/grid_calc_gap.rs
@@ -256,6 +256,8 @@ fn grid_calc_gap_percentages_use_inline_axis_in_vertical_writing_mode() {
   let mut parent_style = ComputedStyle::default();
   parent_style.display = Display::Grid;
   parent_style.writing_mode = WritingMode::VerticalRl;
+  parent_style.align_content = crate::style::types::AlignContent::Start;
+  parent_style.justify_content = crate::style::types::JustifyContent::Start;
   parent_style.grid_template_columns = vec![
     GridTrack::Length(Length::px(10.0)),
     GridTrack::Length(Length::px(10.0)),
diff --git a/src/layout/tests/grid_percent_gap.rs b/src/layout/tests/grid_percent_gap.rs
index e76edfd716..1d327b2c00 100644
--- a/src/layout/tests/grid_percent_gap.rs
+++ b/src/layout/tests/grid_percent_gap.rs
@@ -160,13 +160,33 @@ fn row_gap_percentage_uses_inline_size_in_vertical_writing_mode() {
 
   let mut child_style = ComputedStyle::default();
   child_style.display = Display::Block;
+  child_style.width = Some(Length::px(5.0));
+  child_style.height = Some(Length::px(5.0));
 
   let child1 = BoxNode::new_block(
-    Arc::new(child_style.clone()),
+    Arc::new({
+      let mut style = child_style.clone();
+      style.grid_row_start = 1;
+      style.grid_row_end = 2;
+      style.grid_column_start = 1;
+      style.grid_column_end = 2;
+      style
+    }),
+    FormattingContextType::Block,
+    vec![],
+  );
+  let child2 = BoxNode::new_block(
+    Arc::new({
+      let mut style = child_style;
+      style.grid_row_start = 2;
+      style.grid_row_end = 3;
+      style.grid_column_start = 1;
+      style.grid_column_end = 2;
+      style
+    }),
     FormattingContextType::Block,
     vec![],
   );
-  let child2 = BoxNode::new_block(Arc::new(child_style), FormattingContextType::Block, vec![]);
 
   let subgrid = BoxNode::new_block(
     Arc::new(subgrid_style),
diff --git a/src/layout_engine/layout/contexts/grid.rs b/src/layout_engine/layout/contexts/grid.rs
index 647ab17a84..9b3852f8e0 100644
--- a/src/layout_engine/layout/contexts/grid.rs
+++ b/src/layout_engine/layout/contexts/grid.rs
@@ -4718,6 +4718,8 @@ mod tests {
     // Use a vertical writing mode where the block axis runs right-to-left, so row offsets can be
     // asserted in physical coordinates relative to the right edge.
     container_style.writing_mode = WritingMode::VerticalRl;
+    container_style.align_content = crate::style::types::AlignContent::Start;
+    container_style.justify_content = crate::style::types::JustifyContent::Start;
     container_style.width = Some(Length::px(100.0));
     container_style.height = Some(Length::px(200.0));
     container_style.align_content = AlignContent::Start;
diff --git a/src/layout_minimal/constraints.rs b/src/layout_minimal/constraints.rs
index e6a12299a9..d071e53449 100644
--- a/src/layout_minimal/constraints.rs
+++ b/src/layout_minimal/constraints.rs
@@ -30,13 +30,18 @@ impl AvailableSpace {
 pub struct LayoutConstraints {
   pub available_width: AvailableSpace,
   pub available_height: AvailableSpace,
+  pub inline_percentage_base: Option<f32>,
+  pub block_percentage_base: Option<f32>,
 }
 
 impl LayoutConstraints {
   pub fn new(available_width: AvailableSpace, available_height: AvailableSpace) -> Self {
+    let inline_percentage_base = available_width.to_definite();
     Self {
       available_width,
       available_height,
+      inline_percentage_base,
+      block_percentage_base: None,
     }
   }
 
@@ -55,11 +60,13 @@ impl LayoutConstraints {
     )
   }
 
-  pub fn with_block_percentage_base(self, _base: Option<f32>) -> Self {
+  pub fn with_block_percentage_base(mut self, base: Option<f32>) -> Self {
+    self.block_percentage_base = base;
     self
   }
 
-  pub fn with_inline_percentage_base(self, _base: Option<f32>) -> Self {
+  pub fn with_inline_percentage_base(mut self, base: Option<f32>) -> Self {
+    self.inline_percentage_base = base;
     self
   }
 }
diff --git a/src/layout_minimal/contexts/block.rs b/src/layout_minimal/contexts/block.rs
index 89a75b40b1..7096042b6b 100644
--- a/src/layout_minimal/contexts/block.rs
+++ b/src/layout_minimal/contexts/block.rs
@@ -1,4 +1,6 @@
 use crate::layout::constraints::LayoutConstraints;
+use crate::layout::formatting_context::set_percentage_base_hint;
+use crate::layout::axis::{FragmentAxes, PhysicalAxis};
 use crate::layout::engine::{LayoutConfig, LayoutEngine, LayoutParallelism};
 use crate::layout::formatting_context::{FormattingContext, LayoutError};
 use crate::tree::box_tree::{BoxNode, BoxTree};
@@ -23,6 +25,21 @@ impl BlockFormattingContext {
 
   pub fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints) -> Result<FragmentNode, LayoutError> {
     let _ = self.parallelism;
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let width_base = if axes.inline_axis() == PhysicalAxis::X {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_width.to_definite());
+    let height_base = if axes.inline_axis() == PhysicalAxis::Y {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_height.to_definite());
+    let _percentage_base_guard = set_percentage_base_hint(width_base, height_base);
     let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree).map(|tree| tree.root)
diff --git a/src/layout_minimal/contexts/flex.rs b/src/layout_minimal/contexts/flex.rs
index 49d88080c0..8f40168f3f 100644
--- a/src/layout_minimal/contexts/flex.rs
+++ b/src/layout_minimal/contexts/flex.rs
@@ -16,8 +16,9 @@ pub mod baseline;
 pub mod gap;
 
 use crate::layout::constraints::LayoutConstraints;
+use crate::layout::axis::{FragmentAxes, PhysicalAxis};
 use crate::layout::engine::{LayoutConfig, LayoutEngine, LayoutParallelism};
-use crate::layout::formatting_context::{FormattingContext, LayoutError};
+use crate::layout::formatting_context::{set_percentage_base_hint, FormattingContext, LayoutError};
 use crate::tree::box_tree::{BoxNode, BoxTree};
 use crate::tree::fragment_tree::FragmentNode;
 
@@ -44,6 +45,21 @@ impl FlexFormattingContext {
 
   pub fn layout(&self, box_node: &BoxNode, constraints: &LayoutConstraints) -> Result<FragmentNode, LayoutError> {
     let _ = self.parallelism;
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let width_base = if axes.inline_axis() == PhysicalAxis::X {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_width.to_definite());
+    let height_base = if axes.inline_axis() == PhysicalAxis::Y {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_height.to_definite());
+    let _percentage_base_guard = set_percentage_base_hint(width_base, height_base);
     let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree).map(|tree| tree.root)
diff --git a/src/layout_minimal/contexts/grid.rs b/src/layout_minimal/contexts/grid.rs
index cbe0a11420..95116769a2 100644
--- a/src/layout_minimal/contexts/grid.rs
+++ b/src/layout_minimal/contexts/grid.rs
@@ -10,7 +10,9 @@ use crate::geometry::Point;
 use crate::layout::axis::{FragmentAxes, PhysicalAxis};
 use crate::layout::constraints::{AvailableSpace, LayoutConstraints};
 use crate::layout::engine::{LayoutConfig, LayoutEngine, LayoutParallelism};
-use crate::layout::formatting_context::{FormattingContext, IntrinsicSizingMode, LayoutError};
+use crate::layout::formatting_context::{
+  set_percentage_base_hint, FormattingContext, IntrinsicSizingMode, LayoutError,
+};
 use crate::style::types::GridTrack;
 use crate::tree::box_tree::{BoxNode, BoxTree};
 use crate::tree::fragment_tree::{FragmentNode, FragmentTree};
@@ -39,6 +41,21 @@ impl GridFormattingContext {
     constraints: &LayoutConstraints,
   ) -> Result<FragmentTree, LayoutError> {
     let _ = self.parallelism;
+    let style = box_node.style.as_ref();
+    let axes = FragmentAxes::from_writing_mode_and_direction(style.writing_mode, style.direction);
+    let width_base = if axes.inline_axis() == PhysicalAxis::X {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_width.to_definite());
+    let height_base = if axes.inline_axis() == PhysicalAxis::Y {
+      constraints.inline_percentage_base
+    } else {
+      constraints.block_percentage_base
+    }
+    .or_else(|| constraints.available_height.to_definite());
+    let _percentage_base_guard = set_percentage_base_hint(width_base, height_base);
     let engine = LayoutEngine::new(LayoutConfig::new(constraints.available_size()));
     let tree = BoxTree::new(box_node.clone());
     engine.layout_tree(&tree)
diff --git a/src/layout_minimal/engine.rs b/src/layout_minimal/engine.rs
index c5d3942ccd..0e0dd96396 100644
--- a/src/layout_minimal/engine.rs
+++ b/src/layout_minimal/engine.rs
@@ -16,7 +16,7 @@ use crate::layout::fragmentation::{
 use crate::layout::formatting_context::{
   fragmentainer_axes_hint, fragmentainer_block_offset_hint, fragmentainer_block_size_hint,
   set_fragmentainer_axes_hint, set_fragmentainer_block_offset_hint, set_fragmentainer_block_size_hint,
-  set_viewport_size_hint, viewport_size_hint, LayoutError,
+  percentage_base_hint, set_viewport_size_hint, viewport_size_hint, LayoutError,
 };
 use crate::style::display::FormattingContextType;
 use crate::style::page::PageSide;
@@ -371,6 +371,13 @@ fn resolve_length(
     .unwrap_or(fallback)
 }
 
+fn percentage_base_for_physical_axis(axis: PhysicalAxis, fallback: f32) -> Option<f32> {
+  if fallback.is_finite() {
+    return Some(fallback);
+  }
+  percentage_base_hint(axis)
+}
+
 fn resolve_margin(
   value: Option<crate::style::values::Length>,
   percentage_base: f32,
@@ -560,7 +567,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   let mut width = resolve_length(
     style.width,
     available.width,
-    Some(available.width),
+    percentage_base_for_physical_axis(PhysicalAxis::X, available.width),
     style.font_size,
     style.root_font_size,
   );
@@ -629,7 +636,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
     let mut height = resolve_length(
       style.height,
       max_inline_end,
-      Some(available.height),
+      percentage_base_for_physical_axis(PhysicalAxis::Y, available.height),
       style.font_size,
       style.root_font_size,
     );
@@ -688,7 +695,7 @@ fn layout_block(node: &BoxNode, available: Size, context: LayoutBoxContext) -> F
   let mut height = resolve_length(
     style.height,
     cursor_y,
-    Some(available.height),
+    percentage_base_for_physical_axis(PhysicalAxis::Y, available.height),
     style.font_size,
     style.root_font_size,
   );
@@ -711,7 +718,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
     resolve_length(
       style.height,
       available.height,
-      Some(available.height),
+      percentage_base_for_physical_axis(PhysicalAxis::Y, available.height),
       style.font_size,
       style.root_font_size,
     )
@@ -727,7 +734,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
     resolve_length(
       style.height,
       available.height,
-      Some(available.height),
+      percentage_base_for_physical_axis(PhysicalAxis::Y, available.height),
       style.font_size,
       style.root_font_size,
     )
@@ -955,7 +962,7 @@ fn layout_multicol_block(node: &BoxNode, available: Size, width: f32) -> Fragmen
   let mut height = resolve_length(
     style.height,
     default_height,
-    Some(available.height),
+    percentage_base_for_physical_axis(PhysicalAxis::Y, available.height),
     style.font_size,
     style.root_font_size,
   );
@@ -1597,16 +1604,19 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     (track_inline_sum, track_block_sum)
   };
 
+  let width_percentage_base = percentage_base_for_physical_axis(PhysicalAxis::X, available.width);
+  let height_percentage_base = percentage_base_for_physical_axis(PhysicalAxis::Y, available.height);
+
   let mut width = style
     .width
     .and_then(|length| {
-      length.resolve_px_with_fonts(Some(available.width), style.font_size, style.root_font_size)
+      length.resolve_px_with_fonts(width_percentage_base, style.font_size, style.root_font_size)
     })
     .unwrap_or_else(|| if track_width > 0.0 { track_width } else { available.width });
   let mut height = style
     .height
     .and_then(|length| {
-      length.resolve_px_with_fonts(Some(available.height), style.font_size, style.root_font_size)
+      length.resolve_px_with_fonts(height_percentage_base, style.font_size, style.root_font_size)
     })
     .unwrap_or_else(|| if track_height > 0.0 { track_height } else { 0.0 });
 
@@ -1803,13 +1813,40 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
 
   let stretch_block = matches!(style.align_items, AlignItems::Stretch);
 
-  let track_block_sum: f32 = row_sizes.iter().sum();
-  let track_inline_sum: f32 = column_sizes.iter().sum();
+  // CSS Box Alignment: `row-gap`/`column-gap` consume space just like tracks and must be accounted
+  // for when distributing free space via `align-content`/`justify-content`.
+  //
+  // Percentages in grid gaps resolve against the container's inline size for both axes.
+  let gap_base = if container_inline_size.is_finite() {
+    container_inline_size.max(0.0)
+  } else {
+    0.0
+  };
+  let row_gap = if style.grid_row_gap_is_normal {
+    0.0
+  } else {
+    resolve_track_length(style.grid_row_gap, gap_base)
+  };
+  let row_gap = if row_gap.is_finite() { row_gap.max(0.0) } else { 0.0 };
+  let column_gap = if style.grid_column_gap_is_normal {
+    0.0
+  } else {
+    resolve_track_length(style.grid_column_gap, gap_base)
+  };
+  let column_gap = if column_gap.is_finite() { column_gap.max(0.0) } else { 0.0 };
+
+  let total_row_gap = row_gap * (row_count.saturating_sub(1) as f32);
+  let total_column_gap = column_gap * (column_count.saturating_sub(1) as f32);
+
+  let track_block_sum: f32 = row_sizes.iter().sum::<f32>() + total_row_gap;
+  let track_inline_sum: f32 = column_sizes.iter().sum::<f32>() + total_column_gap;
   let mut block_free = (container_block_size - track_block_sum).max(0.0);
   let inline_free = (container_inline_size - track_inline_sum).max(0.0);
 
   // `align-content: stretch` distributes any remaining free space across the grid tracks. The
-  // minimal layout harness only needs the simplest behavior: grow each row equally.
+  // minimal layout harness only needs enough to keep track ranges consistent with the production
+  // grid: distribute free space across `auto` tracks only. Fixed-length tracks (including explicit
+  // 0px tracks) must remain unchanged so grid line numbering stays stable.
   if matches!(style.align_content, AlignContent::Stretch)
     && container_block_size.is_finite()
     && track_block_sum.is_finite()
@@ -1817,11 +1854,24 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     && row_count > 0
     && block_free > 0.0
   {
-    let extra = block_free / row_count as f32;
-    for size in row_sizes.iter_mut() {
-      *size += extra;
+    let explicit_auto = row_tracks
+      .iter()
+      .filter(|track| matches!(track, GridTrack::Auto))
+      .count();
+    let implicit_auto = row_count.saturating_sub(row_tracks.len());
+    let auto_count = explicit_auto + implicit_auto;
+    if auto_count > 0 {
+      let extra = block_free / auto_count as f32;
+      for (idx, size) in row_sizes.iter_mut().enumerate() {
+        let is_auto = row_tracks
+          .get(idx)
+          .is_none_or(|track| matches!(track, GridTrack::Auto));
+        if is_auto {
+          *size += extra;
+        }
+      }
+      block_free = 0.0;
     }
-    block_free = 0.0;
   }
   let block_offset = match style.align_content {
     AlignContent::Center => block_free / 2.0,
@@ -1830,21 +1880,34 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
   };
   let inline_offset = match style.justify_content {
     JustifyContent::Center => inline_free / 2.0,
-    JustifyContent::FlexEnd => inline_free,
-    JustifyContent::FlexStart | JustifyContent::Start => 0.0,
+    JustifyContent::FlexEnd | JustifyContent::End => inline_free,
+    JustifyContent::FlexStart | JustifyContent::Start | JustifyContent::Normal => 0.0,
+    // The minimal grid harness does not implement `justify-content: space-*` distribution or
+    // `stretch` for track sizing. Treat them like `start` so tests that exercise the enum surface
+    // keep a deterministic layout.
+    JustifyContent::Stretch
+    | JustifyContent::SpaceBetween
+    | JustifyContent::SpaceAround
+    | JustifyContent::SpaceEvenly => 0.0,
   };
 
   let mut row_edges: Vec<f32> = Vec::with_capacity(row_count + 1);
   row_edges.push(block_offset);
-  for size in row_sizes.iter().copied() {
-    let next = row_edges.last().copied().unwrap_or(block_offset) + size;
+  for (idx, size) in row_sizes.iter().copied().enumerate() {
+    let mut next = row_edges.last().copied().unwrap_or(block_offset) + size;
+    if idx + 1 < row_count {
+      next += row_gap;
+    }
     row_edges.push(next);
   }
 
   let mut column_edges: Vec<f32> = Vec::with_capacity(column_count + 1);
   column_edges.push(inline_offset);
-  for size in column_sizes.iter().copied() {
-    let next = column_edges.last().copied().unwrap_or(inline_offset) + size;
+  for (idx, size) in column_sizes.iter().copied().enumerate() {
+    let mut next = column_edges.last().copied().unwrap_or(inline_offset) + size;
+    if idx + 1 < column_count {
+      next += column_gap;
+    }
     column_edges.push(next);
   }
 
@@ -1869,17 +1932,23 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
   }
 
   let mut row_ranges = Vec::with_capacity(row_count);
-  for window in row_edges.windows(2) {
+  for (idx, window) in row_edges.windows(2).enumerate() {
     let start = window[0];
-    let end = window[1];
+    let mut end = window[1];
+    if idx + 2 < row_edges.len() {
+      end = (end - row_gap).max(start);
+    }
     if start.is_finite() && end.is_finite() && end >= start {
       row_ranges.push((start, end));
     }
   }
   let mut col_ranges = Vec::with_capacity(column_count);
-  for window in column_edges.windows(2) {
+  for (idx, window) in column_edges.windows(2).enumerate() {
     let start = window[0];
-    let end = window[1];
+    let mut end = window[1];
+    if idx + 2 < column_edges.len() {
+      end = (end - column_gap).max(start);
+    }
     if start.is_finite() && end.is_finite() && end >= start {
       col_ranges.push((start, end));
     }
@@ -1896,6 +1965,28 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
     (col_ranges, row_ranges)
   };
 
+  fn grid_area_for_positioned_item(
+    line_positions: &[f32],
+    gap: f32,
+    start_line: u16,
+    end_line: u16,
+  ) -> Option<(f32, f32)> {
+    if line_positions.is_empty() {
+      return None;
+    }
+    let gap = gap.max(0.0);
+    let last_index = line_positions.len().saturating_sub(1);
+    let start_index = usize::from(start_line.saturating_sub(1)).min(last_index);
+    let end_index = usize::from(end_line.saturating_sub(1)).min(last_index);
+
+    let start = line_positions[start_index];
+    let mut end = line_positions[end_index];
+    if end_index < last_index {
+      end = (end - gap).max(start);
+    }
+    Some((start, end))
+  }
+
   let mut children: Vec<FragmentNode> = Vec::new();
   for (idx, child) in node.children.iter().enumerate() {
     let placement = placements_by_id.get(&child.id).copied();
@@ -1920,20 +2011,17 @@ fn layout_grid(node: &BoxNode, available: Size) -> FragmentNode {
       )
     };
 
-    let row_start_edge = row_start.saturating_sub(1) as usize;
-    let col_start_edge = col_start.saturating_sub(1) as usize;
-    let row_end_edge = row_end.saturating_sub(1) as usize;
-    let col_end_edge = col_end.saturating_sub(1) as usize;
-
-    let Some(&block_start) = row_edges.get(row_start_edge) else {
-      continue;
-    };
-    let Some(&inline_start) = column_edges.get(col_start_edge) else {
-      continue;
-    };
+    let (block_start, block_end) =
+      match grid_area_for_positioned_item(&row_edges, row_gap, row_start, row_end) {
+        Some(area) => area,
+        None => continue,
+      };
+    let (inline_start, inline_end) =
+      match grid_area_for_positioned_item(&column_edges, column_gap, col_start, col_end) {
+        Some(area) => area,
+        None => continue,
+      };
 
-    let block_end = row_edges.get(row_end_edge).copied().unwrap_or(block_start);
-    let inline_end = column_edges.get(col_end_edge).copied().unwrap_or(inline_start);
     let cell_block = (block_end - block_start).max(0.0);
     let cell_inline = (inline_end - inline_start).max(0.0);
 
@@ -2125,13 +2213,12 @@ fn layout_flex(node: &BoxNode, available: Size) -> FragmentNode {
   let container_width = resolve_length(
     style.width,
     available.width,
-    Some(available.width),
+    percentage_base_for_physical_axis(PhysicalAxis::X, available.width),
     style.font_size,
     style.root_font_size,
   );
   let mut container_height = style.height.and_then(|height| {
-    let base = available.height;
-    let base = base.is_finite().then_some(base);
+    let base = percentage_base_for_physical_axis(PhysicalAxis::Y, available.height);
     height.resolve_px_with_fonts(base, style.font_size, style.root_font_size)
   });
 
diff --git a/src/layout_minimal/formatting_context.rs b/src/layout_minimal/formatting_context.rs
index c56bcebf73..6c8647c62b 100644
--- a/src/layout_minimal/formatting_context.rs
+++ b/src/layout_minimal/formatting_context.rs
@@ -157,6 +157,48 @@ thread_local! {
   static FRAGMENTAINER_BLOCK_SIZE_HINT: Cell<Option<f32>> = Cell::new(None);
   static FRAGMENTAINER_BLOCK_OFFSET_HINT: Cell<f32> = Cell::new(0.0);
   static FRAGMENTAINER_AXES_HINT: Cell<Option<FragmentAxes>> = Cell::new(None);
+  static CONTAINING_BLOCK_PERCENTAGE_BASE_HINT: Cell<PercentageBaseHint> =
+    Cell::new(PercentageBaseHint { width: None, height: None });
+}
+
+#[derive(Debug, Clone, Copy, Default)]
+pub(crate) struct PercentageBaseHint {
+  width: Option<f32>,
+  height: Option<f32>,
+}
+
+pub(crate) struct PercentageBaseHintGuard {
+  previous: PercentageBaseHint,
+}
+
+impl Drop for PercentageBaseHintGuard {
+  fn drop(&mut self) {
+    CONTAINING_BLOCK_PERCENTAGE_BASE_HINT.with(|hint| {
+      hint.set(self.previous);
+    });
+  }
+}
+
+pub(crate) fn percentage_base_hint(axis: PhysicalAxis) -> Option<f32> {
+  CONTAINING_BLOCK_PERCENTAGE_BASE_HINT.with(|hint| {
+    let bases = hint.get();
+    match axis {
+      PhysicalAxis::X => bases.width,
+      PhysicalAxis::Y => bases.height,
+    }
+  })
+}
+
+pub(crate) fn set_percentage_base_hint(width: Option<f32>, height: Option<f32>) -> PercentageBaseHintGuard {
+  let width = width.filter(|base| base.is_finite()).map(|base| base.max(0.0));
+  let height = height.filter(|base| base.is_finite()).map(|base| base.max(0.0));
+  let new = PercentageBaseHint { width, height };
+  let previous = CONTAINING_BLOCK_PERCENTAGE_BASE_HINT.with(|cell| {
+    let previous = cell.get();
+    cell.set(new);
+    previous
+  });
+  PercentageBaseHintGuard { previous }
 }
 
 pub(crate) struct ViewportSizeHintGuard {
diff --git a/src/net/websocket/mod.rs b/src/net/websocket/mod.rs
index eba98b30e1..bb18e9a5cb 100644
--- a/src/net/websocket/mod.rs
+++ b/src/net/websocket/mod.rs
@@ -16,12 +16,10 @@ pub mod http_response_head;
 pub mod http_headers;
 pub mod maybe_tls_stream;
 pub mod message;
-pub mod maybe_tls_stream;
 pub mod ws_url;
 pub mod origin;
 pub mod server;
 pub mod stream;
-mod maybe_tls_stream;
 
 // Async helpers are gated separately so snapshot builds can opt out of Tokio entirely. Keep them
 // behind a dedicated feature so the layout-only workspace snapshot can build the blocking WebSocket
@@ -49,6 +47,7 @@ pub use message::{
   decode_close_payload, encode_close_payload, Message, MessageCodec, MessageDecodeError,
   MessageEncodeError, MessageLimits, MAX_CLOSE_REASON_BYTES,
 };
+pub use maybe_tls_stream::MaybeTlsStream;
 pub use origin::{is_secure_context_for_document_url, serialized_origin_for_document_url};
 pub use stream::{WebSocketStream, WebSocketStreamError, WsMessage};
 
diff --git a/src/net/websocket/stream.rs b/src/net/websocket/stream.rs
index 209e6b06c2..2894d1d9cf 100644
--- a/src/net/websocket/stream.rs
+++ b/src/net/websocket/stream.rs
@@ -19,6 +19,7 @@ use super::frame::close_code;
 use super::{
   FrameCodec, FrameDecodeError, FrameEncodeError, FrameLimits, OpCode, Role, MAX_CLOSE_REASON_BYTES,
 };
+pub use super::maybe_tls_stream::MaybeTlsStream;
 
 /// High-level WebSocket message/control event.
 #[derive(Debug, Clone, PartialEq, Eq)]
diff --git a/src/platform/macos/scroll_end.rs b/src/platform/macos/scroll_end.rs
index 34efe5da6b..6872171cba 100644
--- a/src/platform/macos/scroll_end.rs
+++ b/src/platform/macos/scroll_end.rs
@@ -31,13 +31,13 @@ impl PendingScrollEnd {
     self.pending = None;
   }
 
-  #[cfg(all(test, target_os = "macos"))]
+  #[cfg(test)]
   fn is_pending(&self) -> bool {
     self.pending.is_some()
   }
 }
 
-#[cfg(all(test, target_os = "macos"))]
+#[cfg(test)]
 mod tests {
   use super::PendingScrollEnd;
   use crate::geometry::Point;
diff --git a/src/utils/js_escapes.rs b/src/utils/js_escapes.rs
index cc5dc49753..d2548184e5 100644
--- a/src/utils/js_escapes.rs
+++ b/src/utils/js_escapes.rs
@@ -129,11 +129,25 @@ pub(crate) fn unescape_js_escapes(input: &str) -> Cow<'_, str> {
                           i += 12;
                           continue;
                         }
+                      } else {
+                        // JS strings allow unpaired surrogates, but Rust strings cannot represent
+                        // them. Preserve both escapes verbatim so callers can round-trip the
+                        // original JS code units.
+                        out.push_str(&input[i..i + 12]);
+                        i += 12;
+                        continue;
                       }
                     }
                   }
                 }
 
+                if (0xD800..=0xDFFF).contains(&code) {
+                  // Preserve lone surrogate code units.
+                  out.push_str(&input[i..i + 6]);
+                  i += 6;
+                  continue;
+                }
+
                 if let Some(ch) = char::from_u32(code as u32) {
                   out.push(ch);
                   i += 6;
-- 
2.43.0

