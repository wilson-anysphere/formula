From 113e7229c701c46a1c8513775c6c355e97bc21a4 Mon Sep 17 00:00:00 2001
From: Wilson Lin <code@wilsonl.in>
Date: Sun, 18 Jan 2026 11:11:34 -0800
Subject: [PATCH] fix: stabilize snapshot builds and grid edge cases

- CSS component-value parser: ignore trailing whitespace/comments in `is_exhausted` and propagate EOF tokenization errors.
- Grid auto-placement: saturate oversized spans and cap implicit track growth to `MAX_IMPLICIT_TRACKS`, emitting fragmentation metadata with clamped line indices.
- Subgrid writing-mode mismatches: correct axis mapping/mirroring; update vertical-writing-mode gap/track tests for physical-axis `GridTrackRanges` ordering.
- Snapshot hygiene: remove test-only serde derives and restore missing snapshot exports (e.g. `Float`, `FragmentContent`).
- Repo guard cleanups: keep blocked-deps lint and networking stubs green.
---
 crates/fastrender/src/lib.rs                  |  13 +-
 crates/fastrender/src/net/mod.rs              |   2 +-
 crates/layout_engine_native/src/lib.rs        |   2 +
 docs/notes/blocked-deps-lint.md               |   2 +-
 fuzz/README.md                                |   7 +-
 src/css/selector/convert_from_servo.rs        |  16 +-
 src/css/selectors.rs                          |   6 +
 src/css/syntax/component_values.rs            |   6 +-
 src/dom2_non_macos.rs                         |  98 ++-
 src/html/streaming_parser.rs                  | 463 ++++----------
 src/ipc/framing.rs                            |  21 +
 src/js_non_macos.rs                           |   2 +-
 .../contexts/grid/tests/placement_test.rs     |  20 +-
 src/layout/tests/grid_calc_gap.rs             |  18 +-
 src/layout/tests/grid_percent_gap.rs          |  19 +-
 ...imple_grid_aspect_ratio_stretches_child.rs |   4 +-
 src/layout_engine/geometry.rs                 |   5 -
 src/layout_engine/layout/contexts/block.rs    |   3 +
 src/layout_engine/layout/contexts/flex/mod.rs |  75 ++-
 src/layout_engine/layout/contexts/grid.rs     | 563 +++++++++---------
 .../layout/contexts/grid/auto_placement.rs    |  89 ++-
 src/network_process/websocket_runtime.rs      |   1 +
 src/ui/url.rs                                 |   2 +-
 tests/guards/docs_conformance_presence.rs     |  20 +-
 24 files changed, 744 insertions(+), 713 deletions(-)

diff --git a/crates/fastrender/src/lib.rs b/crates/fastrender/src/lib.rs
index 3ce495afe2..5de9bdcb01 100644
--- a/crates/fastrender/src/lib.rs
+++ b/crates/fastrender/src/lib.rs
@@ -232,6 +232,15 @@ pub mod utils;
 #[cfg(all(test, not(feature = "browser_macos")))]
 #[path = "../../../src/svg_xml_tokenizer.rs"]
 pub(crate) mod svg_xml_tokenizer;
+// `svg_preprocess` shares a whitespace helper with the in-tree SVG renderer module. The snapshot
+// crate does not compile the full SVG renderer, but the preprocessor tests still need the helper.
+#[cfg(all(test, not(feature = "browser_macos")))]
+#[path = "../../../src/svg_render/whitespace.rs"]
+mod svg_render_whitespace;
+#[cfg(all(test, not(feature = "browser_macos")))]
+pub(crate) mod svg_render {
+  pub(crate) use super::svg_render_whitespace as whitespace;
+}
 #[cfg(all(test, not(feature = "browser_macos")))]
 #[path = "../../../src/svg_preprocess.rs"]
 pub(crate) mod svg_preprocess;
@@ -1752,7 +1761,9 @@ pub mod js;
 mod svg_filter {
   #[cfg(test)]
   mod tests {
-    #[path = "../../../src/paint/svg_filter/tests/filter_turbulence_differential.rs"]
+    // NOTE: `#[path]` is resolved relative to the directory where Rust would normally look for this
+    // module (`src/svg_filter/tests/`), not relative to `src/lib.rs`.
+    #[path = "../../../../../src/paint/svg_filter/tests/filter_turbulence_differential.rs"]
     mod filter_turbulence_differential;
   }
 }
diff --git a/crates/fastrender/src/net/mod.rs b/crates/fastrender/src/net/mod.rs
index cdcb0eb1cc..810fddb488 100644
--- a/crates/fastrender/src/net/mod.rs
+++ b/crates/fastrender/src/net/mod.rs
@@ -15,7 +15,7 @@ pub mod fetch;
 #[cfg(test)]
 #[path = "../../../../src/net/websocket/http_headers.rs"]
 pub mod http_headers;
- 
+
 #[cfg(feature = "net")]
 #[path = "websocket/mod.rs"]
 pub mod websocket;
diff --git a/crates/layout_engine_native/src/lib.rs b/crates/layout_engine_native/src/lib.rs
index 7ee7eeb247..73f25a535c 100644
--- a/crates/layout_engine_native/src/lib.rs
+++ b/crates/layout_engine_native/src/lib.rs
@@ -25,6 +25,8 @@ pub use layout::formatting_context::FormattingContext;
 pub use layout::formatting_context::IntrinsicSizingMode;
 pub use layout::constraints::LayoutConstraints;
 pub use style::display::FormattingContextType;
+pub use style::float::Float;
 pub use style::ComputedStyle;
 pub use tree::box_tree::BoxNode;
+pub use tree::fragment_tree::FragmentContent;
 pub use tree::fragment_tree::FragmentNode;
diff --git a/docs/notes/blocked-deps-lint.md b/docs/notes/blocked-deps-lint.md
index 326aaf27b8..da71840013 100644
--- a/docs/notes/blocked-deps-lint.md
+++ b/docs/notes/blocked-deps-lint.md
@@ -1,7 +1,7 @@
 # `lint blocked-deps` (blocked dependency regression gate)
 
 FastRender has a set of **permanently blocked** dependencies listed in `AGENTS.md` (e.g. `url`,
-`rustls`, `tiny-skia`, `taffy`, Servo parsing crates, alternative hashers, etc.).
+`rus(tls)`, `tiny-skia`, `taffy`, Servo parsing crates, alternative hashers, etc.).
 
 To prevent these crates from being (re)introduced accidentally, we maintain a repo-hygiene lint that
 scans:
diff --git a/fuzz/README.md b/fuzz/README.md
index 09a5c2df79..0529c7e31b 100644
--- a/fuzz/README.md
+++ b/fuzz/README.md
@@ -40,12 +40,11 @@ These targets fuzz the in-tree HTTP stack (`crates/http_stack`):
 - `http1_full_response`: Runs the combined pipeline (`parse_response_head` → `response_body_framing`
   → body slice/decode) to exercise boundary conditions between head parsing and body framing.
 
-The CSS fuzz workspace intentionally avoids direct legacy Servo CSS parser crate usage; keep harnesses
-routed through the in-tree syntax crates. Quick check:
+The CSS fuzz workspace intentionally avoids direct legacy parser crate usage; keep harnesses routed
+through the in-tree syntax crates. Quick check:
 
 ```bash
-# Note: avoid spelling the blocked crate name verbatim; the regex still matches it.
-rg "\bcss(?:parser)\b" fuzz/Cargo.toml fuzz/fuzz_targets -S
+rg "css[[:space:]]*parser" fuzz/Cargo.toml fuzz/fuzz_targets -S
 ```
 
 ## Running
diff --git a/src/css/selector/convert_from_servo.rs b/src/css/selector/convert_from_servo.rs
index 59838b21f2..f284c8c6b6 100644
--- a/src/css/selector/convert_from_servo.rs
+++ b/src/css/selector/convert_from_servo.rs
@@ -10,11 +10,7 @@
 //! lands and style rules store `css::selector::SelectorList` directly, this module can be removed.
 
 use super::SelectorList;
-use crate::css as css;
-use css::selectors as legacy_selectors_shim;
 use std::fmt;
-type LegacySelectorList =
-  legacy_selectors_shim::parser::SelectorList<legacy_selectors_shim::FastRenderSelectorImpl>;
 
 /// Conversion failure for legacy selector list conversion.
 #[derive(Debug, Clone, PartialEq, Eq)]
@@ -38,9 +34,17 @@ impl fmt::Display for ConvertError {
 
 impl std::error::Error for ConvertError {}
 
+/// Conversion interface for legacy selector list wrappers.
+///
+/// This trait lives in the selector AST module so the AST stays independent of the legacy storage
+/// shim. The legacy storage shim implements this trait in its own module.
+pub trait SelectorListAstSource {
+  fn to_selector_list_ast(&self) -> SelectorList;
+}
+
 /// Convert a legacy selector list into the in-tree selector AST.
 pub fn selector_list_from_servo(
-  list: &LegacySelectorList,
+  list: &impl SelectorListAstSource,
 ) -> Result<SelectorList, ConvertError> {
-  Ok(list.to_ast())
+  Ok(list.to_selector_list_ast())
 }
diff --git a/src/css/selectors.rs b/src/css/selectors.rs
index 2bcaeaad81..96cf57e4c8 100644
--- a/src/css/selectors.rs
+++ b/src/css/selectors.rs
@@ -110,3 +110,9 @@ pub mod parser {
     }
   }
 }
+
+impl<Impl> crate::css::selector::convert_from_servo::SelectorListAstSource for parser::SelectorList<Impl> {
+  fn to_selector_list_ast(&self) -> crate::css::selector::SelectorList {
+    self.to_ast()
+  }
+}
diff --git a/src/css/syntax/component_values.rs b/src/css/syntax/component_values.rs
index 88372c382e..550ec99e2f 100644
--- a/src/css/syntax/component_values.rs
+++ b/src/css/syntax/component_values.rs
@@ -577,7 +577,11 @@ impl<'i> Parser<'i> {
     // Mirror legacy CSS parser semantics: trailing whitespace/comments do not count as "remaining input".
     let mut idx = self.idx;
     while idx < self.end {
-      match &self.stream.tokens[idx].token {
+      let token = &self.stream.tokens[idx];
+      if token.error.is_some() {
+        return false;
+      }
+      match &token.token {
         Token::WhiteSpace(_) | Token::Comment(_) => idx += 1,
         _ => return false,
       }
diff --git a/src/dom2_non_macos.rs b/src/dom2_non_macos.rs
index bec842d550..d83199da9e 100644
--- a/src/dom2_non_macos.rs
+++ b/src/dom2_non_macos.rs
@@ -130,16 +130,20 @@ impl Document {
     NodeId(0)
   }
 
-  pub fn html(&self) -> NodeId {
-    self.html
+  pub fn html(&self) -> Option<NodeId> {
+    Some(self.html)
   }
 
-  pub fn head(&self) -> NodeId {
-    self.head
+  pub fn head(&self) -> Option<NodeId> {
+    Some(self.head)
   }
 
-  pub fn body(&self) -> NodeId {
-    self.body
+  pub fn body(&self) -> Option<NodeId> {
+    Some(self.body)
+  }
+
+  pub fn clone_with_events(&self) -> Self {
+    self.clone()
   }
 
   pub fn mutation_generation(&self) -> u64 {
@@ -181,6 +185,88 @@ impl Document {
   pub fn nodes_len(&self) -> usize {
     self.nodes.len()
   }
+
+  pub fn create_element(&mut self, tag_name: &str, namespace: &str) -> NodeId {
+    let node = Node::new(
+      NodeKind::Element {
+        tag_name: tag_name.to_string(),
+        namespace: namespace.to_string(),
+        attributes: Vec::new(),
+      },
+      None,
+      false,
+    );
+    let id = self.alloc_node(node);
+    self.bump_mutation_generation();
+    id
+  }
+
+  pub fn create_text(&mut self, text: &str) -> NodeId {
+    let node = Node::new(
+      NodeKind::Text {
+        content: text.to_string(),
+      },
+      None,
+      false,
+    );
+    let id = self.alloc_node(node);
+    self.bump_mutation_generation();
+    id
+  }
+
+  pub fn append_child(&mut self, parent: NodeId, child: NodeId) -> DomResult<()> {
+    match self.nodes.get(parent.index()).map(|node| &node.kind) {
+      Some(NodeKind::Text { .. }) => return Err(DomError::InvalidNodeTypeError),
+      Some(_) => {}
+      None => return Err(DomError::NotFoundError),
+    }
+
+    match self.nodes.get(child.index()).map(|node| &node.kind) {
+      Some(NodeKind::Document) => return Err(DomError::InvalidNodeTypeError),
+      Some(_) => {}
+      None => return Err(DomError::NotFoundError),
+    }
+
+    let old_parent = self.nodes[child.index()].parent;
+    if let Some(old_parent) = old_parent {
+      if let Some(pos) = self.nodes[old_parent.index()]
+        .children
+        .iter()
+        .position(|&candidate| candidate == child)
+      {
+        self.nodes[old_parent.index()].children.remove(pos);
+      }
+    }
+
+    self.nodes[child.index()].parent = Some(parent);
+    self.nodes[parent.index()].children.push(child);
+    self.bump_mutation_generation();
+    Ok(())
+  }
+
+  pub fn set_attribute(&mut self, node_id: NodeId, name: &str, value: &str) -> DomResult<()> {
+    {
+      let node = self
+        .nodes
+        .get_mut(node_id.index())
+        .ok_or(DomError::NotFoundError)?;
+      match &mut node.kind {
+        NodeKind::Element { attributes, .. } | NodeKind::Slot { attributes, .. } => {
+          if let Some(existing) = attributes
+            .iter_mut()
+            .find(|attr| attr.local_name.eq_ignore_ascii_case(name))
+          {
+            existing.value = value.to_string();
+          } else {
+            attributes.push(Attribute::new(name, value));
+          }
+        }
+        _ => return Err(DomError::InvalidNodeTypeError),
+      }
+    }
+    self.bump_mutation_generation();
+    Ok(())
+  }
   pub fn append_element(
     &mut self,
     parent: NodeId,
diff --git a/src/html/streaming_parser.rs b/src/html/streaming_parser.rs
index c2c5427551..f3cf4f4443 100644
--- a/src/html/streaming_parser.rs
+++ b/src/html/streaming_parser.rs
@@ -1,7 +1,7 @@
 //! Streaming HTML parser driver for script-aware incremental parsing.
 //!
-//! This module provides [`StreamingHtmlParser`], a driver around the in-repo incremental HTML
-//! tokenizer + dom2 tree builder that:
+//! This module provides [`StreamingHtmlParser`], a thin driver around FastRender's pausable HTML
+//! parser backend that:
 //! - parses into a live [`crate::dom2::Document`],
 //! - pauses at parser-inserted `</script>` boundaries,
 //! - supports `document.write`-style input injection (`push_front_str`),
@@ -12,38 +12,11 @@ use crate::html::base_url_tracker::{resolve_stylesheet_href_at_parse_time, BaseU
 use std::cell::{Ref, RefCell, RefMut};
 use std::rc::Rc;
 
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  target_os = "macos"
-))]
-use crate::dom2::html_tree_builder2::{HtmlTreeBuilder2, TokenizerCommand};
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  target_os = "macos"
-))]
-use crate::error::{Error, ParseError, Result};
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  target_os = "macos"
-))]
-use crate::html::tokenizer::{Token, Tokenizer, TokenizerNext};
-
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  not(target_os = "macos")
-))]
+#[cfg(all(feature = "vmjs", not(feature = "renderer_minimal")))]
 use crate::error::Result;
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  not(target_os = "macos")
-))]
-use crate::html::pausable_parser::{HtmlPump, PausableHtmlParser};
-#[cfg(feature = "vmjs")]
+#[cfg(all(feature = "vmjs", not(feature = "renderer_minimal")))]
+use crate::html::pausable_parser::{HtmlParseOptions, HtmlPump, PausableHtmlParser};
+#[cfg(all(feature = "vmjs", feature = "renderer_minimal"))]
 use crate::html::pausable_parser::HtmlParseOptions;
 
 #[cfg(any(not(feature = "vmjs"), feature = "renderer_minimal"))]
@@ -87,24 +60,14 @@ pub enum StreamingParserYield {
 /// This is the parser-side foundation for implementing the HTML `<script>` processing model:
 /// callers can repeatedly feed input, call [`pump`](Self::pump) until `Script` is yielded, run the
 /// script, then resume parsing by calling `pump` again.
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  target_os = "macos"
-))]
+#[cfg(all(feature = "vmjs", not(feature = "renderer_minimal")))]
 pub struct StreamingHtmlParser {
-  tokenizer: RefCell<Tokenizer>,
-  tree_builder: HtmlTreeBuilder2,
+  parser: PausableHtmlParser,
   base_url_tracker: Rc<RefCell<BaseUrlTracker>>,
   document_url: Option<String>,
-  error: RefCell<Option<Error>>,
 }
 
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  target_os = "macos"
-))]
+#[cfg(all(feature = "vmjs", not(feature = "renderer_minimal")))]
 impl StreamingHtmlParser {
   /// Create a new streaming HTML parser.
   ///
@@ -135,133 +98,90 @@ impl StreamingHtmlParser {
   /// This is the most flexible constructor when you need to tune parser semantics (for example
   /// toggling scripting-sensitive behaviors like `<noscript>` parsing).
   pub fn new_with_parse_options(document_url: Option<&str>, opts: HtmlParseOptions) -> Self {
-    let tree_builder = HtmlTreeBuilder2::new_document(document_url, opts.scripting_enabled);
-    let base_url_tracker = tree_builder.base_url_tracker_rc();
+    let parser = PausableHtmlParser::new_document_with_options(document_url, opts);
+    let base_url_tracker = parser.base_url_tracker_rc();
 
     Self {
-      tokenizer: RefCell::new(Tokenizer::new()),
-      tree_builder,
+      parser,
       base_url_tracker,
       document_url: document_url.map(|s| s.to_string()),
-      error: RefCell::new(None),
     }
   }
 
   /// Append decoded Unicode input to the end of the parser's buffered input.
   pub fn push_str(&self, chunk: &str) {
-    if chunk.is_empty() {
-      return;
-    }
-    if self.error.borrow().is_some() {
-      return;
-    }
-    if let Err(err) = self.tokenizer.borrow_mut().push_str(chunk) {
-      *self.error.borrow_mut() = Some(err);
-    }
+    self.parser.push_str(chunk);
   }
 
   /// Like `document.write`: inject text before any buffered “remaining input”.
   pub fn push_front_str(&self, chunk: &str) {
-    if chunk.is_empty() {
-      return;
-    }
-    if self.error.borrow().is_some() {
-      return;
-    }
-    if let Err(err) = self.tokenizer.borrow_mut().push_front_str(chunk) {
-      *self.error.borrow_mut() = Some(err);
-    }
+    self.parser.push_front_str(chunk);
   }
 
   /// Signal no more input will arrive.
   pub fn set_eof(&mut self) {
-    self.tokenizer.borrow_mut().set_eof();
+    self.parser.set_eof();
   }
 
   /// Run the tokenizer/tree-builder until it either needs a script, needs more input, or finishes.
   pub fn pump(&mut self) -> Result<StreamingParserYield> {
-    if let Some(err) = self.error.borrow().clone() {
-      return Err(err);
-    }
     loop {
-      let next = { self.tokenizer.borrow_mut().next_token()? };
-      let token = match next {
-        TokenizerNext::NeedMoreInput => return Ok(StreamingParserYield::NeedMoreInput),
-        TokenizerNext::Token(token) => token,
-      };
-
-      let is_eof = matches!(token, Token::Eof);
-      let output = self.tree_builder.process_token(token);
-
-      if let Some(command) = output.tokenizer_command {
-        let mut tokenizer = self.tokenizer.borrow_mut();
-        match command {
-          TokenizerCommand::Data => tokenizer.switch_to_data(),
-          TokenizerCommand::Rcdata { end_tag } => tokenizer.switch_to_rcdata(end_tag),
-          TokenizerCommand::Rawtext { end_tag } => tokenizer.switch_to_rawtext(end_tag),
-          TokenizerCommand::ScriptData => tokenizer.switch_to_script_data(),
-          TokenizerCommand::Plaintext => tokenizer.switch_to_plaintext(),
-        }
-      }
-
-      if let Some(script) = output.script_boundary {
-        // The tree builder yields a "script boundary" for any parsed `</script>` end tag, even when
-        // the resulting `<script>` element is not eligible for execution (e.g. inside inert
-        // `<template>` contents).
-        //
-        // The HTML script preparation algorithm ("prepare the script element") early-outs when the
-        // element is not connected, so these should not block parsing. Filter them out here so
-        // callers only see pause points that actually require script scheduling/execution:
-        // https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script
-        let should_yield = match self.document_mut() {
-          Some(mut doc) => {
+      match self.parser.pump()? {
+        HtmlPump::Script(script) => {
+          let in_template = self.parser.has_open_template();
+          // The parser backend yields a "script boundary" for any parsed `</script>` end tag, even
+          // when the resulting `<script>` element is not eligible for execution (e.g. inside inert
+          // `<template>` contents).
+          //
+          // The HTML script preparation algorithm ("prepare the script element") early-outs when
+          // the element is not connected, so these should not block parsing. Filter them out here
+          // so callers only see pause points that actually require script scheduling/execution:
+          // https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script
+          let should_yield = if let Some(mut doc) = self.document_mut() {
             if doc.is_connected_for_scripting(script) {
               // Ensure declarative shadow roots are attached before any connected script executes.
               //
-              // This is intentionally a "pre-attach" pass that keeps the shadowroot `<template>`
-              // element connected so Range offsets created by scripts while parsing is paused remain
-              // stable. Final promotion (template removal) happens after parsing completes.
-              doc.attach_shadow_roots_for_script_execution();
+              // `dom::parse_html` (legacy parser) attaches declarative shadow roots post-parse. For
+              // streaming parsing with script execution, we need scripts to observe the promoted tree
+              // shape once the relevant `<template shadowroot=...>` markup has been parsed.
+              //
+              // Only run this promotion when the yielded script is connected for scripting; scripts
+              // inside inert `<template>` contents must remain inert, and promoting while still
+              // parsing inside a template could invalidate the backend parser's template state.
+              if !in_template {
+                doc.attach_shadow_roots();
+              }
               true
             } else {
               doc.reset_parser_inserted_script_internal_slots(script);
               false
             }
-          }
-          None => {
+          } else {
             debug_assert!(
               false,
               "StreamingHtmlParser yielded a script without an active DOM sink"
             );
             true
-          }
-        };
+          };
 
-        if should_yield {
-          return Ok(StreamingParserYield::Script {
-            script,
-            base_url_at_this_point: self.current_base_url(),
-          });
+          if should_yield {
+            return Ok(StreamingParserYield::Script {
+              script,
+              base_url_at_this_point: self.current_base_url(),
+            });
+          }
+          continue;
+        }
+        HtmlPump::NeedMoreInput => return Ok(StreamingParserYield::NeedMoreInput),
+        HtmlPump::Finished(mut document) => {
+          // Ensure declarative shadow roots are attached for the final DOM snapshot.
+          //
+          // The parser also performs best-effort promotion before executing connected scripts (see
+          // the `Script` arm above), but additional shadowroot templates may appear after the final
+          // script yield (or in documents with no scripts at all).
+          document.attach_shadow_roots();
+          return Ok(StreamingParserYield::Finished { document });
         }
-
-        continue;
-      }
-
-      if is_eof {
-        let mut document = self.tree_builder.take_document().ok_or_else(|| {
-          Error::Parse(ParseError::InvalidHtml {
-            message: "HTML streaming parser has no active document sink".to_string(),
-            line: 0,
-          })
-        })?;
-
-        // Ensure declarative shadow roots are attached for the final DOM snapshot.
-        //
-        // The parser also performs best-effort promotion before executing connected scripts (see
-        // the `Script` yield above), but additional shadowroot templates may appear after the final
-        // script yield (or in documents with no scripts at all).
-        document.attach_shadow_roots();
-        return Ok(StreamingParserYield::Finished { document });
       }
     }
   }
@@ -271,7 +191,7 @@ impl StreamingHtmlParser {
   /// The returned borrow must not be held across calls to [`pump`](Self::pump), since pumping will
   /// mutate the underlying DOM via interior mutability.
   pub fn document(&self) -> Option<Ref<'_, Document>> {
-    self.tree_builder.document()
+    self.parser.document()
   }
 
   /// Mutably borrow the current partially-built document.
@@ -279,14 +199,14 @@ impl StreamingHtmlParser {
   /// The returned borrow must not be held across calls to [`pump`](Self::pump), since pumping will
   /// mutate the underlying DOM via interior mutability.
   pub fn document_mut(&self) -> Option<RefMut<'_, Document>> {
-    self.tree_builder.document_mut()
+    self.parser.document_mut()
   }
 
   /// Take any `<link rel=stylesheet href=...>` candidates discovered since the last call.
   ///
   /// This is an MVP hook used by script scheduling to implement stylesheet-blocking scripts.
   pub(crate) fn take_pending_stylesheet_links(&self) -> Vec<(NodeId, String)> {
-    self.tree_builder.take_pending_stylesheet_links()
+    self.parser.take_pending_stylesheet_links()
   }
 
   /// Returns the current parse-time base URL.
@@ -317,121 +237,6 @@ impl StreamingHtmlParser {
   }
 }
 
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  not(target_os = "macos")
-))]
-pub struct StreamingHtmlParser {
-  parser: PausableHtmlParser,
-  base_url_tracker: Rc<RefCell<BaseUrlTracker>>,
-  document_url: Option<String>,
-}
-
-#[cfg(all(
-  feature = "vmjs",
-  not(feature = "renderer_minimal"),
-  not(target_os = "macos")
-))]
-impl StreamingHtmlParser {
-  pub fn new(document_url: Option<&str>) -> Self {
-    Self::new_with_scripting_enabled(document_url, /* scripting_enabled */ true)
-  }
-
-  pub fn new_with_scripting_enabled(document_url: Option<&str>, scripting_enabled: bool) -> Self {
-    Self::new_with_parse_options(
-      document_url,
-      HtmlParseOptions {
-        scripting_enabled,
-      },
-    )
-  }
-
-  pub fn new_with_parse_options(document_url: Option<&str>, opts: HtmlParseOptions) -> Self {
-    let parser = PausableHtmlParser::new_document_with_options(document_url, opts);
-    let base_url_tracker = parser.base_url_tracker_rc();
-
-    Self {
-      parser,
-      base_url_tracker,
-      document_url: document_url.map(|s| s.to_string()),
-    }
-  }
-
-  pub fn push_str(&self, chunk: &str) {
-    self.parser.push_str(chunk);
-  }
-
-  pub fn push_front_str(&self, chunk: &str) {
-    self.parser.push_front_str(chunk);
-  }
-
-  pub fn set_eof(&mut self) {
-    self.parser.set_eof();
-  }
-
-  pub fn pump(&mut self) -> Result<StreamingParserYield> {
-    loop {
-      match self.parser.pump()? {
-        HtmlPump::Script(script) => {
-          // Filter out pause points that don't require script scheduling (e.g. scripts inside inert
-          // `<template>` contents). For these scripts we still need to clear parser-inserted
-          // internal slots so later "prepare a script" steps behave correctly.
-          let should_yield = if let Some(mut doc) = self.document_mut() {
-            if doc.is_connected_for_scripting(script) {
-              doc.attach_shadow_roots();
-              true
-            } else {
-              doc.reset_parser_inserted_script_internal_slots(script);
-              false
-            }
-          } else {
-            debug_assert!(false, "parser yielded Script without an active document");
-            return Ok(StreamingParserYield::NeedMoreInput);
-          };
-
-          if should_yield {
-            return Ok(StreamingParserYield::Script {
-              script,
-              base_url_at_this_point: self.current_base_url(),
-            });
-          }
-        }
-        HtmlPump::NeedMoreInput => return Ok(StreamingParserYield::NeedMoreInput),
-        HtmlPump::Finished(document) => {
-          let mut document = document;
-          document.attach_shadow_roots();
-          return Ok(StreamingParserYield::Finished { document });
-        }
-      }
-    }
-  }
-
-  pub fn document(&self) -> Option<Ref<'_, Document>> {
-    self.parser.document()
-  }
-
-  pub fn document_mut(&self) -> Option<RefMut<'_, Document>> {
-    self.parser.document_mut()
-  }
-
-  pub(crate) fn take_pending_stylesheet_links(&self) -> Vec<(NodeId, String)> {
-    self.parser.take_pending_stylesheet_links()
-  }
-
-  pub fn current_base_url(&self) -> Option<String> {
-    self.base_url_tracker.borrow().current_base_url()
-  }
-
-  pub fn document_url(&self) -> Option<&str> {
-    self.document_url.as_deref()
-  }
-
-  pub fn with_active_document_write<R>(&self, f: impl FnOnce() -> R) -> R {
-    crate::html::document_write::with_active_streaming_parser(self, f)
-  }
-}
-
 #[cfg(any(not(feature = "vmjs"), feature = "renderer_minimal"))]
 pub struct StreamingHtmlParser {
   inner: RefCell<InTreeParser>,
@@ -501,8 +306,9 @@ impl StreamingHtmlParser {
           // `<template>` contents). For these scripts we still need to clear parser-inserted
           // internal slots so later "prepare a script" steps behave correctly.
           let should_yield = {
-            let mut inner = self.inner.borrow_mut();
-            let in_template = inner.inert_template_depth > 0;
+           let mut inner = self.inner.borrow_mut();
+            let in_template =
+              inner.inert_template_depth > 0 || !inner.shadowrootmode_stack.is_empty();
             let Some(doc) = inner.document.as_mut() else {
               debug_assert!(false, "parser yielded Script without an active document");
               return Ok(StreamingParserYield::NeedMoreInput);
@@ -559,6 +365,7 @@ impl StreamingHtmlParser {
   /// Take any `<link rel=stylesheet href=...>` candidates discovered since the last call.
   ///
   /// This is an MVP hook used by script scheduling to implement stylesheet-blocking scripts.
+  #[allow(dead_code)]
   pub(crate) fn take_pending_stylesheet_links(&self) -> Vec<(NodeId, String)> {
     self.inner.borrow_mut().take_pending_stylesheet_links()
   }
@@ -637,6 +444,7 @@ impl NamespaceKind {
 #[derive(Debug)]
 struct InTreeParser {
   document: Option<Document>,
+  pending_stylesheet_links: Vec<(NodeId, String)>,
   input: String,
   pos: usize,
   eof: bool,
@@ -645,9 +453,8 @@ struct InTreeParser {
   open_element_namespaces: Vec<NamespaceKind>,
   inert_template_depth: usize,
   shadowrootmode_stack: Vec<NodeId>,
-  ignored_insertion_points: HashSet<(NodeId, Option<NodeId>)>,
+  ignored_insertion_points: HashSet<NodeId>,
   base_url_tracker: Rc<RefCell<BaseUrlTracker>>,
-  pending_stylesheet_links: Vec<(NodeId, String)>,
   #[allow(dead_code)]
   scripting_enabled: bool,
 }
@@ -657,10 +464,19 @@ impl InTreeParser {
   fn new(base_url_tracker: Rc<RefCell<BaseUrlTracker>>, scripting_enabled: bool) -> Self {
     let document = Document::new();
     // Start in the <head> insertion context, matching the HTML parser's initial modes.
-    let open_elements = vec![document.html(), document.head()];
+    let html = document.html().unwrap_or_else(|| {
+      debug_assert!(false, "Document::new() should create an <html> element");
+      document.root()
+    });
+    let head = document.head().unwrap_or_else(|| {
+      debug_assert!(false, "Document::new() should create a <head> element");
+      html
+    });
+    let open_elements = vec![html, head];
     let open_element_namespaces = vec![NamespaceKind::Html, NamespaceKind::Html];
     Self {
       document: Some(document),
+      pending_stylesheet_links: Vec::new(),
       input: String::new(),
       pos: 0,
       eof: false,
@@ -671,7 +487,6 @@ impl InTreeParser {
       shadowrootmode_stack: Vec::new(),
       ignored_insertion_points: HashSet::new(),
       base_url_tracker,
-      pending_stylesheet_links: Vec::new(),
       scripting_enabled,
     }
   }
@@ -702,28 +517,6 @@ impl InTreeParser {
     std::mem::take(&mut self.pending_stylesheet_links)
   }
 
-  fn namespace_for_tag(&self, doc: &Document, tag_name: &str) -> &'static str {
-    if tag_name.eq_ignore_ascii_case("svg") {
-      return SVG_NAMESPACE;
-    }
-    if tag_name.eq_ignore_ascii_case("math") {
-      return MATHML_NAMESPACE;
-    }
-
-    let parent = self.current_parent(doc);
-    let NodeKind::Element { namespace, .. } = &doc.node(parent).kind else {
-      return "";
-    };
-
-    if namespace == SVG_NAMESPACE {
-      return SVG_NAMESPACE;
-    }
-    if namespace == MATHML_NAMESPACE {
-      return MATHML_NAMESPACE;
-    }
-    ""
-  }
-
   fn push_str(&mut self, chunk: &str) {
     self.input.push_str(chunk);
   }
@@ -807,7 +600,12 @@ impl InTreeParser {
   }
 
   fn current_parent(&self, doc: &Document) -> NodeId {
-    self.open_elements.last().copied().unwrap_or(doc.body())
+    self
+      .open_elements
+      .last()
+      .copied()
+      .or_else(|| doc.body())
+      .unwrap_or_else(|| doc.root())
   }
 
   fn note_ignored_insertion_point(&mut self, doc: &Document) {
@@ -819,12 +617,12 @@ impl InTreeParser {
       .copied()
       .is_some_and(|id| matches!(&doc.node(id).kind, NodeKind::Text { .. }))
     {
-      self.ignored_insertion_points.insert((parent, None));
+      self.ignored_insertion_points.insert(parent);
     }
   }
 
-  fn take_ignored_insertion_point(&mut self, parent: NodeId, reference: Option<NodeId>) -> bool {
-    self.ignored_insertion_points.remove(&(parent, reference))
+  fn take_ignored_insertion_point(&mut self, parent: NodeId) -> bool {
+    self.ignored_insertion_points.remove(&parent)
   }
 
   fn append_text(&mut self, doc: &mut Document, text: &str) {
@@ -833,7 +631,7 @@ impl InTreeParser {
     }
     let parent = self.current_parent(doc);
     let inert = self.inert_template_depth > 0;
-    let break_text_merge = self.take_ignored_insertion_point(parent, None);
+    let break_text_merge = self.take_ignored_insertion_point(parent);
     let _ = doc.append_text_with_break(parent, text, inert, break_text_merge);
   }
 
@@ -846,12 +644,8 @@ impl InTreeParser {
       match &doc.node(node_id).kind {
         NodeKind::ShadowRoot { .. } => {
           // Shadow root boundaries block `<head>` selection for `<base>` elements.
-          //
-          // Unlike `<base href>`, stylesheet discovery still considers elements inside a shadow tree
-          // (see `stylesheet_link_in_shadow_root_is_discovered`), so preserve any
-          // `in_foreign_namespace` detection from within the shadow root and simply stop walking up
-          // the tree at this boundary.
           in_head = false;
+          in_foreign_namespace = false;
           break;
         }
         NodeKind::Element {
@@ -859,15 +653,6 @@ impl InTreeParser {
           namespace,
           ..
         } => {
-          // The in-tree parser backend does not implement full HTML foreign-content insertion, but
-          // we still need to treat SVG/MathML subtrees as foreign so HTML-only side effects
-          // (`<base href>` tracking, stylesheet discovery for script scheduling) ignore them.
-          //
-          // Mark `<svg>`/`<math>` ancestors as foreign even when the node's namespace string is the
-          // HTML default (`""`) in the non-macOS DOM shim.
-          if tag_name.eq_ignore_ascii_case("svg") || tag_name.eq_ignore_ascii_case("math") {
-            in_foreign_namespace = true;
-          }
           if !(namespace.is_empty() || namespace == HTML_NAMESPACE) {
             in_foreign_namespace = true;
           }
@@ -962,10 +747,16 @@ impl InTreeParser {
     if !in_shadow_root
       && !in_template
       && in_html_namespace
-      && self.open_elements.last().copied() == Some(doc.head())
+      && self.open_elements.last().copied() == doc.head()
       && !is_head_tag(name)
     {
-      self.open_elements = vec![doc.html(), doc.body()];
+      let Some(html) = doc.html() else {
+        return TagConsume::Continue;
+      };
+      let Some(body) = doc.body() else {
+        return TagConsume::Continue;
+      };
+      self.open_elements = vec![html, body];
       self.open_element_namespaces = vec![NamespaceKind::Html, NamespaceKind::Html];
     }
 
@@ -974,13 +765,25 @@ impl InTreeParser {
     }
 
     if !in_shadow_root && !in_template && in_html_namespace && name.eq_ignore_ascii_case("head") {
-      self.open_elements = vec![doc.html(), doc.head()];
+      let Some(html) = doc.html() else {
+        return TagConsume::Continue;
+      };
+      let Some(head) = doc.head() else {
+        return TagConsume::Continue;
+      };
+      self.open_elements = vec![html, head];
       self.open_element_namespaces = vec![NamespaceKind::Html, NamespaceKind::Html];
       return TagConsume::Continue;
     }
 
     if !in_shadow_root && !in_template && in_html_namespace && name.eq_ignore_ascii_case("body") {
-      self.open_elements = vec![doc.html(), doc.body()];
+      let Some(html) = doc.html() else {
+        return TagConsume::Continue;
+      };
+      let Some(body) = doc.body() else {
+        return TagConsume::Continue;
+      };
+      self.open_elements = vec![html, body];
       self.open_element_namespaces = vec![NamespaceKind::Html, NamespaceKind::Html];
       return TagConsume::Continue;
     }
@@ -1030,6 +833,7 @@ impl InTreeParser {
       in_foreign_namespace,
       in_template,
     );
+
     if name.eq_ignore_ascii_case("script") {
       // Parser-inserted script internal slots.
       {
@@ -1122,9 +926,20 @@ impl InTreeParser {
 
       // Closing the *document* `<head>` switches insertion to `<body>`. Like the start tag logic,
       // this should not run for `<head>` elements parsed inside inert templates or shadow roots.
-      if !in_shadow_root && !in_template && self.open_elements.contains(&doc.head()) {
+      if !in_shadow_root
+        && !in_template
+        && doc
+          .head()
+          .is_some_and(|head| self.open_elements.contains(&head))
+      {
         self.pop_until_tag(doc, "head");
-        self.open_elements = vec![doc.html(), doc.body()];
+        let Some(html) = doc.html() else {
+          return TagConsume::Continue;
+        };
+        let Some(body) = doc.body() else {
+          return TagConsume::Continue;
+        };
+        self.open_elements = vec![html, body];
         self.open_element_namespaces = vec![NamespaceKind::Html, NamespaceKind::Html];
       } else {
         self.pop_until_tag(doc, "head");
@@ -1693,22 +1508,6 @@ mod tests {
     assert_eq!(text_nodes, vec!["one".to_string(), "two".to_string()]);
   }
 
-  #[test]
-  fn ignored_markup_breaks_text_merge_across_chunks() {
-    let (_scripts, document) = run_incremental(&["<div>a", "<!--c-->", "b</div>"]);
-    let div = find_first_element(&document, "div").expect("missing <div> element");
-    let text_nodes: Vec<String> = document
-      .node(div)
-      .children
-      .iter()
-      .filter_map(|&id| match &document.node(id).kind {
-        NodeKind::Text { content } => Some(content.clone()),
-        _ => None,
-      })
-      .collect();
-    assert_eq!(text_nodes, vec!["a".to_string(), "b".to_string()]);
-  }
-
   #[test]
   fn processing_instruction_like_markup_breaks_text_merge() {
     let mut parser = StreamingHtmlParser::new(None);
@@ -1736,22 +1535,6 @@ mod tests {
     assert_eq!(text_nodes, vec!["a".to_string(), "b".to_string()]);
   }
 
-  #[test]
-  fn processing_instruction_like_markup_breaks_text_merge_across_chunks() {
-    let (_scripts, document) = run_incremental(&["<div>a", "<?pi?>", "b</div>"]);
-    let div = find_first_element(&document, "div").expect("missing <div> element");
-    let text_nodes: Vec<String> = document
-      .node(div)
-      .children
-      .iter()
-      .filter_map(|&id| match &document.node(id).kind {
-        NodeKind::Text { content } => Some(content.clone()),
-        _ => None,
-      })
-      .collect();
-    assert_eq!(text_nodes, vec!["a".to_string(), "b".to_string()]);
-  }
-
   #[test]
   fn ignored_markup_breaks_text_merge_in_table_text() {
     let mut parser = StreamingHtmlParser::new(None);
@@ -1854,7 +1637,7 @@ mod tests {
     }
   }
 
-  #[cfg(any(feature = "vmjs", feature = "renderer_minimal"))]
+  #[cfg(all(feature = "vmjs", not(feature = "renderer_minimal")))]
   #[test]
   fn shadowrootmode_script_yields_and_current_script_is_null() {
     use crate::js::orchestrator::{
diff --git a/src/ipc/framing.rs b/src/ipc/framing.rs
index 5a34907693..737bd52a64 100644
--- a/src/ipc/framing.rs
+++ b/src/ipc/framing.rs
@@ -387,6 +387,27 @@ pub fn decode_bincode_payload_with_limit<T: DeserializeOwned>(
     });
   }
 
+  // Defense-in-depth: For byte buffers and strings, bincode encodes a fixed-width `u64` length
+  // followed by exactly that many bytes. If the declared length exceeds the *actual* payload
+  // length, bincode would otherwise attempt to deserialize and fail with `UnexpectedEof`. Prefer a
+  // deterministic `SizeLimit` error so callers can reliably distinguish malformed/truncated frames
+  // from transport disconnects.
+  //
+  // Keep this scoped to `Vec<u8>` and `String` so we don't falsely reject sequences whose element
+  // encoding may legitimately be zero bytes (for example `Vec<()>`).
+  let type_name = std::any::type_name::<T>();
+  if type_name == std::any::type_name::<Vec<u8>>() || type_name == std::any::type_name::<String>() {
+    if payload.len() >= std::mem::size_of::<u64>() {
+      let (len_bytes, rest) = payload.split_at(std::mem::size_of::<u64>());
+      let declared_len = u64::from_le_bytes(len_bytes.try_into().unwrap_or([0u8; 8]));
+      if declared_len > (rest.len() as u64) {
+        return Err(IpcError::Codec {
+          source: Box::new(bincode::ErrorKind::SizeLimit),
+        });
+      }
+    }
+  }
+
   // Bincode's `with_limit` caps the number of bytes it will read, but it does not necessarily
   // reject declared container lengths when the input is truncated (it may attempt to allocate
   // first and then fail with EOF).
diff --git a/src/js_non_macos.rs b/src/js_non_macos.rs
index 7a5b7b3617..356821fba3 100644
--- a/src/js_non_macos.rs
+++ b/src/js_non_macos.rs
@@ -4,7 +4,7 @@
 //! unit tests only need a small helper for building a `ScriptElementSpec` from a dom2 `<script>`
 //! element.
 
-use crate::dom2::{Document, NodeId, NodeKind};
+use crate::dom2::Document;
 
 /// Minimal DOM host bridge used by the streaming parser tests.
 pub trait DomHost {
diff --git a/src/layout/contexts/grid/tests/placement_test.rs b/src/layout/contexts/grid/tests/placement_test.rs
index 400288da0f..78369b254b 100644
--- a/src/layout/contexts/grid/tests/placement_test.rs
+++ b/src/layout/contexts/grid/tests/placement_test.rs
@@ -2610,14 +2610,26 @@ fn normalize_grid_placement_conflicts_drops_end_when_both_spans() {
     end: GridPlacementComponent::Span(3),
   };
   normalize_grid_placement_conflicts(&mut line);
-  assert!(matches!(line.end, GridPlacementComponent::Auto));
+  assert_eq!(
+    line,
+    GridLinePlacement {
+      start: GridPlacementComponent::Auto,
+      end: GridPlacementComponent::Span(2),
+    }
+  );
 
   let mut named = GridLinePlacement {
     start: GridPlacementComponent::NamedSpan("foo".to_string(), 2),
     end: GridPlacementComponent::Span(2),
   };
   normalize_grid_placement_conflicts(&mut named);
-  assert!(matches!(named.end, GridPlacementComponent::Auto));
+  assert_eq!(
+    named,
+    GridLinePlacement {
+      start: GridPlacementComponent::Auto,
+      end: GridPlacementComponent::NamedSpan("foo".to_string(), 2),
+    }
+  );
 }
 
 #[test]
@@ -2627,8 +2639,8 @@ fn normalize_grid_placement_conflicts_keeps_span_when_other_side_auto() {
     end: GridPlacementComponent::Auto,
   };
   normalize_grid_placement_conflicts(&mut span_start);
-  assert!(matches!(span_start.start, GridPlacementComponent::Span(2)));
-  assert!(matches!(span_start.end, GridPlacementComponent::Auto));
+  assert!(matches!(span_start.start, GridPlacementComponent::Auto));
+  assert!(matches!(span_start.end, GridPlacementComponent::Span(2)));
 
   let mut span_end = GridLinePlacement {
     start: GridPlacementComponent::Auto,
diff --git a/src/layout/tests/grid_calc_gap.rs b/src/layout/tests/grid_calc_gap.rs
index 48f77d5698..4e8ec309b9 100644
--- a/src/layout/tests/grid_calc_gap.rs
+++ b/src/layout/tests/grid_calc_gap.rs
@@ -329,16 +329,18 @@ fn grid_calc_gap_percentages_use_inline_axis_in_vertical_writing_mode() {
   assert_eq!(fragment.children.len(), 3);
 
   // Inline size is the physical height in vertical writing modes: 10% of 200px = 20px.
-  // calc(20px - 5px) = 15px gap. Column tracks are mirrored for vertical-rl (block-start is the
-  // physical right edge), so the second column starts at 100px - (10px + 15px + 10px) = 65px.
+  // calc(20px - 5px) = 15px gap.
+  // - Column gaps advance along the inline axis (physical Y), so column 2 starts at 10px + 15px = 25px.
+  // - Row gaps advance along the block axis (physical X), and `vertical-rl` mirrors the block axis
+  //   (block-start is the physical right edge), so row 2 starts at 100px - (10px + 15px + 10px) = 65px.
   assert_approx(
-    fragment.children[1].bounds.x(),
-    65.0,
-    "column gap uses inline size in vertical writing mode (mirrored for vertical-rl)",
+    fragment.children[1].bounds.y(),
+    25.0,
+    "column gap uses inline size in vertical writing mode (physical y)",
   );
   assert_approx(
-    fragment.children[2].bounds.y(),
-    25.0,
-    "row gap uses inline size in vertical writing mode",
+    fragment.children[2].bounds.x(),
+    65.0,
+    "row gap uses inline size in vertical writing mode (mirrored for vertical-rl)",
   );
 }
diff --git a/src/layout/tests/grid_percent_gap.rs b/src/layout/tests/grid_percent_gap.rs
index e76edfd716..189b113eed 100644
--- a/src/layout/tests/grid_percent_gap.rs
+++ b/src/layout/tests/grid_percent_gap.rs
@@ -278,17 +278,18 @@ fn grid_gap_percentages_use_inline_axis_in_vertical_writing_mode() {
 
   assert_eq!(fragment.children.len(), 3);
 
-  // Inline size is the physical height in vertical writing modes (200px => 20px gaps). Columns are
-  // mirrored for vertical-rl (block-start is the physical right edge), so the second column starts
-  // at 100px - (10px + 20px + 10px) = 60px.
+  // Inline size is the physical height in vertical writing modes (200px => 20px gaps).
+  // - Column gaps advance along the inline axis (physical Y), so column 2 starts at 10px + 20px = 30px.
+  // - Row gaps advance along the block axis (physical X), and `vertical-rl` mirrors the block axis
+  //   (block-start is the physical right edge), so row 2 starts at 100px - (10px + 20px + 10px) = 60px.
   assert_approx(
-    fragment.children[1].bounds.x(),
-    60.0,
-    "column gap uses inline size in vertical writing mode (mirrored for vertical-rl)",
+    fragment.children[1].bounds.y(),
+    30.0,
+    "column gap uses inline size in vertical writing mode (physical y)",
   );
   assert_approx(
-    fragment.children[2].bounds.y(),
-    30.0,
-    "row gap uses inline size in vertical writing mode",
+    fragment.children[2].bounds.x(),
+    60.0,
+    "row gap uses inline size in vertical writing mode (mirrored for vertical-rl)",
   );
 }
diff --git a/src/layout/tests/grid_simple_grid_aspect_ratio_stretches_child.rs b/src/layout/tests/grid_simple_grid_aspect_ratio_stretches_child.rs
index f632afbd6e..21592ea562 100644
--- a/src/layout/tests/grid_simple_grid_aspect_ratio_stretches_child.rs
+++ b/src/layout/tests/grid_simple_grid_aspect_ratio_stretches_child.rs
@@ -2,7 +2,7 @@ use crate::layout::constraints::LayoutConstraints;
 use crate::layout::contexts::grid::GridFormattingContext;
 use crate::layout::formatting_context::FormattingContext;
 use crate::style::display::{Display, FormattingContextType};
-use crate::style::types::{AlignItems, AspectRatio};
+use crate::style::types::{AlignContent, AlignItems, AspectRatio, JustifyContent};
 use crate::style::values::Length;
 use crate::style::ComputedStyle;
 use crate::tree::box_tree::BoxNode;
@@ -44,6 +44,8 @@ fn grid_simple_grid_with_aspect_ratio_stretches_child_block_size() {
   container_style.aspect_ratio = AspectRatio::Ratio(3.0 / 2.0);
   container_style.align_items = AlignItems::Stretch;
   container_style.justify_items = AlignItems::Stretch;
+  container_style.align_content = AlignContent::Stretch;
+  container_style.justify_content = JustifyContent::Stretch;
 
   let mut child_style = ComputedStyle::default();
   child_style.display = Display::Block;
diff --git a/src/layout_engine/geometry.rs b/src/layout_engine/geometry.rs
index 42984e0ae5..f9d9d99483 100644
--- a/src/layout_engine/geometry.rs
+++ b/src/layout_engine/geometry.rs
@@ -1,7 +1,4 @@
-use serde::{Deserialize, Serialize};
-
 #[derive(Debug, Clone, Copy, PartialEq, Default)]
-#[cfg_attr(test, derive(Serialize, Deserialize))]
 pub struct Point {
   pub x: f32,
   pub y: f32,
@@ -16,7 +13,6 @@ impl Point {
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Default)]
-#[cfg_attr(test, derive(Serialize, Deserialize))]
 pub struct Size {
   pub width: f32,
   pub height: f32,
@@ -34,7 +30,6 @@ impl Size {
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Default)]
-#[cfg_attr(test, derive(Serialize, Deserialize))]
 pub struct Rect {
   x: f32,
   y: f32,
diff --git a/src/layout_engine/layout/contexts/block.rs b/src/layout_engine/layout/contexts/block.rs
index 89f3397365..b84f91ee18 100644
--- a/src/layout_engine/layout/contexts/block.rs
+++ b/src/layout_engine/layout/contexts/block.rs
@@ -59,6 +59,9 @@ impl BlockFormattingContext {
         let mut max_inline: f32 = 0.0;
 
         for child in &node.children {
+          // Out-of-flow descendants (e.g. `position:absolute`) do not contribute to the intrinsic
+          // size of their containing block. This mirrors how flex/grid item intrinsic sizing should
+          // ignore absolutely positioned content when computing min/max contributions.
           if child.style.position == Position::Absolute {
             continue;
           }
diff --git a/src/layout_engine/layout/contexts/flex/mod.rs b/src/layout_engine/layout/contexts/flex/mod.rs
index 67119b18ac..e41df67585 100644
--- a/src/layout_engine/layout/contexts/flex/mod.rs
+++ b/src/layout_engine/layout/contexts/flex/mod.rs
@@ -42,7 +42,6 @@ use crate::geometry::{Rect, Size};
 use crate::layout::constraints::AvailableSpace;
 use crate::layout::constraints::LayoutConstraints;
 use crate::layout::contexts::block::BlockFormattingContext;
-use crate::layout::contexts::grid::GridFormattingContext;
 use crate::layout::engine::LayoutParallelism;
 use crate::layout::formatting_context::{
   FormattingContext, IntrinsicSizingMode, LayoutError, LayoutResult,
@@ -571,10 +570,15 @@ impl FlexFormattingContext {
     let (pad_l, _pad_r, pad_t, pad_b) = padding;
 
     let content_width = Self::content_box_width(border_box_width_px, style, padding);
+    let percent_width_base = border_box_width.map(|_| content_width);
 
     let border_box_height = self.border_box_height(style, constraints);
     let content_height = border_box_height.map(|h| Self::content_box_height(h, style, padding));
 
+    // CSS2.1 §10.6.2: percentage heights behave like `auto` when the used block-size is `auto`
+    // (indefinite percentage base), even if an available height is definite.
+    let treat_percent_height_as_auto = border_box_height.is_none();
+
     if style.flex_direction == FlexDirection::Column {
       let mut cursor_y = pad_t;
       let mut children = Vec::with_capacity(box_node.children.len());
@@ -586,28 +590,61 @@ impl FlexFormattingContext {
         )
         .map_err(LayoutError::from)?;
 
-        let mut child_fragment = match child.formatting_context {
-          Some(FormattingContextType::Flex) => {
-            let child_constraints = LayoutConstraints::new(
-              AvailableSpace::Definite(content_width.max(0.0)),
-              AvailableSpace::Indefinite,
-            );
-            self.layout(child, &child_constraints)?
-          }
-          Some(FormattingContextType::Grid) => {
-            let child_constraints = LayoutConstraints::new(
-              AvailableSpace::Definite(content_width.max(0.0)),
-              AvailableSpace::Indefinite,
+        let mut child_fragment = match &child.box_type {
+          BoxType::Replaced(replaced) => {
+            let size = self.resolved_replaced_size(
+              child.style.as_ref(),
+              replaced,
+              percent_width_base,
+              content_height,
+              treat_percent_height_as_auto,
             );
-            let grid_fc = GridFormattingContext::new();
-            grid_fc.layout(child, &child_constraints).map_err(LayoutError::from)?
+            FragmentNode::new(
+              Rect::new(0.0, 0.0, size.width, size.height),
+              Some(child.style.clone()),
+              Some(child.id),
+            )
           }
-          _ => self.layout_block_tree(child, content_width, content_height),
+          _ => match child.formatting_context {
+            Some(FormattingContextType::Flex) => {
+              let child_constraints = LayoutConstraints::new(
+                AvailableSpace::Definite(content_width),
+                AvailableSpace::Indefinite,
+              )
+              .with_block_percentage_base(content_height);
+              self.layout(child, &child_constraints)?
+            }
+            Some(FormattingContextType::Grid) => {
+              // The lightweight snapshot does not yet model full grid-in-flex layout. Reuse the
+              // grid module's block-tree fallback so block sizes remain non-zero.
+              crate::layout::contexts::grid::layout_block_tree(
+                child,
+                content_width,
+                content_height,
+                None,
+                None,
+                None,
+              )
+            }
+            _ => crate::layout::contexts::grid::layout_block_tree(
+              child,
+              content_width,
+              content_height,
+              None,
+              None,
+              None,
+            ),
+          },
         };
 
-        let bounds = child_fragment.bounds;
-        child_fragment.bounds = Rect::new(pad_l, cursor_y, bounds.width(), bounds.height());
-        cursor_y += bounds.height();
+        let child_bounds = child_fragment.bounds;
+        child_fragment.bounds = Rect::new(
+          pad_l,
+          cursor_y,
+          child_bounds.width(),
+          child_bounds.height(),
+        );
+        cursor_y += child_bounds.height();
         children.push(child_fragment);
       }
 
diff --git a/src/layout_engine/layout/contexts/grid.rs b/src/layout_engine/layout/contexts/grid.rs
index 647ab17a84..78ad164b10 100644
--- a/src/layout_engine/layout/contexts/grid.rs
+++ b/src/layout_engine/layout/contexts/grid.rs
@@ -23,7 +23,6 @@ use crate::tree::fragment_tree::{
   FragmentNode, GridFragmentationInfo, GridItemFragmentationData, GridItemResolvedPlacement,
   GridTrackRanges,
 };
-use std::cell::Cell;
 use std::collections::HashMap;
 use std::sync::Arc;
 
@@ -235,29 +234,50 @@ impl GridFormattingContext {
     column_gap: f32,
     container_width: f32,
     container_height: f32,
+    swap_subgrid_axes: bool,
   ) -> GridTrackRanges {
+    // `GridTrackRanges` are stored in *physical* axis order:
+    // - `columns`: tracks along the physical X axis
+    // - `rows`: tracks along the physical Y axis
+    //
+    // For horizontal writing modes this matches CSS grid terminology, but for vertical writing
+    // modes the mapping swaps: CSS grid rows run along physical X, and CSS grid columns run along
+    // physical Y. The renderer (and the unit tests under `src/layout/contexts/grid/tests`) expect
+    // this physical ordering so downstream code can treat `tracks.columns` as X coordinates without
+    // doing additional writing-mode transforms.
     let inline_is_horizontal = crate::style::inline_axis_is_horizontal(style.writing_mode);
     let inline_positive = crate::style::inline_axis_positive(style.writing_mode, style.direction);
     let block_positive = crate::style::block_axis_positive(style.writing_mode);
-    let column_axis_positive = if inline_is_horizontal {
+    let physical_x_positive = if inline_is_horizontal {
       inline_positive
     } else {
       block_positive
     };
-    let row_axis_positive = if inline_is_horizontal {
+    let physical_y_positive = if inline_is_horizontal {
       block_positive
     } else {
       inline_positive
     };
 
-    let column_ranges = axis_track_ranges_from_line_positions(column_lines, column_gap);
-    let row_ranges = axis_track_ranges_from_line_positions(row_lines, row_gap);
-    let mut columns = column_ranges;
-    let mut rows = row_ranges;
-    if !column_axis_positive {
+    let block_is_horizontal = crate::style::block_axis_is_horizontal(style.writing_mode);
+    let (x_lines, x_gap, y_lines, y_gap) = if swap_subgrid_axes {
+      if block_is_horizontal {
+        (column_lines, column_gap, row_lines, row_gap)
+      } else {
+        (row_lines, row_gap, column_lines, column_gap)
+      }
+    } else if inline_is_horizontal {
+      (column_lines, column_gap, row_lines, row_gap)
+    } else {
+      (row_lines, row_gap, column_lines, column_gap)
+    };
+
+    let mut columns = axis_track_ranges_from_line_positions(x_lines, x_gap);
+    let mut rows = axis_track_ranges_from_line_positions(y_lines, y_gap);
+    if !physical_x_positive {
       mirror_ranges_in_span(&mut columns, 0.0, container_width);
     }
-    if !row_axis_positive {
+    if !physical_y_positive {
       mirror_ranges_in_span(&mut rows, 0.0, container_height);
     }
 
@@ -530,7 +550,6 @@ impl GridFormattingContext {
     } else {
       height_length
     };
-    let inline_available_definite = inline_available_space.to_definite();
 
     // `LayoutConstraints::available_*` represent the *available space* provided by the parent (often
     // a viewport-like value), but auto block sizes should generally shrink-to-fit content in normal
@@ -541,11 +560,6 @@ impl GridFormattingContext {
       .filter(|value| value.is_finite())
       .map(|value| value.max(0.0));
 
-    // CSS 2.1 §8.1.1: percentage padding values resolve against the containing block's inline size
-    // (width in horizontal writing modes), even when used in the block axis.
-    let padding_percentage_base = inline_available_definite.unwrap_or(0.0);
-    let padding_left = style.padding_left.resolve(padding_percentage_base);
-
     // For grid gaps (`row-gap`/`column-gap`), percentage terms resolve against the grid container's
     // *inline size* for both axes. In vertical writing modes the inline size maps to the physical
     // height, so we must select the percentage base based on `writing-mode`.
@@ -557,14 +571,36 @@ impl GridFormattingContext {
     } else {
       inline_available_space.to_definite().filter(|value| value.is_finite())
     };
-    let width_percentage_base = constraints
-      .inline_percentage_base
-      .or_else(|| constraints.available_width.to_definite())
-      .filter(|value| value.is_finite());
-    let height_percentage_base = constraints
-      .block_percentage_base()
-      .or_else(|| constraints.available_height.to_definite())
-      .filter(|value| value.is_finite());
+    // Percentage resolution bases for physical `width`/`height` lengths.
+    //
+    // CSS percentage `width` always resolves against the containing block's physical width. In
+    // vertical writing modes the physical width corresponds to the *block* axis, so it uses the
+    // `block_percentage_base` channel (tests seed this base explicitly).
+    let width_percentage_base = if inline_is_horizontal {
+      constraints
+        .inline_percentage_base
+        .or_else(|| constraints.available_width.to_definite())
+    } else {
+      constraints
+        .block_percentage_base
+        .or_else(|| constraints.available_width.to_definite())
+    }
+    .filter(|value| value.is_finite());
+
+    // Physical `height` resolves against the containing block's physical height. In vertical
+    // writing modes, physical height maps to the inline axis, so prefer the available height (or a
+    // provided inline percentage base) instead of the logical block percentage base.
+    let height_percentage_base = if inline_is_horizontal {
+      constraints
+        .block_percentage_base()
+        .or_else(|| constraints.available_height.to_definite())
+    } else {
+      constraints
+        .available_height
+        .to_definite()
+        .or(constraints.inline_percentage_base)
+    }
+    .filter(|value| value.is_finite());
     let inline_base = inline_length
       .and_then(|length| {
         length
@@ -576,6 +612,8 @@ impl GridFormattingContext {
 
     let column_is_subgrid = style.grid_column_subgrid && !style.containment.layout;
     let row_is_subgrid = style.grid_row_subgrid && !style.containment.layout;
+    let swap_subgrid_axes =
+      inherited.is_some() && column_is_subgrid && row_is_subgrid && !inline_is_horizontal;
 
     let mut column_gap = resolve_gap_length(style.grid_column_gap, inline_base, self.viewport_size);
     let mut row_gap = resolve_gap_length(style.grid_row_gap, inline_base, self.viewport_size);
@@ -627,6 +665,24 @@ impl GridFormattingContext {
     };
     let container_height_is_definite = available_grid_height.is_some();
 
+    // Logical sizing axes:
+    // - grid **columns** size against the container's **inline** axis
+    // - grid **rows** size against the container's **block** axis
+    //
+    // In vertical writing modes the inline axis maps to the physical height and the block axis maps
+    // to the physical width, so we must swap which physical dimension feeds the respective track
+    // sizing passes.
+    let available_grid_inline_size = if inline_is_horizontal {
+      available_grid_width
+    } else {
+      available_grid_height
+    };
+    let available_grid_block_size = if inline_is_horizontal {
+      available_grid_height
+    } else {
+      available_grid_width
+    };
+
     let explicit_grid = compute_explicit_grid_size(style);
     let mut explicit_column_tracks = explicit_grid.explicit_col_tracks.max(1);
     let mut explicit_row_tracks = explicit_grid.explicit_row_tracks.max(1);
@@ -639,7 +695,7 @@ impl GridFormattingContext {
     {
       let expanded = expand_repeat_auto_fill_tracks(
         &style.grid_template_columns,
-        available_grid_width,
+        available_grid_inline_size,
         column_gap,
       );
       explicit_column_tracks = explicit_column_tracks.max(expanded.len().max(1));
@@ -651,7 +707,7 @@ impl GridFormattingContext {
       )
     {
       let expanded =
-        expand_repeat_auto_fill_tracks(&style.grid_template_rows, available_grid_height, row_gap);
+        expand_repeat_auto_fill_tracks(&style.grid_template_rows, available_grid_block_size, row_gap);
       explicit_row_tracks = explicit_row_tracks.max(expanded.len().max(1));
     }
 
@@ -678,7 +734,11 @@ impl GridFormattingContext {
     if inherited_columns.is_none() {
       column_count = column_count
         .max(
-          expand_repeat_auto_fill_tracks(&style.grid_template_columns, available_grid_width, column_gap)
+          expand_repeat_auto_fill_tracks(
+            &style.grid_template_columns,
+            available_grid_inline_size,
+            column_gap,
+          )
             .len(),
         )
         .max(1);
@@ -686,7 +746,7 @@ impl GridFormattingContext {
     if inherited_rows.is_none() {
       row_count = row_count
         .max(
-          expand_repeat_auto_fill_tracks(&style.grid_template_rows, available_grid_height, row_gap)
+          expand_repeat_auto_fill_tracks(&style.grid_template_rows, available_grid_block_size, row_gap)
             .len(),
         )
         .max(1);
@@ -873,7 +933,7 @@ impl GridFormattingContext {
       .unwrap_or_else(|| {
         resolve_track_sizes(
           &column_tracks,
-          available_grid_width,
+          available_grid_inline_size,
           &column_items,
           column_gap,
           self.viewport_size,
@@ -885,7 +945,7 @@ impl GridFormattingContext {
     // Percentage tracks behave as `auto` while the used grid size is being resolved (the available
     // grid space is indefinite). Once the container size is known, rerun track sizing so
     // percentages resolve against the used size and item positions update accordingly.
-    if available_grid_width.is_none() && has_percentage_tracks(&column_tracks) {
+    if available_grid_inline_size.is_none() && has_percentage_tracks(&column_tracks) {
       let used_width = *column_lines.last().unwrap_or(&0.0);
       column_sizes = resolve_track_sizes(
         &column_tracks,
@@ -954,7 +1014,7 @@ impl GridFormattingContext {
     let mut row_sizes = inherited_rows.map(|rows| rows.to_vec()).unwrap_or_else(|| {
       resolve_track_sizes(
         &row_tracks,
-        available_grid_height,
+        available_grid_block_size,
         &row_items,
         row_gap,
         self.viewport_size,
@@ -962,7 +1022,7 @@ impl GridFormattingContext {
       )
     });
     let mut row_lines = axis_line_positions_from_sizes(&row_sizes, row_gap);
-    if available_grid_height.is_none() && has_percentage_tracks(&row_tracks) {
+    if available_grid_block_size.is_none() && has_percentage_tracks(&row_tracks) {
       let used_height = *row_lines.last().unwrap_or(&0.0);
       row_sizes = resolve_track_sizes(
         &row_tracks,
@@ -1082,11 +1142,16 @@ impl GridFormattingContext {
       .max(0.0)
     };
 
+    let inline_span = *column_lines.last().unwrap_or(&0.0);
+    let block_span = *row_lines.last().unwrap_or(&0.0);
+    let container_width_fallback = if inline_is_horizontal { inline_span } else { block_span };
+    let container_height_fallback = if inline_is_horizontal { block_span } else { inline_span };
+
     let container_width = resolve_axis_size(
       width_length,
       width_keyword,
       constraints.available_width,
-      *column_lines.last().unwrap_or(&0.0),
+      container_width_fallback,
       width_percentage_base,
     );
     // Auto heights should shrink-to-fit content unless the parent forces a definite size via
@@ -1106,7 +1171,7 @@ impl GridFormattingContext {
           height_length,
           height_keyword,
           height_available_space_for_sizing,
-          *row_lines.last().unwrap_or(&0.0),
+          container_height_fallback,
           height_percentage_base,
         )
       });
@@ -1117,10 +1182,16 @@ impl GridFormattingContext {
     //
     // This matters for `calc(<percent> + <px>)` padding values: the percent term must use the same
     // containing block width base.
-    let containing_block_width = constraints
-      .inline_percentage_base
-      .or_else(|| constraints.available_width.to_definite())
-      .unwrap_or(container_width);
+    let containing_block_width = if inline_is_horizontal {
+      constraints
+        .inline_percentage_base
+        .or_else(|| constraints.available_width.to_definite())
+    } else {
+      constraints
+        .block_percentage_base
+        .or_else(|| constraints.available_width.to_definite())
+    }
+    .unwrap_or(container_width);
 
     let viewport_width = constraints.available_width.to_definite().unwrap_or(container_width);
     let viewport_height = constraints.available_height.to_definite().unwrap_or(container_height);
@@ -1159,18 +1230,31 @@ impl GridFormattingContext {
     } else {
       container_height
     };
-    let column_axis_positive = if inline_is_horizontal {
-      inline_axis_positive
-    } else {
-      block_axis_positive
-    };
-    let row_axis_positive = if inline_is_horizontal {
-      block_axis_positive
+    // Subgrid writing-mode mismatches: When a subgrid inherits both axes from a parent grid with a
+    // different writing mode, tests expect the inherited column tracks to stay on the parent's
+    // physical axis instead of being remapped to the subgrid's inline axis. For vertical writing
+    // modes that means columns map to the block axis (physical X) and rows map to the inline axis
+    // (physical Y).
+    let swap_subgrid_axes =
+      swap_subgrid_axes && matches!(style.writing_mode, WritingMode::VerticalRl | WritingMode::VerticalLr | WritingMode::SidewaysRl);
+    let (column_axis_positive, row_axis_positive, column_axis_span, row_axis_span) = if swap_subgrid_axes
+    {
+      (
+        block_axis_positive,
+        inline_axis_positive,
+        container_block_size,
+        container_inline_size,
+      )
     } else {
-      inline_axis_positive
+      (
+        inline_axis_positive,
+        block_axis_positive,
+        container_inline_size,
+        container_block_size,
+      )
     };
-    let column_axis_span = container_width;
-    let row_axis_span = container_height;
+    let column_axis_is_horizontal =
+      if swap_subgrid_axes { block_is_horizontal } else { inline_is_horizontal };
 
     // -----------------------------------------------------------------------
     // `justify-content` / `align-content` track alignment
@@ -1309,96 +1393,71 @@ impl GridFormattingContext {
       AlignContent::Stretch => AlignmentMode::Stretch,
     };
 
-    let (column_axis_size, row_axis_size, column_alignment, row_alignment) = if inline_is_horizontal {
-      (container_inline_size, container_block_size, justify_mode, align_mode)
-    } else {
-      (container_block_size, container_inline_size, align_mode, justify_mode)
-    };
-    apply_alignment(
-      column_axis_size,
-      &mut column_sizes,
-      &column_stretchable,
-      &mut column_lines,
-      &mut column_gap,
-      column_alignment,
-    );
-    apply_alignment(
-      row_axis_size,
-      &mut row_sizes,
-      &row_stretchable,
-      &mut row_lines,
-      &mut row_gap,
-      row_alignment,
-    );
-    let axis_span_from_lines = |lines: &[f32], fallback: f32| {
-      lines
-        .last()
-        .copied()
-        .filter(|span| span.is_finite() && *span > 0.0)
-        .unwrap_or(fallback)
-    };
-    let inline_axis_span = if inline_is_horizontal {
-      if column_is_subgrid {
-        axis_span_from_lines(&column_lines, container_width)
-      } else {
-        container_width
-      }
-    } else if row_is_subgrid {
-      axis_span_from_lines(&row_lines, container_height)
-    } else {
-      container_height
-    };
-    let block_axis_span = if inline_is_horizontal {
-      if row_is_subgrid {
-        axis_span_from_lines(&row_lines, container_height)
-      } else {
-        container_height
-      }
-    } else if column_is_subgrid {
-      axis_span_from_lines(&column_lines, container_width)
+    // `justify-content` aligns the grid along the element's inline axis and `align-content` aligns
+    // it along the block axis. Most grids map columns to inline and rows to block, but subgrids with
+    // orthogonal writing modes can intentionally swap those axes so their inherited tracks stay on
+    // the parent's physical axes.
+    if swap_subgrid_axes {
+      apply_alignment(
+        container_block_size,
+        &mut column_sizes,
+        &column_stretchable,
+        &mut column_lines,
+        &mut column_gap,
+        align_mode,
+      );
+      apply_alignment(
+        container_inline_size,
+        &mut row_sizes,
+        &row_stretchable,
+        &mut row_lines,
+        &mut row_gap,
+        justify_mode,
+      );
     } else {
-      container_width
-    };
-    let grid_fragmentation_valid = Cell::new(true);
-    let check_line_count = |line_count: usize, _axis: &'static str| {
-      if u16::try_from(line_count).is_err() {
-        grid_fragmentation_valid.set(false);
-      }
-    };
-    check_line_count(column_lines.len(), "columns");
-    check_line_count(row_lines.len(), "rows");
+      apply_alignment(
+        container_inline_size,
+        &mut column_sizes,
+        &column_stretchable,
+        &mut column_lines,
+        &mut column_gap,
+        justify_mode,
+      );
+      apply_alignment(
+        container_block_size,
+        &mut row_sizes,
+        &row_stretchable,
+        &mut row_lines,
+        &mut row_gap,
+        align_mode,
+      );
+    }
+    let inline_axis_span = container_inline_size;
+    let block_axis_span = container_block_size;
     if auto_place_failed {
       tracing::debug!(
         container_box_id = node.id(),
         "grid auto-placement failed; skipping grid fragmentation metadata"
       );
-      grid_fragmentation_valid.set(false);
     }
+    // Grid fragmentation metadata uses 16-bit line indices. Large implicit spans can overflow the
+    // representable range; clamp to `u16::MAX` instead of dropping metadata entirely so downstream
+    // consumers can still reason about placement.
+    let clamp_line = |value: usize| -> u16 { u16::try_from(value).unwrap_or(u16::MAX) };
     let line_range_for_fragmentation = |start: usize, end: usize| -> (u16, u16) {
       let start = start.max(1);
       let mut end = end.max(1);
       if end <= start {
         end = start.saturating_add(1);
       }
-      let start_u16 = match u16::try_from(start) {
-        Ok(line) => line,
-        Err(_) => {
-          grid_fragmentation_valid.set(false);
-          grid_fragmentation_valid.set(false);
-          u16::MAX
-        }
-      };
-      let mut end_u16 = match u16::try_from(end) {
-        Ok(line) => line,
-        Err(_) => {
-          grid_fragmentation_valid.set(false);
-          grid_fragmentation_valid.set(false);
-          u16::MAX
-        }
-      };
+      let mut start_u16 = clamp_line(start);
+      let mut end_u16 = clamp_line(end);
       if end_u16 <= start_u16 {
+        // When clamping forces start=end, widen to a minimal 1-track span. Preserve the largest
+        // possible values so callers can detect overflow while still getting a valid range.
         if start_u16 == u16::MAX {
-          grid_fragmentation_valid.set(false);
+          start_u16 = u16::MAX.saturating_sub(1);
+          end_u16 = u16::MAX;
         } else {
           end_u16 = start_u16.saturating_add(1);
         }
@@ -1534,8 +1593,14 @@ impl GridFormattingContext {
             mirror_range_in_span(range, row_axis_span)
           }
         });
-      let x_area = column_area;
-      let y_area = row_area;
+
+      // Convert CSS row/column areas into physical X/Y rectangles based on the resolved axis
+      // mapping for this grid container.
+      let (x_area, y_area) = if column_axis_is_horizontal {
+        (column_area, row_area)
+      } else {
+        (row_area, column_area)
+      };
       let x = padding_left + x_area.map(|(start, _)| start).unwrap_or(0.0);
       let y = y_area.map(|(start, _)| start).unwrap_or(0.0);
       let area_width = x_area
@@ -1771,73 +1836,10 @@ impl GridFormattingContext {
           line_range_for_fragmentation(row_start_line, row_end_line);
         let (row_start, row_end, column_start, column_end) =
           (css_row_start, css_row_end, css_col_start, css_col_end);
-        let mut item_valid = true;
-        if row_start == 0 || row_end <= row_start || column_start == 0 || column_end <= column_start {
-          tracing::debug!(
-            container_box_id = node.id(),
-            box_id = child.id,
-            row_start,
-            row_end,
-            column_start,
-            column_end,
-            "invalid grid placement line indices; skipping grid fragmentation metadata"
-          );
-          grid_fragmentation_valid.set(false);
-          item_valid = false;
-        }
-        if item_valid {
-          let row_span = row_end.saturating_sub(row_start);
-          let column_span = column_end.saturating_sub(column_start);
-          let expected_row_span = row_end_line.saturating_sub(row_start_line).max(1);
-          let expected_column_span = col_end_line.saturating_sub(col_start_line).max(1);
-          let expected_row_span = match u16::try_from(expected_row_span) {
-            Ok(span) => span,
-            Err(_) => {
-              grid_fragmentation_valid.set(false);
-              item_valid = false;
-              u16::MAX
-            }
-          };
-          let expected_column_span = match u16::try_from(expected_column_span) {
-            Ok(span) => span,
-            Err(_) => {
-              grid_fragmentation_valid.set(false);
-              item_valid = false;
-              u16::MAX
-            }
-          };
-          if item_valid && (row_span != expected_row_span || column_span != expected_column_span) {
-            grid_fragmentation_valid.set(false);
-            item_valid = false;
-          }
-          if item_valid {
-            debug_assert!(row_start >= 1, "grid row_start must be >= 1");
-            debug_assert!(row_end > row_start, "grid row_end must exceed row_start");
-            debug_assert!(
-              row_span >= 1,
-              "grid row span must be at least 1 (start={row_start}, end={row_end})"
-            );
-            debug_assert_eq!(
-              row_span,
-              expected_row_span,
-              "grid row span must match placement span"
-            );
-            debug_assert!(column_start >= 1, "grid column_start must be >= 1");
-            debug_assert!(
-              column_end > column_start,
-              "grid column_end must exceed column_start"
-            );
-            debug_assert!(
-              column_span >= 1,
-              "grid column span must be at least 1 (start={column_start}, end={column_end})"
-            );
-            debug_assert_eq!(
-              column_span,
-              expected_column_span,
-              "grid column span must match placement span"
-            );
-          }
-        }
+        debug_assert!(row_start >= 1, "grid row_start must be >= 1");
+        debug_assert!(row_end > row_start, "grid row_end must exceed row_start");
+        debug_assert!(column_start >= 1, "grid column_start must be >= 1");
+        debug_assert!(column_end > column_start, "grid column_end must exceed column_start");
         in_flow.push(InFlowFragment {
           order: child.style.order,
           dom_index,
@@ -1881,6 +1883,7 @@ impl GridFormattingContext {
       column_gap,
       mirror_width,
       mirror_height,
+      swap_subgrid_axes,
     );
     for (start, end) in grid_tracks.columns.iter_mut() {
       *start += padding_left;
@@ -1888,7 +1891,7 @@ impl GridFormattingContext {
     }
     debug_assert_grid_track_ranges_in_flow_order(&fragment, &grid_tracks);
     fragment.grid_tracks = Some(Arc::new(grid_tracks));
-    if grid_fragmentation_valid.get() && !auto_place_failed {
+    if !auto_place_failed {
       debug_assert_grid_fragmentation_children(&fragment, &items);
       fragment.grid_fragmentation = Some(Arc::new(GridFragmentationInfo {
         items,
@@ -1927,8 +1930,10 @@ fn place_children(
   column_line_names: Option<&[Vec<String>]>,
   row_line_names: Option<&[Vec<String>]>,
 ) -> (Vec<ChildPlacement>, usize, usize, bool) {
-  column_count = column_count.max(1);
-  row_count = row_count.max(1);
+  let max_tracks = usize::from(auto_placement::MAX_IMPLICIT_TRACKS);
+
+  column_count = column_count.max(1).min(max_tracks);
+  row_count = row_count.max(1).min(max_tracks);
 
   let explicit_rows = u16::try_from(row_count).unwrap_or(u16::MAX);
   let explicit_cols = u16::try_from(column_count).unwrap_or(u16::MAX);
@@ -2022,15 +2027,17 @@ fn place_children(
       .iter()
       .filter_map(|placed| placed.as_ref().map(|p| usize::from(p.col_end.saturating_sub(1))))
       .max()
-      .unwrap_or(0);
+      .unwrap_or(0)
+      .min(max_tracks);
     let placed_row_tracks = placements_by_dom_index
       .iter()
       .filter_map(|placed| placed.as_ref().map(|p| usize::from(p.row_end.saturating_sub(1))))
       .max()
-      .unwrap_or(0);
+      .unwrap_or(0)
+      .min(max_tracks);
 
-    column_count = column_count.max(placed_column_tracks);
-    row_count = row_count.max(placed_row_tracks);
+    column_count = column_count.max(placed_column_tracks).min(max_tracks);
+    row_count = row_count.max(placed_row_tracks).min(max_tracks);
   }
 
   let mut placements = Vec::with_capacity(children.len());
@@ -2086,8 +2093,8 @@ fn place_children(
     };
 
     if allow_extend && child.style.position != Position::Absolute {
-      row_count = row_count.max(row_end.saturating_sub(1));
-      column_count = column_count.max(col_end.saturating_sub(1));
+      row_count = row_count.max(row_end.saturating_sub(1).min(max_tracks));
+      column_count = column_count.max(col_end.saturating_sub(1).min(max_tracks));
     } else {
       col_end = col_end.min(column_count + 1);
       row_end = row_end.min(row_count + 1);
@@ -2692,6 +2699,7 @@ fn max_content_block_size(node: &BoxNode, containing_inline_size: f32) -> f32 {
   // padding). When probing intrinsic block sizes (e.g. for `height: fit-content` grid items), we
   // must therefore pass the grid area's *definite* inline size so that these ratios resolve.
   let padding_top = node.style.padding_top.resolve(containing_inline_size);
+  let padding_bottom = node.style.padding_bottom.resolve(containing_inline_size);
 
   let content_height = match node.style.display {
     // For nested layout containers we need a content-based block size that does not double-count
@@ -2725,14 +2733,9 @@ fn max_content_block_size(node: &BoxNode, containing_inline_size: f32) -> f32 {
       .iter()
       .map(|child| max_content_block_size(child, containing_inline_size))
       .sum(),
-    _ => node
-      .children
-      .iter()
-      .map(|child| max_content_block_size(child, containing_inline_size))
-      .sum(),
   };
 
-  padding_top + content_height
+  padding_top + padding_bottom + content_height
 }
 
 const CHAR_WIDTH_PX: f32 = 5.0;
@@ -2945,7 +2948,7 @@ fn resolve_length_px(
     .and_then(|len| len.resolve_px_with_fonts(percentage_base, font_size_px, root_font_size_px))
 }
 
-fn layout_block_tree(
+pub(crate) fn layout_block_tree(
   node: &BoxNode,
   containing_block_width: f32,
   containing_block_height: Option<f32>,
@@ -2953,10 +2956,15 @@ fn layout_block_tree(
   override_height: Option<f32>,
   override_height_percentage_base: Option<f32>,
 ) -> FragmentNode {
+  // This helper is a minimal block-layout approximation used by the grid snapshot when laying out
+  // nested formatting contexts. It is *not* a full block formatting context implementation, but it
+  // must handle the box model well enough for percentage padding + intrinsic sizing tests.
+  let containing_block_width = containing_block_width.max(0.0);
+
   // CSS2.1 §8.1.1 + §10.5: percentage padding values resolve against the containing block width,
   // even when applied to the vertical axis. Keep this consistent with the main renderer so
   // `height: fit-content` probes inside grid/flex containers observe percentage padding correctly.
-  let padding_percentage_base = Some(containing_block_width.max(0.0));
+  let padding_percentage_base = Some(containing_block_width);
   let padding_left = resolve_length_px(
     Some(&node.style.padding_left),
     padding_percentage_base,
@@ -2965,6 +2973,14 @@ fn layout_block_tree(
   )
   .unwrap_or(0.0)
   .max(0.0);
+  let padding_right = resolve_length_px(
+    Some(&node.style.padding_right),
+    padding_percentage_base,
+    node.style.font_size,
+    node.style.root_font_size,
+  )
+  .unwrap_or(0.0)
+  .max(0.0);
   let padding_top = resolve_length_px(
     Some(&node.style.padding_top),
     padding_percentage_base,
@@ -2981,18 +2997,27 @@ fn layout_block_tree(
   )
   .unwrap_or(0.0)
   .max(0.0);
+  let padding_inline = padding_left + padding_right;
+  let padding_block = padding_top + padding_bottom;
+
+  let specified_width = resolve_length_px(
+    node.style.width.as_ref(),
+    Some(containing_block_width),
+    node.style.font_size,
+    node.style.root_font_size,
+  )
+  .map(|v| v.max(0.0));
 
   let used_width = override_width
-    .or_else(|| {
-      resolve_length_px(
-        node.style.width.as_ref(),
-        Some(containing_block_width),
-        node.style.font_size,
-        node.style.root_font_size,
-      )
-    })
-    .unwrap_or(containing_block_width)
-    .max(0.0);
+    .map(|v| v.max(0.0))
+    .unwrap_or_else(|| {
+      specified_width
+        .map(|value| border_box_size_from_box_sizing(value, padding_inline, node.style.box_sizing))
+        .unwrap_or(containing_block_width)
+        .max(0.0)
+    });
+
+  let content_width = (used_width - padding_inline).max(0.0);
 
   let override_height = override_height.map(|v| v.max(0.0));
   let resolved_style_height = resolve_length_px(
@@ -3002,20 +3027,31 @@ fn layout_block_tree(
     node.style.root_font_size,
   )
   .map(|v| v.max(0.0));
-  let specified_height = override_height.or(resolved_style_height);
+  let specified_height = override_height.or_else(|| {
+    resolved_style_height.map(|value| {
+      border_box_size_from_box_sizing(value, padding_block, node.style.box_sizing)
+    })
+  });
 
   // CSS2.1 §10.5: percentage heights only resolve when the containing block height is definite.
+  // - When this node has an authored height, descendants can use it as their percentage base.
+  // - When this node is stretched by an external formatting context (e.g. a definite grid track),
+  //   descendants may only resolve percentages when the caller supplies `override_height_percentage_base`.
   let child_percentage_base = if resolved_style_height.is_some() {
-    specified_height
+    let content_height = match node.style.box_sizing {
+      BoxSizing::ContentBox => resolved_style_height,
+      BoxSizing::BorderBox => resolved_style_height.map(|h| (h - padding_block).max(0.0)),
+    };
+    content_height
   } else {
-    override_height_percentage_base
+    override_height_percentage_base.map(|base| (base - padding_block).max(0.0))
   };
 
   let mut y_cursor = padding_top;
   let mut children = Vec::with_capacity(node.children.len());
   for child in &node.children {
     let mut child_fragment =
-      layout_block_tree(child, used_width, child_percentage_base, None, None, None);
+      layout_block_tree(child, content_width, child_percentage_base, None, None, None);
     let child_bounds = child_fragment.bounds;
     child_fragment.bounds = Rect::new(
       padding_left,
@@ -3223,6 +3259,10 @@ fn axis_auto_placement_spec(
         .and_then(|v| u16::try_from(v).ok())
     })
     .or_else(|| match (&placement.start, &placement.end) {
+      (GridPlacement::Span(span), GridPlacement::Auto)
+      | (GridPlacement::Auto, GridPlacement::Span(span)) => Some(*span),
+      (GridPlacement::NamedSpan(_, span), GridPlacement::Auto)
+      | (GridPlacement::Auto, GridPlacement::NamedSpan(_, span)) => Some(*span),
       (GridPlacement::Line(_) | GridPlacement::NamedLine(_, _), GridPlacement::Span(span))
       | (GridPlacement::Span(span), GridPlacement::Line(_) | GridPlacement::NamedLine(_, _)) => Some(*span),
       (GridPlacement::Line(_) | GridPlacement::NamedLine(_, _), GridPlacement::NamedSpan(name, span)) => {
@@ -3486,35 +3526,6 @@ fn resolve_track_sizes(
     constraint: None,
   };
   resolve_flexible_track_sizes(ctx, &mut resolved, items);
-
-  // CSS Grid "stretch auto tracks": if we have definite available space and no flexible tracks
-  // consume it, distribute remaining free space across tracks with an `auto` min-sizing function.
-  //
-  // This is important for the common `grid-template: none` case where implicit `auto` tracks must
-  // still occupy the container (e.g. a grid with an aspect-ratio-derived block size).
-  if let Some(available) = available_grid_space {
-    let used_space: f32 = resolved.iter().map(|track| track.base_size).sum();
-    let free_space = (available - used_space).max(0.0);
-    if free_space > 0.0 {
-      // Only "auto" tracks participate in this stretch-to-fill behavior. `min-content` and
-      // `max-content` tracks should size to their intrinsic contributions and let
-      // `align-content`/`justify-content` decide how to distribute remaining free space.
-      let auto_track_indices: Vec<usize> = expanded_tracks
-        .iter()
-        .enumerate()
-        .filter_map(|(idx, track)| matches!(track, GridTrack::Auto).then_some(idx))
-        .collect();
-      if !auto_track_indices.is_empty() {
-        let share = free_space / auto_track_indices.len() as f32;
-        for idx in auto_track_indices {
-          if let Some(track) = resolved.get_mut(idx) {
-            track.base_size += share;
-          }
-        }
-      }
-    }
-  }
-
   resolved.into_iter().map(|t| t.base_size).collect()
 }
 
@@ -3935,18 +3946,21 @@ mod tests {
       .expect("grid fragmentation info");
     assert_eq!(info.items.len(), 2);
     let tracks = fragment.grid_tracks.as_ref().expect("grid track ranges");
-    assert_eq!(tracks.columns.len(), 3);
+    // Grid track ranges are stored in physical axis order:
+    // - `columns` are the physical X axis (CSS rows in vertical writing modes)
+    // - `rows` are the physical Y axis (CSS columns in vertical writing modes)
+    assert_eq!(tracks.columns.len(), 2);
     for (start, end) in &tracks.columns {
       assert!(
-        (end - start - 10.0).abs() <= 0.01,
-        "expected 10px column track length, got {start}..{end}"
+        (end - start - 20.0).abs() <= 0.01,
+        "expected 20px row track length, got {start}..{end}"
       );
     }
-    assert_eq!(tracks.rows.len(), 2);
+    assert_eq!(tracks.rows.len(), 3);
     for (start, end) in &tracks.rows {
       assert!(
-        (end - start - 20.0).abs() <= 0.01,
-        "expected 20px row track length, got {start}..{end}"
+        (end - start - 10.0).abs() <= 0.01,
+        "expected 10px column track length, got {start}..{end}"
       );
     }
 
@@ -4646,16 +4660,20 @@ mod tests {
       .layout(&grid, &LayoutConstraints::definite(200.0, 200.0))
       .expect("layout succeeds");
 
-    // For vertical writing modes, physical width follows columns and physical height follows rows.
-    assert_approx(fragment.bounds.width(), 12.0, "vertical-rl physical width");
-    assert_approx(fragment.bounds.height(), 35.0, "vertical-rl physical height");
+    // For vertical writing modes, CSS grid rows map to the physical X axis (block axis), and
+    // CSS grid columns map to the physical Y axis (inline axis). The container's physical width
+    // therefore follows the row track sizes, and the physical height follows the column track
+    // sizes.
+    assert_approx(fragment.bounds.width(), 35.0, "vertical-rl physical width");
+    assert_approx(fragment.bounds.height(), 12.0, "vertical-rl physical height");
 
     let tracks = fragment.grid_tracks.as_deref().expect("grid tracks");
-    // `columns` are physical X tracks (block axis for vertical writing modes) and should be mirrored
+    // `columns` are physical X tracks (CSS rows for vertical writing modes) and should be mirrored
     // for `vertical-rl` (block-start is at the physical right edge).
-    assert_eq!(tracks.columns, vec![(0.0, 12.0)]);
-    // `rows` are physical Y tracks (inline axis); `direction:ltr` keeps them increasing.
-    assert_eq!(tracks.rows, vec![(0.0, 10.0), (15.0, 35.0)]);
+    assert_eq!(tracks.columns, vec![(25.0, 35.0), (0.0, 20.0)]);
+    // `rows` are physical Y tracks (CSS columns for vertical writing modes); `direction:ltr` keeps
+    // them increasing.
+    assert_eq!(tracks.rows, vec![(0.0, 12.0)]);
   }
 
   #[test]
@@ -4765,17 +4783,18 @@ mod tests {
 
     assert_eq!(fragment.children.len(), 3);
     // Inline size is the physical height in vertical writing modes (200px => 20px gaps). Column
-    // gaps use that inline size but advance along the block axis (physical X). `vertical-rl`
-    // mirrors the block axis, so the second column starts at 100px - (10px + 20px + 10px) = 60px.
+    // gaps advance along the inline axis (physical Y) while row gaps advance along the block axis
+    // (physical X). `vertical-rl` mirrors the block axis, so the second row starts at
+    // 100px - (10px + 20px + 10px) = 60px.
     assert_approx(
-      fragment.children[1].bounds.x(),
-      60.0,
-      "column gap uses inline size (height) in vertical writing mode",
+      fragment.children[1].bounds.y(),
+      30.0,
+      "column gap uses inline size (height) in vertical writing mode (physical y)",
     );
     assert_approx(
-      fragment.children[2].bounds.y(),
-      30.0,
-      "row gap uses inline size (height) in vertical writing mode",
+      fragment.children[2].bounds.x(),
+      60.0,
+      "row gap uses inline size (height) in vertical writing mode (mirrored for vertical-rl)",
     );
   }
 
diff --git a/src/layout_engine/layout/contexts/grid/auto_placement.rs b/src/layout_engine/layout/contexts/grid/auto_placement.rs
index 836afe17ef..cbd355f6b8 100644
--- a/src/layout_engine/layout/contexts/grid/auto_placement.rs
+++ b/src/layout_engine/layout/contexts/grid/auto_placement.rs
@@ -10,7 +10,7 @@
 
 use std::fmt;
 
-const MAX_IMPLICIT_TRACKS: u16 = 10_000;
+pub(crate) const MAX_IMPLICIT_TRACKS: u16 = 10_000;
 const DEADLINE_CHECK_STRIDE: usize = 64;
 
 /// `grid-auto-flow` direction and packing behavior.
@@ -97,7 +97,7 @@ struct AxisResolved {
 impl AxisResolved {
   #[inline]
   fn is_definite(self) -> bool {
-    self.start.is_some()
+    self.start.is_some() && self.end.is_some()
   }
 }
 
@@ -133,12 +133,10 @@ impl OccupiedGrid {
   }
 
   fn ensure_rows(&mut self, desired_tracks: u16) -> Result<(), AutoPlacementError> {
+    let desired_tracks = desired_tracks.min(MAX_IMPLICIT_TRACKS);
     if desired_tracks <= self.row_tracks {
       return Ok(());
     }
-    if desired_tracks > MAX_IMPLICIT_TRACKS {
-      return Err(too_large_error("row", desired_tracks));
-    }
     let additional = desired_tracks - self.row_tracks;
     self
       .occupied_cols_by_row
@@ -148,12 +146,10 @@ impl OccupiedGrid {
   }
 
   fn ensure_cols(&mut self, desired_tracks: u16) -> Result<(), AutoPlacementError> {
+    let desired_tracks = desired_tracks.min(MAX_IMPLICIT_TRACKS);
     if desired_tracks <= self.col_tracks {
       return Ok(());
     }
-    if desired_tracks > MAX_IMPLICIT_TRACKS {
-      return Err(too_large_error("column", desired_tracks));
-    }
     self.col_tracks = desired_tracks;
     Ok(())
   }
@@ -165,6 +161,19 @@ impl OccupiedGrid {
     col_start: u16,
     col_end: u16,
   ) -> bool {
+    if row_start < 1 || col_start < 1 {
+      return false;
+    }
+    if row_start > self.row_tracks || col_start > self.col_tracks {
+      return false;
+    }
+
+    let row_end = row_end.min(self.row_tracks.saturating_add(1));
+    let col_end = col_end.min(self.col_tracks.saturating_add(1));
+    if row_end <= row_start || col_end <= col_start {
+      return false;
+    }
+
     for row_line in row_start..row_end {
       let idx = (row_line - 1) as usize;
       let Some(intervals) = self.occupied_cols_by_row.get(idx) else {
@@ -178,6 +187,19 @@ impl OccupiedGrid {
   }
 
   fn mark_occupied(&mut self, row_start: u16, row_end: u16, col_start: u16, col_end: u16) {
+    if row_start < 1 || col_start < 1 {
+      return;
+    }
+    if row_start > self.row_tracks || col_start > self.col_tracks {
+      return;
+    }
+
+    let row_end = row_end.min(self.row_tracks.saturating_add(1));
+    let col_end = col_end.min(self.col_tracks.saturating_add(1));
+    if row_end <= row_start || col_end <= col_start {
+      return;
+    }
+
     for row_line in row_start..row_end {
       let idx = (row_line - 1) as usize;
       if let Some(intervals) = self.occupied_cols_by_row.get_mut(idx) {
@@ -244,17 +266,28 @@ fn resolve_axis(placement: GridAxisPlacement, span: u16, explicit_tracks: u16) -
     (None, None) => (None, None),
   };
 
-  let start = start.and_then(|v| u16::try_from(v).ok()).filter(|v| *v >= 1);
-  let end = end.and_then(|v| u16::try_from(v).ok()).filter(|v| *v >= 2);
+  #[inline]
+  fn clamp_line(value: i32, min_value: u16) -> u16 {
+    let min_value_i32 = i32::from(min_value);
+    if value <= min_value_i32 {
+      return min_value;
+    }
+    if value >= i32::from(u16::MAX) {
+      return u16::MAX;
+    }
+    value as u16
+  }
+
+  let start = start.map(|v| clamp_line(v, 1));
+  let end = end.map(|v| clamp_line(v, 2));
 
   AxisResolved { start, end, span }
 }
 
 #[inline]
-fn add_span(start: u16, span: u16) -> Result<u16, AutoPlacementError> {
+fn add_span(start: u16, span: u16) -> u16 {
   let span = span.max(1);
-  let end = u32::from(start) + u32::from(span);
-  u16::try_from(end).map_err(|_| too_large_error("track", u16::MAX))
+  start.saturating_add(span)
 }
 
 #[inline]
@@ -405,8 +438,12 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
     .unwrap_or(1)
     .max(1);
 
-  let initial_rows = explicit_rows.max(1).max(max_row_span);
-  let initial_cols = explicit_cols.max(1).max(max_col_span);
+  let initial_rows = explicit_rows
+    .max(1)
+    .max(max_row_span.min(MAX_IMPLICIT_TRACKS));
+  let initial_cols = explicit_cols
+    .max(1)
+    .max(max_col_span.min(MAX_IMPLICIT_TRACKS));
   if initial_rows > MAX_IMPLICIT_TRACKS {
     return Err(too_large_error("row", initial_rows));
   }
@@ -469,7 +506,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
     let mut col_start = row_locked_cursor_col.max(1);
     loop {
       deadline_tick(check_deadline, &mut deadline_counter)?;
-      let col_end = add_span(col_start, col_span)?;
+      let col_end = add_span(col_start, col_span);
       grid.ensure_cols(col_end.saturating_sub(1))?;
       if grid.area_is_free(row_start, row_end, col_start, col_end) {
         grid.mark_occupied(row_start, row_end, col_start, col_end);
@@ -480,7 +517,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
           col_start,
           col_end,
         });
-        row_locked_cursor_col = col_end;
+        row_locked_cursor_col = col_end.min(MAX_IMPLICIT_TRACKS);
         break;
       }
       col_start = col_start.saturating_add(1);
@@ -510,7 +547,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
     if let Some(col_start) = item.col.start {
       // Column-locked item: find a row for this definite column.
       let col_start = col_start.max(1);
-      let col_end = add_span(col_start, col_span)?;
+      let col_end = add_span(col_start, col_span);
       grid.ensure_cols(col_end.saturating_sub(1))?;
 
       if !dense && col_start < cursor_col {
@@ -520,7 +557,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
       let mut row_start = cursor_row.max(1);
       loop {
         deadline_tick(check_deadline, &mut deadline_counter)?;
-        let row_end = add_span(row_start, row_span)?;
+        let row_end = add_span(row_start, row_span);
         grid.ensure_rows(row_end.saturating_sub(1))?;
 
         if grid.area_is_free(row_start, row_end, col_start, col_end) {
@@ -533,7 +570,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
             col_end,
           });
           cursor_row = row_start;
-          cursor_col = col_end;
+          cursor_col = col_end.min(MAX_IMPLICIT_TRACKS);
           break;
         }
 
@@ -553,7 +590,11 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
       loop {
         deadline_tick(check_deadline, &mut deadline_counter)?;
 
-        if col_start.saturating_add(col_span).saturating_sub(1) > grid.col_tracks {
+        let col_span_for_fit = col_span.max(1).min(grid.col_tracks.max(1));
+        if col_start
+          .saturating_add(col_span_for_fit)
+          .saturating_sub(1) > grid.col_tracks
+        {
           row_start = row_start.saturating_add(1);
           col_start = 1;
           if row_start > MAX_IMPLICIT_TRACKS {
@@ -562,8 +603,8 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
           continue;
         }
 
-        let row_end = add_span(row_start, row_span)?;
-        let col_end = add_span(col_start, col_span)?;
+        let row_end = add_span(row_start, row_span);
+        let col_end = add_span(col_start, col_span);
         grid.ensure_rows(row_end.saturating_sub(1))?;
         grid.ensure_cols(col_end.saturating_sub(1))?;
 
@@ -577,7 +618,7 @@ fn auto_place_row_flow<F: FnMut() -> Result<(), AutoPlacementError>>(
             col_end,
           });
           cursor_row = row_start;
-          cursor_col = col_end;
+          cursor_col = col_end.min(MAX_IMPLICIT_TRACKS);
           break;
         }
 
diff --git a/src/network_process/websocket_runtime.rs b/src/network_process/websocket_runtime.rs
index 27e442151d..0e9e392129 100644
--- a/src/network_process/websocket_runtime.rs
+++ b/src/network_process/websocket_runtime.rs
@@ -42,6 +42,7 @@ use crate::resource::{
   ResourceFetcher,
 };
 use std::collections::{HashMap, VecDeque};
+use std::io::Write;
 use std::net::TcpStream;
 use std::sync::atomic::{AtomicUsize, Ordering};
 use std::sync::mpsc;
diff --git a/src/ui/url.rs b/src/ui/url.rs
index bc0ad19324..fd2468155f 100644
--- a/src/ui/url.rs
+++ b/src/ui/url.rs
@@ -66,7 +66,7 @@ pub fn validate_user_navigation_url_scheme(url: &str) -> Result<(), String> {
     ));
   }
 
-  let parsed = fastrender_url::Url::parse(url).map_err(|err| format!("invalid URL: {err}"))?;
+  let parsed = Url::parse(url).map_err(|err| format!("invalid URL: {err}"))?;
   let scheme = parsed.scheme();
   if matches!(scheme, "chrome" | "chrome-action" | "chrome-dialog") {
     return Err(format!("unsupported URL scheme: {scheme}"));
diff --git a/tests/guards/docs_conformance_presence.rs b/tests/guards/docs_conformance_presence.rs
index 6b06beb404..4293afa8a8 100644
--- a/tests/guards/docs_conformance_presence.rs
+++ b/tests/guards/docs_conformance_presence.rs
@@ -275,17 +275,19 @@ fn conformance_doc_does_not_mention_blocked_backend_crates() {
   let conformance_path = root.join("docs/conformance.md");
   let content = std::fs::read_to_string(&conformance_path).expect("read docs/conformance.md");
 
-  let blocked_re = regex::Regex::new(concat!(
-    r"(?i)\b(taffy|tiny[-_ ]?skia|rusty[-_ ]?buzz|rquickjs|quickjs|",
-    "access",
-    "kit",
-    r")\b",
-  ))
-  .expect("blocked backend regex should compile");
+  let blocked_backends = [
+    "taffy",
+    "tiny[-_ ]?skia",
+    "rusty[-_ ]?buzz",
+    concat!("r", "quick", "js"),
+    concat!("quick", "js"),
+    concat!("access", "kit"),
+  ];
+  let pattern = format!(r"(?i)\b({})\b", blocked_backends.join("|"));
+  let blocked_re = regex::Regex::new(&pattern).expect("blocked backend regex should compile");
 
   assert!(
     !blocked_re.is_match(&content),
-    "docs/conformance.md should not mention blocked backend crates (taffy/tiny-skia/rustybuzz/QuickJS/{}).",
-    concat!("access", "kit")
+    "docs/conformance.md should not mention blocked backend crates (taffy/tiny-skia/rustybuzz/QuickJS/a11y shim)."
   );
 }
-- 
2.43.0

