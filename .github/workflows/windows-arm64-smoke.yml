name: Windows ARM64 (Tauri) smoke

on:
  workflow_dispatch:
  schedule:
    # Weekly (Monday 05:23 UTC) so we detect runner image/toolchain regressions
    # even when no desktop-related PRs are landing.
    - cron: "23 5 * * 1"
  push:
    branches: [main]
    paths:
      - "apps/desktop/**"
      - "crates/**"
      - "packages/**"
      - "scripts/ci/**"
      - "scripts/desktop_dist_asset_report.mjs"
      - "Cargo.lock"
      - "rust-toolchain.toml"
      - ".github/workflows/windows-arm64-smoke.yml"
      - ".github/workflows/release.yml"
  pull_request:
    paths:
      - "apps/desktop/**"
      - "crates/**"
      - "packages/**"
      - "scripts/ci/**"
      - "scripts/desktop_dist_asset_report.mjs"
      - "Cargo.lock"
      - "rust-toolchain.toml"
      - ".github/workflows/windows-arm64-smoke.yml"
      - ".github/workflows/release.yml"

jobs:
  windows-arm64:
    name: Build + bundle (aarch64-pc-windows-msvc)
    # Avoid spending compute on scheduled runs in forks.
    if: github.event_name != 'schedule' || github.repository == 'wilson-anysphere/formula'
    # Pin runner image versions for reproducibility. GitHub's `*-latest` labels move
    # over time, which can unexpectedly break desktop packaging workflows.
    #
    # Update this pin only after validating the workflow succeeds on the newer runner
    # images (see https://github.com/actions/runner-images).
    runs-on: windows-2022

    env:
      # Keep this aligned with the pinned versions in `.github/workflows/release.yml`
      # so the smoke workflow catches the same toolchain regressions that would
      # break tagged releases.
      NODE_VERSION: 22
      PNPM_VERSION: 9.0.0
      WASM_PACK_VERSION: 0.13.1
      TAURI_CLI_VERSION: 2.9.5
      # Opt-in: bundle Pyodide assets into `apps/desktop/dist` (otherwise Pyodide is downloaded
      # on-demand at runtime and cached in the app data directory).
      FORMULA_BUNDLE_PYODIDE_ASSETS: ${{ vars.FORMULA_BUNDLE_PYODIDE_ASSETS }}

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      # Ensure all Cargo builds (including `cargo tauri build`) emit artifacts under the
      # expected path `apps/desktop/src-tauri/target/**`. This keeps validations deterministic
      # and matches the tagged release workflow expectations.
      - name: Set CARGO_TARGET_DIR for desktop builds (Windows)
        shell: pwsh
        run: |
          $targetDir = Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target'
          "CARGO_TARGET_DIR=$targetDir" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: "Guard: Rust toolchain pins match rust-toolchain.toml"
        shell: bash
        run: bash scripts/ci/check-rust-toolchain-pins.sh

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Check pinned Tauri CLI version matches Tauri crates
        run: node scripts/ci/check-tauri-cli-version.mjs

      - name: Validate desktop compliance artifact bundling config (LICENSE/NOTICE)
        run: node scripts/ci/check-desktop-compliance-artifacts.mjs

      - name: "Guard: Windows Authenticode timestamp URL uses HTTPS"
        run: node scripts/ci/check-windows-timestamp-url.mjs

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@e97e2d8cc328f1b50210efc529dca0028893a2d9 # v1
        with:
          toolchain: 1.92.0

      - name: Setup Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Check Cargo.lock is up-to-date (no implicit lockfile updates)
        shell: bash
        run: bash scripts/ci/check-cargo-lock-reproducible.sh

      - name: Fail if preflight modified tracked files
        shell: bash
        run: git diff --exit-code

      - name: Install Rust targets (wasm32 + Windows ARM64)
        run: rustup target add wasm32-unknown-unknown aarch64-pc-windows-msvc

      - name: Ensure MSVC ARM64 components are installed
        id: windows_arm64_toolchain
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (!(Test-Path $vswhere)) {
            throw "vswhere not found at $vswhere (expected on windows-2022)."
          }
          $installPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (!$installPath) {
            throw "Failed to locate a Visual Studio installation via vswhere."
          }
          Write-Host "Visual Studio install path: $installPath"
          $msvcRoot = Join-Path $installPath "VC\Tools\MSVC"
          $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (!$msvcVersionDir) {
            throw "MSVC toolset directory not found under $msvcRoot"
          }
          $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
          $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
          $arm64Cl = Join-Path $arm64BinDir "cl.exe"
          $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          $hasArm64Toolchain = (Test-Path $arm64LibDir) -and (Test-Path $arm64Cl) -and (Test-Path $arm64LinkExe)

          if (-not $hasArm64Toolchain) {
            Write-Host "MSVC ARM64 toolchain not found; installing Visual Studio component Microsoft.VisualStudio.Component.VC.Tools.ARM64"
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            & $vsInstaller modify --installPath $installPath --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --includeRecommended --passive --norestart
            $exitCode = $LASTEXITCODE
            # 3010 is a common "success, reboot required" code for Windows installers.
            if ($exitCode -ne 0 -and $exitCode -ne 3010) {
              throw "vs_installer.exe failed with exit code $exitCode while installing MSVC ARM64 components."
            }

            $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
            $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
            $arm64Cl = Join-Path $arm64BinDir "cl.exe"
            $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          }

          if (!(Test-Path $arm64LibDir) -or !(Test-Path $arm64Cl) -or !(Test-Path $arm64LinkExe)) {
            throw "MSVC ARM64 build tools were not found. Expected:\n  - $arm64LibDir\n  - $arm64Cl\n  - $arm64LinkExe\nGitHub-hosted runners may not include the required MSVC ARM64 workload; use a self-hosted runner with ARM64 build tools preinstalled."
          }

          Write-Host "MSVC ARM64 tools present:"
          Write-Host "  - libs: $arm64LibDir"
          Write-Host "  - cl.exe: $arm64Cl"
          Write-Host "  - link.exe: $arm64LinkExe"

          $sdkLibRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\Lib"
          if (!(Test-Path $sdkLibRoot)) {
            throw "Windows SDK lib root not found at $sdkLibRoot. Windows ARM64 builds require the Windows 10/11 SDK with ARM64 libraries."
          }

          function Find-SdkArm64($root) {
            $dirs = @(Get-ChildItem -Path $root -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending)
            foreach ($dir in $dirs) {
              $um = Join-Path $dir.FullName "um\arm64"
              $ucrt = Join-Path $dir.FullName "ucrt\arm64"
              if ((Test-Path $um) -and (Test-Path $ucrt)) {
                return [pscustomobject]@{ VersionDir = $dir; Um = $um; Ucrt = $ucrt; AllDirs = $dirs }
              }
            }
            return [pscustomobject]@{ VersionDir = $null; Um = $null; Ucrt = $null; AllDirs = $dirs }
          }

          $sdkInfo = Find-SdkArm64 $sdkLibRoot
          if (-not $sdkInfo.AllDirs -or $sdkInfo.AllDirs.Count -eq 0) {
            throw "No Windows SDK lib versions found under $sdkLibRoot. Windows ARM64 builds require a Windows SDK installation with ARM64 libraries."
          }

          if (-not $sdkInfo.VersionDir) {
            $candidateName = $sdkInfo.AllDirs[0].Name
            $sdkBuild = $null
            if ($candidateName -match '^10\.0\.(\d+)\.\d+$') {
              $sdkBuild = $Matches[1]
            }
            if (-not $sdkBuild) {
              $sdkBuild = "20348"
            }

            $sdkComponents = @(
              "Microsoft.VisualStudio.Component.Windows10SDK.$sdkBuild",
              "Microsoft.VisualStudio.Component.Windows11SDK.$sdkBuild"
            ) | Select-Object -Unique
            Write-Host "Windows SDK ARM64 libs not found; attempting to install one of:"
            $sdkComponents | ForEach-Object { Write-Host "  - $_" }
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            $installErrors = @()
            foreach ($sdkComponent in $sdkComponents) {
              Write-Host "Installing Windows SDK component: $sdkComponent"
              & $vsInstaller modify --installPath $installPath --add $sdkComponent --includeRecommended --passive --norestart
              $exitCode = $LASTEXITCODE
              # 3010 is a common "success, reboot required" code for Windows installers.
              if ($exitCode -ne 0 -and $exitCode -ne 3010) {
                $installErrors += "$sdkComponent (exit code $exitCode)"
                continue
              }
              $sdkInfo = Find-SdkArm64 $sdkLibRoot
              if ($sdkInfo.VersionDir) {
                break
              }
            }

            if (-not $sdkInfo.VersionDir -and $installErrors.Count -gt 0) {
              Write-Host "Windows SDK component install attempts failed:"
              $installErrors | ForEach-Object { Write-Host "  - $_" }
            }
          }

          if (-not $sdkInfo.VersionDir) {
            throw "Windows SDK ARM64 UM/UCRT libraries were not found under $sdkLibRoot. The runner image may be missing the Windows SDK ARM64 components."
          }

          $sdkVersionDir = $sdkInfo.VersionDir
          $sdkUmArm64 = $sdkInfo.Um
          $sdkUcrtArm64 = $sdkInfo.Ucrt

          # Ensure the MSVC environment setup uses a Windows SDK version that actually includes
          # ARM64 UM/UCRT libraries. Hosted runner images can occasionally have multiple SDK
          # versions installed, and the newest one may be incomplete. We pin msvc-dev-cmd to the
          # discovered version so cross-compiles link reliably.
          if ($env:GITHUB_OUTPUT) {
            "sdk_version=$($sdkVersionDir.Name)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          Write-Host "windows-arm64-toolchain: OK"
          Write-Host " - MSVC: $($msvcVersionDir.FullName)"
          Write-Host " - link.exe: $arm64LinkExe"
          Write-Host " - MSVC lib: $arm64LibDir"
          Write-Host " - SDK um/arm64: $sdkUmArm64"
          Write-Host " - SDK ucrt/arm64: $sdkUcrtArm64"

      - name: Install WiX Toolset (required for MSI builds)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $candle = Get-Command candle.exe -ErrorAction SilentlyContinue
          $light = Get-Command light.exe -ErrorAction SilentlyContinue
          if (-not $candle -or -not $light) {
            choco install wixtoolset --yes --no-progress
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          # Add common WiX install locations to PATH for subsequent steps.
          $wixRoots = Get-ChildItem -Path (Join-Path ${env:ProgramFiles(x86)} "WiX Toolset v*") -Directory -ErrorAction SilentlyContinue
          foreach ($root in $wixRoots) {
            $bin = Join-Path $root.FullName "bin"
            if (Test-Path $bin) {
              $env:PATH = "$bin;$env:PATH"
              $bin | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
            }
          }

          if (-not (Get-Command candle.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: candle.exe not found on PATH."
          }
          if (-not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: light.exe not found on PATH."
          }

      - name: Install NSIS (required for NSIS .exe bundling)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            choco install nsis --no-progress -y
          }

          $nsisHome = "${env:ProgramFiles(x86)}\NSIS"
          if (Test-Path $nsisHome) {
            # Ensure the tool is visible in the current step (and persist it for later steps).
            $env:PATH = "$nsisHome;$env:PATH"
            $nsisHome | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          }
          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            throw "NSIS installation failed: makensis.exe not found on PATH."
          }

      - name: Install 7-Zip (required for NSIS payload validation)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Get-Command 7z.exe -ErrorAction SilentlyContinue)) {
            choco install 7zip --no-progress -y
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }
          if (-not (Get-Command 7z.exe -ErrorAction SilentlyContinue)) {
            throw "7-Zip installation failed: 7z.exe not found on PATH."
          }

      - name: Install JS dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/.cargo/bin/wasm-pack*
          # Include the Rust toolchain pin so Rust upgrades force rebuilding cargo-installed tools.
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Cache wasm-pack tool downloads (Windows)
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ${{ env.LOCALAPPDATA }}/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        # Use --force so cache restore-keys (or other CI caches) can't strand a stale/untracked
        # wasm-pack binary that would otherwise block `cargo install` from overwriting it.
        run: cargo install wasm-pack --version ${{ env.WASM_PACK_VERSION }} --locked --force

      - name: Verify wasm-pack version
        shell: bash
        run: |
          set -euo pipefail
          expected="${WASM_PACK_VERSION}"
          actual="$(wasm-pack --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected wasm-pack ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache pinned Tauri CLI binary (cargo-tauri)
        id: tauri-cli-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/.cargo/bin/cargo-tauri*
          # Include the Rust toolchain pin so Rust upgrades force rebuilding cargo-installed tools.
          key: cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install tauri-cli (installs the `cargo tauri` subcommand)
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ${{ env.TAURI_CLI_VERSION }} --locked --force

      - name: Verify Tauri CLI version
        shell: bash
        run: |
          set -euo pipefail
          expected="${TAURI_CLI_VERSION}"
          actual="$(cargo tauri --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected cargo-tauri ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Print Tauri CLI version
        run: cargo tauri --version

      - name: Cache Tauri tooling downloads
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          # Tauri's cache directory lives under %LOCALAPPDATA% on Windows.
          path: ${{ env.LOCALAPPDATA }}/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Detect Pyodide version (for caching)
        id: pyodide
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        shell: bash
        run: |
          set -euo pipefail
          version="$(node -e "const fs=require('node:fs'); const src=fs.readFileSync('apps/desktop/scripts/ensure-pyodide-assets.mjs','utf8'); const m=src.match(/const\\s+PYODIDE_VERSION\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/); if(!m) throw new Error('PYODIDE_VERSION not found'); process.stdout.write(m[1]);")"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Restore Pyodide asset cache
        id: pyodide-cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        uses: actions/cache/restore@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Ensure Pyodide assets are present
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        run: node apps/desktop/scripts/ensure-pyodide-assets.mjs

      - name: Save Pyodide asset cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1' && steps.pyodide-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Setup MSVC cross-compilation environment (amd64 â†’ arm64)
        uses: ilammy/msvc-dev-cmd@0b201ec74fa43914dc39ae48a89fd1d8cb592756 # v1.13.0
        with:
          arch: amd64_arm64
          sdk: ${{ steps.windows_arm64_toolchain.outputs.sdk_version }}

      - name: Build Windows ARM64 bundles (MSI + NSIS)
        run: |
          cd apps/desktop
          cargo tauri build --target aarch64-pc-windows-msvc --bundles msi,nsis

      - name: Verify desktop binary is stripped (no symbols)
        run: python scripts/verify_desktop_binary_stripped.py

      - name: Desktop dist asset report
        run: node scripts/desktop_dist_asset_report.mjs --json-out desktop-dist-assets-report.json
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Upload desktop dist asset report (JSON)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: windows-arm64-desktop-dist-assets-report
          path: desktop-dist-assets-report.json
          if-no-files-found: ignore

      - name: Verify compiled desktop executable is ARM64
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "aarch64-pc-windows-msvc"
          $releaseDir = "apps/desktop/src-tauri/target/$target/release"
          if (!(Test-Path $releaseDir)) {
            throw "Expected Rust release directory not found: $releaseDir"
          }
          # Avoid scanning the entire Cargo target release directory (can be large in CI). The binary
          # is expected at <releaseDir>/formula-desktop.exe; fall back to a recursive search only if
          # the direct path is missing (defensive against unusual build layouts).
          $exePath = Join-Path $releaseDir "formula-desktop.exe"
          if (Test-Path $exePath) {
            $exe = Get-Item -LiteralPath $exePath
          } else {
            $exe = Get-ChildItem -Path $releaseDir -Recurse -File -Filter "formula-desktop.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          }
          if (-not $exe) {
            throw "Expected compiled binary formula-desktop.exe not found under: $releaseDir"
          }
          $dumpbin = Get-Command dumpbin.exe -ErrorAction SilentlyContinue
          if (-not $dumpbin) {
            throw "dumpbin.exe not found on PATH (expected after MSVC dev-cmd setup)."
          }
          $headers = & dumpbin.exe /headers $exe.FullName
          $joined = ($headers -join "`n")
          $machineLine = ($headers | Select-String -Pattern "machine" -CaseSensitive:$false | Select-Object -First 1).ToString()
          Write-Host "dumpbin machine line: $machineLine"
          if ($joined -notmatch '\bAA64\b') {
            throw "Expected ARM64 machine type 'AA64' in dumpbin output for $($exe.FullName), but it was not found. If this is x64, the ARM64 target toolchain/environment is misconfigured."
          }
          if ($joined -match '\b8664\b') {
            throw "Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
          }

      - name: Verify bundles exist
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $bundleDir = "apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle"
          if (!(Test-Path $bundleDir)) {
            throw "Expected bundle directory not found: $bundleDir"
          }

          # Use the shared validator so the smoke workflow matches release CI behavior.
          pwsh -NoProfile -ExecutionPolicy Bypass -File ./scripts/validate-windows-bundles.ps1 -BundleDir $bundleDir -RequireExe -RequireMsi

          "## Windows ARM64 bundles" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          $exe = @()
          $exe += @(Get-ChildItem -Path (Join-Path $bundleDir "nsis") -Recurse -File -Filter "*.exe" -ErrorAction SilentlyContinue)
          $exe += @(Get-ChildItem -Path (Join-Path $bundleDir "nsis-web") -Recurse -File -Filter "*.exe" -ErrorAction SilentlyContinue)
          $exe = @($exe | Where-Object { $_.Name -notmatch '^MicrosoftEdgeWebview2' })
          $msi = @(Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue)
          $files = @($exe + $msi) | Sort-Object FullName
          foreach ($f in $files) {
            $rel = $f.FullName.Replace((Resolve-Path ".").Path + "\", "")
            $mb = [Math]::Round($f.Length / 1MB, 2)
            "- `$rel` (${mb} MB)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }

      - name: Verify MSI targets ARM64 (template summary)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $bundleDir = "apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle"
          $msis = @(
            Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue
          )
          if ($msis.Count -eq 0) {
            throw "windows-arm64-msi: ERROR no .msi installers found under: $bundleDir"
          }

          $installer = New-Object -ComObject WindowsInstaller.Installer
          foreach ($msi in $msis) {
            $db = $installer.OpenDatabase($msi.FullName, 0)
            $summary = $db.SummaryInformation(0)
            $template = $summary.Property(7)
            Write-Host "windows-arm64-msi: $($msi.Name) template=$template"
            if ($template -notmatch '(?i)arm64') {
              throw "windows-arm64-msi: ERROR Expected MSI Template Summary to include ARM64 for $($msi.FullName), got: $template"
            }
          }

      - name: Verify Windows installers bundle/reference WebView2 (bootstrapper/runtime)
        run: python scripts/ci/check-windows-webview2-installer.py

      - name: Upload bundles
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: windows-arm64-bundles
          path: apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle/**
