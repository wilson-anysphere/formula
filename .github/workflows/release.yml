name: Desktop Release

# NOTE: Third-party GitHub Actions are pinned to an immutable commit SHA for
# supply-chain hardening. To update, pick the desired upstream tag (same major
# version), resolve it to a commit with `git ls-remote <repo> <tag> <tag>^{}`,
# then replace the SHA below and update the trailing comment.

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

# Prevent multiple runs for the same tag from racing while uploading GitHub Release
# assets (including Tauri updater manifests like `latest.json`). Without this,
# manual re-runs or tag updates can overlap and clobber/partially overwrite the
# release asset set.
concurrency:
  group: desktop-release-${{ github.ref }}
  # Queue (don't cancel) subsequent runs so each tag's release assets are written
  # atomically by a single workflow run.
  cancel-in-progress: false

env:
  # Keep release builds on the same Node.js major as CI (see ci.yml) to avoid
  # "works in CI, breaks in release" drift.
  NODE_VERSION: 22
jobs:
  conflict-marker-guard:
    name: "Guard: no merge conflict markers"
    # Pinned runner images keep release workflows deterministic and avoid breakages
    # when GitHub updates the default `*-latest` hosted runner images.
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh

  validate-version:
    name: Validate desktop version matches tag
    needs: conflict-marker-guard
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check desktop version matches release tag
        run: node scripts/check-desktop-version.mjs "${{ github.ref_name }}"

      - name: Validate Tauri updater config
        run: node scripts/check-updater-config.mjs

      - name: Validate Tauri updater signing secrets
        # This workflow currently only runs on tags, but keep the guard so future
        # workflow_dispatch runs on branches don't require release secrets.
        if: startsWith(github.ref, 'refs/tags/')
        run: node scripts/ci/check-tauri-updater-secrets.mjs
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

  build:
    name: Build (${{ matrix.label }})
    needs: validate-version
    strategy:
      fail-fast: false
      # NOTE: tauri-action updates shared GitHub Release assets (notably `latest.json`)
      # for the updater. If multiple matrix jobs run in parallel they can race and
      # overwrite each other, leading to missing platform entries. Serializing the
      # matrix prevents these release asset / manifest update races.
      max-parallel: 1
      matrix:
        # Pinned runner images keep release workflows deterministic and avoid breakages
        # when GitHub updates the default `*-latest` hosted runner images.
        include:
          - platform: macos-14
            label: macos-14
            # The macOS job builds a universal bundle (x86_64 + arm64).
            cache_target: universal-apple-darwin
            rust_target: ""
            tauri_args: ""
          - platform: ubuntu-24.04
            label: ubuntu-24.04
            cache_target: x86_64-unknown-linux-gnu
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: windows-2022
            label: windows-2022 (x64)
            cache_target: x86_64-pc-windows-msvc
            rust_target: x86_64-pc-windows-msvc
            tauri_args: "--target x86_64-pc-windows-msvc --bundles msi,nsis"
          - platform: windows-2022
            label: windows-2022 (arm64)
            cache_target: aarch64-pc-windows-msvc
            rust_target: aarch64-pc-windows-msvc
            tauri_args: "--target aarch64-pc-windows-msvc --bundles msi,nsis"

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          # Pin the pnpm patch version for deterministic tagged-release builds.
          # Keep this in sync with the root package.json `packageManager` field.
          version: 9.0.0

      - name: Preflight: verify macOS code signing secrets (base64 + PKCS#12)
        if: matrix.platform == 'macos-latest' && (secrets.APPLE_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1')
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh macos

      - name: Preflight: verify Windows code signing secrets (base64 + PKCS#12)
        if: matrix.platform == 'windows-latest' && (secrets.WINDOWS_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1')
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh windows

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Validate macOS entitlements (hardened runtime)
        if: runner.os == 'macOS'
        run: node scripts/check-macos-entitlements.mjs

      # Code signing is optional and frequently unavailable in forks/dry-runs (no repo secrets).
      # When signing secrets are missing, we patch `tauri.conf.json` for this CI run so bundling
      # still succeeds (unsigned artifacts), and we only export notarization env vars when all
      # required credentials are configured.
      #
      # When maintainers set FORMULA_REQUIRE_CODESIGN=1, this step switches to enforcement mode and
      # fails early if platform signing secrets are missing.
      - name: Prepare optional Tauri signing config (macOS/Windows)
        run: node scripts/ci/prepare-tauri-signing-config.mjs
        env:
          # Optional: set as a GitHub Actions "Variable" to enforce platform code signing.
          # - FORMULA_REQUIRE_CODESIGN=1 to fail when required signing secrets are missing
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}

          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@9bc92bc5598b4f3bec5d910d352094982cb0c3b9 # 1.92.0

      - name: Install Rust targets (WASM)
        run: rustup target add wasm32-unknown-unknown

      - name: Install macOS Rust targets (universal build)
        if: runner.os == 'macOS'
        run: rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Install Rust target (${{ matrix.rust_target }})
        if: matrix.rust_target != ''
        run: rustup target add ${{ matrix.rust_target }}

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Use shared Cargo home for CI caching (Unix)
        if: runner.os != 'Windows'
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Install WiX Toolset (required for MSI builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's MSI bundler requires WiX (candle.exe/light.exe) to be on PATH.
          # GitHub runners don't consistently have it available, and Tauri may skip
          # MSI generation without failing. Install WiX deterministically.
          $candle = Get-Command candle.exe -ErrorAction SilentlyContinue
          $light = Get-Command light.exe -ErrorAction SilentlyContinue
          if (-not $candle -or -not $light) {
            choco install wixtoolset --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            # (Chocolatey may update PATH via the registry; refreshenv reloads it.)
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          # Add common WiX install locations to PATH for subsequent steps.
          $wixRoots = Get-ChildItem -Path (Join-Path ${env:ProgramFiles(x86)} "WiX Toolset v*") -Directory -ErrorAction SilentlyContinue
          foreach ($root in $wixRoots) {
            $bin = Join-Path $root.FullName "bin"
            if (Test-Path $bin) {
              $env:PATH = "$bin;$env:PATH"
              $bin | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
            }
          }

          if (-not (Get-Command candle.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: candle.exe not found on PATH."
          }
          if (-not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: light.exe not found on PATH."
          }

      - name: Install NSIS (required for EXE builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's NSIS bundler requires makensis.exe. If it's missing, Tauri may
          # skip EXE generation without failing the overall build. Install NSIS
          # deterministically so Windows releases always include both `.exe` and `.msi`.
          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            choco install nsis --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            throw "NSIS installation failed: makensis.exe not found on PATH."
          }

      - name: Cache cargo registry + git
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ${{ env.CARGO_HOME }}/registry
            ${{ env.CARGO_HOME }}/git
          key: cargo-${{ runner.os }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-${{ runner.os }}-

      - name: Cache cargo target (release build artifacts)
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            target/**/release/deps
            target/**/release/build
            target/**/release/.fingerprint
            target/**/release/incremental
            target/**/release/wbuild
            target/.rustc_info.json
            target/**/.rustc_info.json
            apps/desktop/src-tauri/target/**/release/deps
            apps/desktop/src-tauri/target/**/release/build
            apps/desktop/src-tauri/target/**/release/.fingerprint
            apps/desktop/src-tauri/target/**/release/incremental
            apps/desktop/src-tauri/target/**/release/wbuild
            apps/desktop/src-tauri/target/.rustc_info.json
            apps/desktop/src-tauri/target/**/.rustc_info.json
          # Keep these caches isolated per Rust target triple + runner arch so cross-compile jobs
          # (e.g. Windows aarch64) don't thrash/overwrite caches or restore host build-script
          # binaries from an incompatible runner architecture.
          key: cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            squashfs-tools \
            fakeroot \
            rpm

          # `appimagetool` is distributed as an AppImage and requires the FUSE 2 runtime.
          # Ubuntu 24.04 uses `libfuse2t64` as part of the time_t 64-bit transition.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64

      - name: Install JS dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/wasm-pack
            ~/.cargo/bin/wasm-pack.exe
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-v0.13.1
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        # Pinned for release reproducibility. Known-good with this repo's WASM build
        # (`crates/formula-wasm` via `packages/engine/scripts/build-wasm.mjs`).
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        run: cargo install wasm-pack --version 0.13.1 --locked

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        run: pnpm -C apps/desktop check:coi

      - name: Build and upload release assets (macOS universal)
        if: runner.os == 'macOS'
        # Pinned for reproducible releases: avoid upstream `@v0` moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          args: --target universal-apple-darwin
          tagName: ${{ github.ref_name }}
          releaseName: Formula ${{ github.ref_name }}
          releaseBody: |
            Automated build for ${{ github.ref_name }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          prerelease: false

      - name: Build and upload release assets
        if: runner.os != 'macOS'
        # Pinned for reproducible releases: avoid upstream `@v0` moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          args: ${{ matrix.tauri_args }}
          tagName: ${{ github.ref_name }}
          releaseName: Formula ${{ github.ref_name }}
          releaseBody: |
            Automated build for ${{ github.ref_name }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          prerelease: false

      - name: Assert Windows installer bundle exists for target
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-bundle: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $bundleDir = "apps/desktop/src-tauri/target/$target/release/bundle"

          if (-not (Test-Path $bundleDir)) {
            throw "windows-bundle: ERROR expected Tauri bundle dir not found: $bundleDir"
          }

          # Wrap in @() so `.Count` behaves consistently even when 0 or 1 files match.
          $msis = @(Get-ChildItem -Path $bundleDir -Recurse -File -Include *.msi -ErrorAction SilentlyContinue)
          $exes = @(Get-ChildItem -Path $bundleDir -Recurse -File -Include *.exe -ErrorAction SilentlyContinue)

          if ($msis.Count -eq 0) {
            throw "windows-bundle: ERROR missing required Windows MSI installer under: $bundleDir"
          }
          if ($exes.Count -eq 0) {
            throw "windows-bundle: ERROR missing required Windows EXE (NSIS) installer under: $bundleDir"
          }

          Write-Host "windows-bundle: OK (found $($msis.Count) MSI + $($exes.Count) EXE installer file(s))"
          Write-Host "MSI installers:"
          $msis | ForEach-Object { Write-Host " - $($_.FullName)" }
          Write-Host "EXE installers:"
          $exes | ForEach-Object { Write-Host " - $($_.FullName)" }

      - name: Verify Windows installers bundle/reference WebView2 (bootstrapper/runtime)
        if: runner.os == 'Windows'
        run: python scripts/ci/check-windows-webview2-installer.py

      - name: Verify Linux release artifacts (AppImage + deb + rpm + signatures)
        if: matrix.platform == 'ubuntu-24.04'
        shell: bash
        env:
          # Updater signature files (`*.sig`) are only generated when the updater private key is
          # configured. Forks/dry-runs often have no secrets, so we skip `.sig` validation there
          # while still ensuring the bundle artifacts themselves were produced.
          FORMULA_HAS_TAURI_UPDATER_KEY: ${{ secrets.TAURI_PRIVATE_KEY != '' }}
        run: |
          set -euo pipefail

          # Tauri bundles normally live under `src-tauri/target/release/bundle`, but can also
          # end up under `src-tauri/target/<triple>/release/bundle` if `--target` is used.
          bundle_roots=()
          for root in "apps/desktop/src-tauri/target" "target"; do
            if [[ -d "$root" ]]; then
              bundle_roots+=("$root")
            fi
          done
          if ((${#bundle_roots[@]} == 0)); then
            echo "Expected Tauri target directory not found. Looked in: apps/desktop/src-tauri/target and target" >&2
            exit 1
          fi

          mapfile -d '' appimages < <(find "${bundle_roots[@]}" -type f -path '*/release/bundle/appimage/*.AppImage' -print0)
          mapfile -d '' debs < <(find "${bundle_roots[@]}" -type f -path '*/release/bundle/deb/*.deb' -print0)
          mapfile -d '' rpms < <(find "${bundle_roots[@]}" -type f -path '*/release/bundle/rpm/*.rpm' -print0)

          echo "Bundle outputs:"
          printf '  AppImage: %s\n' "${#appimages[@]}"
          printf '  deb:      %s\n' "${#debs[@]}"
          printf '  rpm:      %s\n' "${#rpms[@]}"

          if ((${#appimages[@]} == 0)); then
            echo "Missing required Linux artifact: .AppImage" >&2
            exit 1
          fi
          if ((${#debs[@]} == 0)); then
            echo "Missing required Linux artifact: .deb" >&2
            exit 1
          fi
          if ((${#rpms[@]} == 0)); then
            echo "Missing required Linux artifact: .rpm" >&2
            exit 1
          fi

          if [[ "${FORMULA_HAS_TAURI_UPDATER_KEY}" == "true" ]]; then
            # Ensure updater signature files exist for each bundle type.
            for artifact in "${appimages[@]}" "${debs[@]}" "${rpms[@]}"; do
              if [[ ! -f "${artifact}.sig" ]]; then
                echo "Missing signature file for ${artifact} (expected ${artifact}.sig)" >&2
                exit 1
              fi
            done
          else
            echo "TAURI_PRIVATE_KEY not configured; skipping updater signature (*.sig) verification."
          fi

      - name: Verify Linux package dependency metadata (deb + rpm)
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/verify-linux-package-deps.sh

      - name: Verify macOS universal binary (lipo)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Locate the packaged `.app` under the Tauri bundle output directory and verify the
          # main executable is a universal binary (x86_64 + arm64).
          #
          # We look under `apps/desktop/src-tauri/target/**/release/bundle/**` first, but also
          # fall back to the workspace root `target/` directory (Cargo workspaces often emit
          # build artifacts there).
          app_path="$(
            find apps/desktop/src-tauri/target -type d -path '*/release/bundle/macos/*.app' -print 2>/dev/null | head -n 1 || true
          )"
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find target -type d -path '*/release/bundle/macos/*.app' -print 2>/dev/null | head -n 1 || true
            )"
          fi

          if [[ -z "$app_path" ]]; then
            echo "::error::No .app bundle found under apps/desktop/src-tauri/target/**/release/bundle/**" >&2
            find apps/desktop/src-tauri/target -type d -name '*.app' -print 2>/dev/null || true
            exit 1
          fi

          echo "Found app bundle: $app_path"
          macos_dir="$app_path/Contents/MacOS"
          if [[ ! -d "$macos_dir" ]]; then
            echo "::error::Expected Contents/MacOS directory not found: $macos_dir" >&2
            find "$app_path/Contents" -maxdepth 2 -print 2>/dev/null || true
            exit 1
          fi

          bin_path="$macos_dir/formula-desktop"
          if [[ ! -f "$bin_path" ]]; then
            bin_path="$(find "$macos_dir" -maxdepth 1 -type f -print | head -n 1 || true)"
          fi
          if [[ -z "$bin_path" || ! -f "$bin_path" ]]; then
            echo "::error::Could not find app executable under $macos_dir" >&2
            ls -la "$macos_dir" || true
            exit 1
          fi

          echo "Checking architectures for: $bin_path"
          info="$(lipo -info "$bin_path" | tee /dev/stderr)"
          echo "$info" | grep -q "x86_64" || { echo "::error::macOS binary is missing x86_64 slice"; exit 1; }
          echo "$info" | grep -q "arm64" || { echo "::error::macOS binary is missing arm64 slice"; exit 1; }

      - name: Verify Windows installers are Authenticode-signed
        if: runner.os == 'Windows' && secrets.WINDOWS_CERTIFICATE != '' && secrets.WINDOWS_CERTIFICATE_PASSWORD != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Tauri Windows bundles are emitted under src-tauri/target/**/release/bundle/**.
          # We only enforce signature validity when Windows signing secrets are present
          # so forks/dry runs (which cannot access secrets) skip this check cleanly.
          # Cargo workspaces typically emit bundles under `<repo>/target/**`, but standalone Tauri
          # builds may use `apps/desktop/src-tauri/target/**`. Support both so we don't break
          # releases if the build output layout changes.
          $searchRoots = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target"),
            (Join-Path $env:GITHUB_WORKSPACE "target")
          ) | Where-Object { Test-Path $_ }

          if ($searchRoots.Count -eq 0) {
            Write-Error "Expected build output directory not found. Looked for:`n- apps/desktop/src-tauri/target`n- target"
          }

          # Wrap in @() so `.Count` behaves consistently even when 0 or 1 files match.
          $installers = @(Get-ChildItem -Path $searchRoots -Recurse -File -Include *.exe, *.msi |
            Where-Object { $_.FullName -match '[\\/]release[\\/]bundle[\\/]' })

          if ($installers.Count -eq 0) {
            Write-Error "No Windows installers (.exe/.msi) found under target/**/release/bundle/**"
          }

          $failed = $false
          foreach ($file in $installers) {
            Write-Host "Checking Authenticode signature: $($file.FullName)"
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -ne 'Valid') {
              Write-Host ($sig | Format-List | Out-String)
              Write-Error "Authenticode signature is not valid for $($file.FullName): Status=$($sig.Status) $($sig.StatusMessage)"
              $failed = $true
            }
          }

          if ($failed) {
            exit 1
          }

      - name: Validate macOS notarization + stapling (Gatekeeper)
        if: ${{ runner.os == 'macOS' && secrets.APPLE_CERTIFICATE != '' && secrets.APPLE_CERTIFICATE_PASSWORD != '' && secrets.APPLE_SIGNING_IDENTITY != '' && secrets.APPLE_ID != '' && secrets.APPLE_PASSWORD != '' && secrets.APPLE_TEAM_ID != '' }}
        working-directory: apps/desktop/src-tauri
        shell: bash
        run: |
          set -euo pipefail

          echo "Validating macOS release artifacts are notarized and stapled (Gatekeeper-ready)."
          echo "Search root: $(pwd)"

          if [[ ! -d target ]]; then
            echo "::error::Expected build output directory 'apps/desktop/src-tauri/target' does not exist."
            exit 1
          fi

          # Tauri bundler outputs (examples):
          # - target/release/bundle/dmg/*.dmg
          # - target/release/bundle/macos/*.app
          # - target/<triple>/release/bundle/... (when building for non-host targets)
          # Avoid bash `mapfile` (not available on macOS's system bash 3.x).
          dmgs=()
          while IFS= read -r -d '' dmg; do
            dmgs+=("$dmg")
          done < <(find target -type f -path "*/release/bundle/*/*.dmg" -print0)

          # Prune at the first matching .app so we don't accidentally validate nested helper apps.
          apps=()
          while IFS= read -r -d '' app; do
            apps+=("$app")
          done < <(find target -type d -path "*/release/bundle/*/*.app" -prune -print0)

          # Tauri's macOS updater artifact is typically a tarball (e.g. `Formula.app.tar.gz`).
          # Validate the `.app` inside the archive as well to ensure the updater payload is
          # stapled/notarized, not just the standalone bundle output.
          tarballs=()
          while IFS= read -r -d '' archive; do
            tarballs+=("$archive")
          done < <(find target -type f \( -name "*.tar.gz" -o -name "*.tgz" \) -path "*/release/bundle/macos/*" -print0)

          if [[ ${#dmgs[@]} -eq 0 && ${#apps[@]} -eq 0 ]]; then
            echo "::error::No macOS bundle artifacts (.dmg or .app) were found under target/**/release/bundle/**."
            echo "This step runs only when APPLE_* notarization secrets are configured, and is meant to"
            echo "guarantee tagged releases produce Gatekeeper-ready artifacts (notarized + stapled)."
            echo
            echo "Expected output paths include:"
            echo "  apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg"
            echo "  apps/desktop/src-tauri/target/release/bundle/macos/*.app"
            exit 1
          fi

          echo "Found artifacts:"
          if [[ ${#dmgs[@]} -gt 0 ]]; then
            printf '  - %s\n' "${dmgs[@]}"
          fi
          if [[ ${#apps[@]} -gt 0 ]]; then
            printf '  - %s\n' "${apps[@]}"
          fi
          if [[ ${#tarballs[@]} -gt 0 ]]; then
            printf '  - %s\n' "${tarballs[@]}"
          fi

          fail=0

          validate_dmg() {
            local dmg="$1"
            echo "::group::Validate notarization for DMG: $dmg"

            # Requires the DMG to have a stapled ticket for offline Gatekeeper validation.
            if ! xcrun stapler validate "$dmg"; then
              echo "::error::DMG is not stapled (missing notarization ticket): $dmg"
              fail=1
            fi

            # Gatekeeper assessment for disk images.
            if ! spctl -a -vv --type open "$dmg"; then
              echo "::error::Gatekeeper rejected DMG (not notarized?): $dmg"
              fail=1
            fi

            echo "::endgroup::"
          }

          validate_app() {
            local app="$1"
            echo "::group::Validate notarization for app: $app"

            if ! xcrun stapler validate "$app"; then
              echo "::error::App bundle is not stapled (missing notarization ticket): $app"
              fail=1
            fi

            # Gatekeeper assessment for executables / app bundles.
            if ! spctl -a -vv --type execute "$app"; then
              echo "::error::Gatekeeper rejected app bundle (not notarized?): $app"
              fail=1
            fi

            echo "::endgroup::"
          }

          validate_apps_inside_dmg() {
            local dmg="$1"
            local mount_dir
            mount_dir="$(mktemp -d)"

            echo "::group::Validate .app inside DMG: $dmg"

            if hdiutil attach "$dmg" -nobrowse -readonly -mountpoint "$mount_dir" >/dev/null; then
              mounted_apps=()
              while IFS= read -r -d '' app; do
                mounted_apps+=("$app")
              done < <(find "$mount_dir" -maxdepth 2 -type d -name "*.app" -prune -print0)

              if [[ ${#mounted_apps[@]} -eq 0 ]]; then
                echo "::error::Mounted DMG but did not find a .app bundle inside: $dmg"
                fail=1
              else
                for app in "${mounted_apps[@]}"; do
                  validate_app "$app"
                done
              fi

              hdiutil detach "$mount_dir" >/dev/null || hdiutil detach "$mount_dir" -force >/dev/null || true
            else
              echo "::error::Failed to mount DMG for validation: $dmg"
              fail=1
            fi

            rm -rf "$mount_dir" || true
            echo "::endgroup::"
          }

          validate_apps_inside_archive() {
            local archive="$1"
            local extract_dir
            extract_dir="$(mktemp -d)"

            echo "::group::Validate .app inside archive: $archive"

            if tar -xzf "$archive" -C "$extract_dir"; then
              extracted_apps=()
              while IFS= read -r -d '' app; do
                extracted_apps+=("$app")
              done < <(find "$extract_dir" -maxdepth 3 -type d -name "*.app" -prune -print0)

              if [[ ${#extracted_apps[@]} -eq 0 ]]; then
                echo "::error::Extracted updater archive but did not find a .app bundle inside: $archive"
                fail=1
              else
                for app in "${extracted_apps[@]}"; do
                  validate_app "$app"
                done
              fi
            else
              echo "::error::Failed to extract updater archive for validation: $archive"
              fail=1
            fi

            rm -rf "$extract_dir" || true
            echo "::endgroup::"
          }

          for dmg in "${dmgs[@]}"; do
            validate_dmg "$dmg"
            validate_apps_inside_dmg "$dmg"
          done

          for app in "${apps[@]}"; do
            validate_app "$app"
          done

          for archive in "${tarballs[@]}"; do
            validate_apps_inside_archive "$archive"
          done

          if [[ "$fail" -ne 0 ]]; then
            echo "::error::macOS notarization/stapling validation failed."
            echo "The release build produced artifacts, but at least one was rejected by Gatekeeper or"
            echo "missing a stapled notarization ticket."
            echo
            echo "Troubleshooting:"
            echo "  - Confirm Apple signing + notarization secrets are configured:"
            echo "    - APPLE_CERTIFICATE / APPLE_CERTIFICATE_PASSWORD / APPLE_SIGNING_IDENTITY"
            echo "    - APPLE_ID / APPLE_PASSWORD / APPLE_TEAM_ID"
            echo "  - Check the tauri-action logs for notarization/stapling output."
            exit 1
          fi

          echo "macOS notarization/stapling validation passed."

      - name: Verify Windows ARM64 binary (formula-desktop.exe is AA64)
        if: matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $exeCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/formula-desktop.exe'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/formula-desktop.exe')
          )
          $exe = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$exe) {
            Write-Error "Expected ARM64 executable not found. Looked in:`n$($exeCandidates -join [Environment]::NewLine)`nDid the build run with --target aarch64-pc-windows-msvc?"
            exit 1
          }

          # Locate dumpbin from the installed Visual Studio toolchain.
          $vswhere = Join-Path ${env:ProgramFiles(x86)} 'Microsoft Visual Studio/Installer/vswhere.exe'
          if (!(Test-Path $vswhere)) {
            Write-Error "vswhere.exe not found at: $vswhere"
            exit 1
          }

          $vsInstall = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
          if (!$vsInstall) {
            Write-Error 'Unable to locate a Visual Studio installation via vswhere.'
            exit 1
          }

          $msvcRoot = Join-Path $vsInstall 'VC/Tools/MSVC'
          if (!(Test-Path $msvcRoot)) {
            Write-Error "MSVC tools dir not found at: $msvcRoot"
            exit 1
          }

          $dumpbin = Get-ChildItem -Path $msvcRoot -Filter dumpbin.exe -Recurse -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match '\\bin\\Hostx64\\x64\\dumpbin\.exe$' } |
            Sort-Object -Property FullName -Descending |
            Select-Object -First 1

          if (!$dumpbin) {
            Write-Error "dumpbin.exe not found under: $msvcRoot"
            exit 1
          }

          $headers = & $dumpbin.FullName /headers $exe
          $headersText = ($headers | Out-String)
          Write-Host $headersText

          if ($headersText -notmatch 'AA64') {
            Write-Error "Expected ARM64 machine type 'AA64' in dumpbin output, but it was not found."
            exit 1
          }

          if ($headersText -match '8664') {
            Write-Error "Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
            exit 1
          }

      - name: Verify Windows ARM64 updater signatures exist
        if: matrix.rust_target == 'aarch64-pc-windows-msvc' && secrets.TAURI_PRIVATE_KEY != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/bundle')
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$bundleDir) {
            Write-Error "Bundle output dir not found. Looked in:`n$($bundleCandidates -join [Environment]::NewLine)"
            exit 1
          }

          $sigs = Get-ChildItem -Path $bundleDir -Recurse -File -Filter '*.sig'
          if ($sigs.Count -lt 1) {
            Write-Error "No updater signature files (*.sig) found under: $bundleDir"
            exit 1
          }

          Write-Host "Found updater signatures:"
          $sigs | ForEach-Object { Write-Host "- $($_.FullName)" }

      - name: Validate desktop release artifacts
        run: node scripts/ci/check-desktop-release-artifacts.mjs

      - name: Smoke test Linux .deb install in clean Ubuntu container
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/linux-package-install-smoke.sh deb

      - name: Smoke test Linux .rpm install in clean Fedora container
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/linux-package-install-smoke.sh rpm
      - name: Dump macOS effective entitlements (codesign) (signed builds only)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          # Only run when signing secrets are configured. On forks/dry-runs we build unsigned
          # artifacts (see `scripts/ci/prepare-tauri-signing-config.mjs`).
          if [[ -z "${APPLE_CERTIFICATE:-}" || -z "${APPLE_CERTIFICATE_PASSWORD:-}" ]]; then
            echo "Skipping entitlements dump: macOS signing secrets not configured (unsigned build)."
            exit 0
          fi

          search_roots=(target apps/desktop/src-tauri/target)
          app_path=""
          for root in "${search_roots[@]}"; do
            if [[ -d "$root" ]]; then
              candidate="$(find "$root" -type d -path "*/release/bundle/macos/Formula.app" | head -n 1 || true)"
              if [[ -n "$candidate" ]]; then
                app_path="$candidate"
                break
              fi
            fi
          done

          if [[ -z "$app_path" ]]; then
            for root in "${search_roots[@]}"; do
              if [[ -d "$root" ]]; then
                candidate="$(find "$root" -type d -path "*/release/bundle/macos/*.app" | head -n 1 || true)"
                if [[ -n "$candidate" ]]; then
                  app_path="$candidate"
                  break
                fi
              fi
            done
          fi

          if [[ -z "$app_path" ]]; then
            echo "No .app bundle found under expected Tauri bundle roots; skipping."
            exit 0
          fi

          echo "Found app bundle: $app_path"

          exe_path="$app_path/Contents/MacOS/formula-desktop"
          if [[ ! -f "$exe_path" ]]; then
            exe_path="$(find "$app_path/Contents/MacOS" -maxdepth 1 -type f | head -n 1 || true)"
          fi

          if [[ -z "$exe_path" || ! -f "$exe_path" ]]; then
            echo "Could not locate main executable inside: $app_path"
            exit 0
          fi

          echo "Dumping effective entitlements from: $exe_path"
          /usr/bin/codesign -d --entitlements :- "$exe_path" || true
      - name: Report desktop bundle sizes
        env:
          # Optional: set these as GitHub Actions "Variables" to enable gating.
          # - FORMULA_ENFORCE_BUNDLE_SIZE=1 to fail when any artifact exceeds the limit
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        run: python scripts/desktop_bundle_size_report.py

  validate-updater-manifest:
    name: Validate combined updater manifest (latest.json)
    needs: build
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Validate updater manifest assets + targets
        env:
          # The validator uses the GitHub API to read/download assets from the draft release.
          # Set both token env vars so it works whether it looks for GH_TOKEN or GITHUB_TOKEN.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/ci/validate-updater-manifest.mjs "${{ github.ref_name }}"
