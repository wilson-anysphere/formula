name: Desktop Release

# NOTE: Third-party GitHub Actions are pinned to an immutable commit SHA for
# supply-chain hardening. To update, pick the desired upstream tag (same major
# version), resolve it to a commit with `git ls-remote <repo> <tag> <tag>^{}`,
# then replace the SHA below and update the trailing comment.

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Git tag to use for the release (optional). Example: v0.2.3"
        required: false
        type: string
      version:
        description: "Version label for artifacts (optional). Example: 0.2.3"
        required: false
        type: string
      upload:
        description: "If true, create/update a draft GitHub Release and attach assets. If false, upload bundles as workflow artifacts."
        required: false
        type: boolean
        default: false

permissions:
  contents: write

# Prevent multiple runs for the same tag from racing while uploading GitHub Release
# assets (including Tauri updater manifests like `latest.json`). Without this,
# manual re-runs or tag updates can overlap and clobber/partially overwrite the
# release asset set.
concurrency:
  # For `workflow_dispatch`, `github.ref` is the branch the workflow is run from, but the release
  # tag may come from inputs. Key concurrency off the *effective* release tag when provided so
  # dispatch runs for a given tag can't overlap with the corresponding tag push run.
  # NOTE: `github.event.inputs.*` may be empty/undefined for optional inputs, so guard `startsWith`
  # with truthy checks to avoid evaluation errors.
  group: desktop-release-${{ github.event_name == 'workflow_dispatch' && ((github.event.inputs.tag && (startsWith(github.event.inputs.tag, 'v') && github.event.inputs.tag || format('v{0}', github.event.inputs.tag))) || (github.event.inputs.version && (startsWith(github.event.inputs.version, 'v') && github.event.inputs.version || format('v{0}', github.event.inputs.version))) || github.ref_name) || github.ref_name }}
  # Queue (don't cancel) subsequent runs so each tag's release assets are written
  # atomically by a single workflow run.
  cancel-in-progress: false

env:
  # Keep release builds on the same Node.js major as CI (see ci.yml) to avoid
  # "works in CI, breaks in release" drift.
  NODE_VERSION: 22
  # Pin wasm-pack for reproducible tagged releases (avoid `cargo install wasm-pack`
  # pulling newer incompatible versions). Keep this in sync with ci.yml/perf.yml.
  WASM_PACK_VERSION: 0.13.1
  # Pin the Tauri CLI (`cargo tauri`) version used by release builds so the toolchain
  # can't drift independently from the repo's pinned Tauri crates.
  #
  # Keep this in sync with:
  # - apps/desktop/src-tauri/Cargo.toml (tauri = "2.9")
  # - docs/release.md (local release prep instructions)
  TAURI_CLI_VERSION: "2.9.5"
jobs:
  conflict-marker-guard:
    name: "Guard: no merge conflict markers"
    # Pinned runner images keep release workflows deterministic and avoid breakages
    # when GitHub updates the default `*-latest` hosted runner images.
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh
      - name: "Guard: Rust toolchain pins match rust-toolchain.toml"
        run: bash scripts/ci/check-rust-toolchain-pins.sh
      - name: "Guard: Node version pins match CI workflow"
        run: bash scripts/ci/check-node-version-pins.sh
      - name: "Guard: pnpm version pins match package.json + CI workflow"
        run: bash scripts/ci/check-pnpm-version-pins.sh

  validate-version:
    name: Validate desktop version matches tag
    needs: conflict-marker-guard
    runs-on: ubuntu-24.04
    outputs:
      upload: ${{ steps.params.outputs.upload }}
      release_tag: ${{ steps.params.outputs.release_tag }}
      artifact_label: ${{ steps.params.outputs.artifact_label }}
      should_validate_version: ${{ steps.params.outputs.should_validate_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Compute release parameters
        id: params
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          INPUT_VERSION: ${{ github.event.inputs.version }}
          INPUT_UPLOAD: ${{ github.event.inputs.upload }}
        run: |
          set -euo pipefail

          # Defaults:
          upload="false"
          release_tag=""

          # Derive the release tag / artifact label.
          if [[ "${EVENT_NAME}" == "push" ]]; then
            upload="true"
            release_tag="${REF_NAME}"
            artifact_label="${REF_NAME}"
          else
            # workflow_dispatch
            if [[ "${INPUT_UPLOAD:-}" == "true" ]]; then
              upload="true"
            fi

            tag="${INPUT_TAG:-}"
            version="${INPUT_VERSION:-}"

            # Some users may paste full ref names. Normalize to a bare tag/version string.
            tag="${tag#refs/tags/}"
            version="${version#refs/tags/}"

            if [[ -n "${tag}" ]]; then
              if [[ "${tag}" == v* ]]; then
                release_tag="${tag}"
              else
                release_tag="v${tag}"
              fi
              artifact_label="${release_tag}"
            elif [[ -n "${version}" ]]; then
              # `version` is primarily for labeling dry-run artifacts. When `upload=true`, we
              # still need a GitHub Release tag, so we normalize it to a `v*` tag.
              artifact_label="${version}"
              if [[ "${version}" == v* ]]; then
                release_tag="${version}"
              else
                release_tag="v${version}"
              fi
            else
              short_sha="$(echo "${GITHUB_SHA}" | cut -c1-7)"
              artifact_label="manual-${short_sha}"
            fi

            if [[ "${upload}" == "true" && -z "${release_tag}" ]]; then
              echo "error: upload=true requires either the 'tag' or 'version' workflow input." >&2
              exit 1
            fi
          fi

          should_validate_version="false"
          if [[ "${EVENT_NAME}" == "push" || "${upload}" == "true" ]]; then
            should_validate_version="true"
          fi

          # Artifact names should be safe as directory/file-ish identifiers. GitHub allows many
          # characters, but keep it simple for consumers and avoid surprises.
          artifact_label_sanitized="$(echo "${artifact_label}" | sed -E 's/[^A-Za-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
          if [[ -z "${artifact_label_sanitized}" ]]; then
            artifact_label_sanitized="manual-$(echo "${GITHUB_SHA}" | cut -c1-7)"
          fi

          echo "upload=${upload}" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${release_tag}" >> "${GITHUB_OUTPUT}"
          echo "artifact_label=${artifact_label_sanitized}" >> "${GITHUB_OUTPUT}"
          echo "should_validate_version=${should_validate_version}" >> "${GITHUB_OUTPUT}"

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check pinned Tauri CLI version matches Tauri crates
        run: node scripts/ci/check-tauri-cli-version.mjs

      - name: Check desktop version matches release tag
        if: steps.params.outputs.should_validate_version == 'true'
        run: node scripts/check-desktop-version.mjs "${{ steps.params.outputs.release_tag }}"

      - name: Validate Tauri updater config
        run: node scripts/check-updater-config.mjs

      - name: Validate Windows WebView2 installer configuration
        run: node scripts/ci/check-webview2-install-mode.mjs

      - name: Validate Windows Authenticode timestamp URL (HTTPS)
        run: node scripts/ci/check-windows-timestamp-url.mjs

      - name: Validate Windows downgrade / rollback support (allowDowngrades)
        run: node scripts/ci/check-windows-allow-downgrades.mjs

      - name: Validate Tauri updater signing secrets
        # Forks/dry-runs often do not configure release secrets. We always validate updater
        # signing secrets in the upstream repo (so official releases can't ship without
        # auto-update signatures), and validate in forks only when the user has configured their
        # own updater keys.
        #
        # Only enforce when we're publishing to a GitHub Release (tag push or workflow_dispatch upload=true).
        if: steps.params.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
        run: node scripts/ci/check-tauri-updater-secrets.mjs
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

      # Fail fast (before any platform builds start) if maintainers require code signing or if
      # signing secrets are partially configured. This avoids wasting build time and uploading
      # a partial set of GitHub Release assets.
      - name: "Preflight: verify macOS code signing secrets (base64 + PKCS#12)"
        if: secrets.APPLE_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh macos

      - name: "Preflight: verify Windows code signing secrets (base64 + PKCS#12)"
        if: secrets.WINDOWS_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh windows

      - name: "Preflight: require macOS notarization creds when FORMULA_REQUIRE_CODESIGN=1"
        if: vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          missing=()
          for name in APPLE_SIGNING_IDENTITY APPLE_ID APPLE_PASSWORD APPLE_TEAM_ID; do
            if [[ -z "${!name:-}" ]]; then
              missing+=("$name")
            fi
          done

          if ((${#missing[@]} > 0)); then
            echo "" >&2
            echo "Code signing is required (FORMULA_REQUIRE_CODESIGN=1) but macOS notarization/signing secrets are missing:" >&2
            for m in "${missing[@]}"; do
              echo "  - ${m}" >&2
            done
            echo "" >&2
            echo "Set these in GitHub: Settings → Secrets and variables → Actions → New repository secret." >&2
            echo "See docs/release.md (\"Code signing\")." >&2
            exit 1
          fi

  build:
    name: Build (${{ matrix.label }})
    needs: validate-version
    strategy:
      fail-fast: false
      # NOTE: `tauri-apps/tauri-action` updates shared GitHub Release assets (notably `latest.json`)
      # for the updater. Matrix jobs remain parallel for fast releases; we publish a single combined
      # updater manifest in a dedicated job after all platform builds complete.
      matrix:
        # Pinned runner images keep release workflows deterministic and avoid breakages
        # when GitHub updates the default `*-latest` hosted runner images.
        include:
          - platform: macos-14
            label: macos-14
            # The macOS job builds a universal bundle (x86_64 + arm64).
            cache_target: universal-apple-darwin
            cache_features: desktop
            rust_target: ""
            tauri_args: ""
          - platform: ubuntu-24.04
            label: ubuntu-24.04
            cache_target: x86_64-unknown-linux-gnu
            cache_features: desktop
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: windows-2022
            label: windows-2022 (x64)
            cache_target: x86_64-pc-windows-msvc
            cache_features: desktop
            rust_target: x86_64-pc-windows-msvc
            tauri_args: "--target x86_64-pc-windows-msvc --bundles msi,nsis"
          - platform: windows-2022
            label: windows-2022 (arm64)
            cache_target: aarch64-pc-windows-msvc
            cache_features: desktop
            rust_target: aarch64-pc-windows-msvc
            tauri_args: "--target aarch64-pc-windows-msvc --bundles msi,nsis"

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          # Pin the pnpm patch version for deterministic tagged-release builds.
          # Keep this in sync with the root package.json `packageManager` field.
          version: 9.0.0

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Validate macOS entitlements (hardened runtime)
        if: runner.os == 'macOS'
        run: node scripts/check-macos-entitlements.mjs

      # Code signing is optional and frequently unavailable in forks/dry-runs (no repo secrets).
      # When signing secrets are missing, we patch `tauri.conf.json` for this CI run so bundling
      # still succeeds (unsigned artifacts), and we only export notarization env vars when all
      # required credentials are configured.
      #
      # When maintainers set FORMULA_REQUIRE_CODESIGN=1, this step switches to enforcement mode and
      # fails early if platform signing secrets are missing.
      - name: Prepare optional Tauri signing config (macOS/Windows)
        run: node scripts/ci/prepare-tauri-signing-config.mjs
        env:
          # Optional: set as a GitHub Actions "Variable" to enforce platform code signing.
          # - FORMULA_REQUIRE_CODESIGN=1 to fail when required signing secrets are missing
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}

          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@9bc92bc5598b4f3bec5d910d352094982cb0c3b9 # 1.92.0

      - name: Install Rust targets (WASM)
        run: rustup target add wasm32-unknown-unknown

      - name: Install macOS Rust targets (universal build)
        if: runner.os == 'macOS'
        run: rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Install Rust target (${{ matrix.rust_target }})
        if: matrix.rust_target != ''
        run: rustup target add ${{ matrix.rust_target }}

      - name: Ensure MSVC ARM64 build tools are installed (Windows ARM64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (!(Test-Path $vswhere)) {
            throw "vswhere not found at $vswhere (expected on GitHub-hosted Windows runners)."
          }
          $installPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (!$installPath) {
            throw "Failed to locate a Visual Studio installation via vswhere."
          }
          Write-Host "Visual Studio install path: $installPath"
          $msvcRoot = Join-Path $installPath "VC\Tools\MSVC"
          $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (!$msvcVersionDir) {
            throw "MSVC toolset directory not found under $msvcRoot"
          }
          $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
          $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
          $arm64Cl = Join-Path $arm64BinDir "cl.exe"
          $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          $hasArm64Toolchain = (Test-Path $arm64LibDir) -and (Test-Path $arm64Cl) -and (Test-Path $arm64LinkExe)

          if (-not $hasArm64Toolchain) {
            Write-Host "MSVC ARM64 toolchain not found; installing Visual Studio component Microsoft.VisualStudio.Component.VC.Tools.ARM64"
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            & $vsInstaller modify --installPath $installPath --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --includeRecommended --passive --norestart
            $exitCode = $LASTEXITCODE
            # 3010 is a common "success, reboot required" code for Windows installers.
            if ($exitCode -ne 0 -and $exitCode -ne 3010) {
              throw "vs_installer.exe failed with exit code $exitCode while installing MSVC ARM64 components."
            }

            $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
            $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
            $arm64Cl = Join-Path $arm64BinDir "cl.exe"
            $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          }

          if (!(Test-Path $arm64LibDir) -or !(Test-Path $arm64Cl) -or !(Test-Path $arm64LinkExe)) {
            throw "MSVC ARM64 build tools were not found. Expected:\n  - $arm64LibDir\n  - $arm64Cl\n  - $arm64LinkExe\nWindows ARM64 builds require the MSVC ARM64 toolchain to be present on the runner."
          }

          Write-Host "MSVC ARM64 tools present:"
          Write-Host "  - libs: $arm64LibDir"
          Write-Host "  - cl.exe: $arm64Cl"
          Write-Host "  - link.exe: $arm64LinkExe"

          $sdkLibRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\Lib"
          if (!(Test-Path $sdkLibRoot)) {
            throw "Windows SDK lib root not found at $sdkLibRoot. Windows ARM64 builds require the Windows 10/11 SDK with ARM64 libraries."
          }

          $sdkVersionDir = Get-ChildItem -Path $sdkLibRoot -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending | Select-Object -First 1
          if (!$sdkVersionDir) {
            throw "No Windows SDK lib versions found under $sdkLibRoot. Windows ARM64 builds require a Windows SDK installation with ARM64 libraries."
          }

          $sdkUmArm64 = Join-Path $sdkVersionDir.FullName "um\arm64"
          $sdkUcrtArm64 = Join-Path $sdkVersionDir.FullName "ucrt\arm64"
          if (!(Test-Path $sdkUmArm64)) {
            throw "Windows SDK ARM64 UM libraries not found at $sdkUmArm64. The runner image may be missing the Windows SDK ARM64 components."
          }
          if (!(Test-Path $sdkUcrtArm64)) {
            throw "Windows SDK ARM64 UCRT libraries not found at $sdkUcrtArm64. The runner image may be missing the Windows SDK ARM64 components."
          }

          Write-Host "windows-arm64-toolchain: OK"
          Write-Host " - MSVC: $($msvcVersionDir.FullName)"
          Write-Host " - link.exe: $arm64LinkExe"
          Write-Host " - MSVC lib: $arm64LibDir"
          Write-Host " - SDK um/arm64: $sdkUmArm64"
          Write-Host " - SDK ucrt/arm64: $sdkUcrtArm64"

      - name: Setup MSVC cross-compilation environment (amd64 → arm64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        uses: ilammy/msvc-dev-cmd@7defe9254715b088f12dddd9942945a3d75cdad5 # v1.9.0
        with:
          arch: amd64_arm64

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Use shared Cargo home for CI caching (Unix)
        if: runner.os != 'Windows'
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Install WiX Toolset (required for MSI builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's MSI bundler requires WiX (candle.exe/light.exe) to be on PATH.
          # GitHub runners don't consistently have it available, and Tauri may skip
          # MSI generation without failing. Install WiX deterministically.
          $candle = Get-Command candle.exe -ErrorAction SilentlyContinue
          $light = Get-Command light.exe -ErrorAction SilentlyContinue
          if (-not $candle -or -not $light) {
            choco install wixtoolset --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            # (Chocolatey may update PATH via the registry; refreshenv reloads it.)
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          # Add common WiX install locations to PATH for subsequent steps.
          $wixRoots = Get-ChildItem -Path (Join-Path ${env:ProgramFiles(x86)} "WiX Toolset v*") -Directory -ErrorAction SilentlyContinue
          foreach ($root in $wixRoots) {
            $bin = Join-Path $root.FullName "bin"
            if (Test-Path $bin) {
              $env:PATH = "$bin;$env:PATH"
              $bin | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
            }
          }

          if (-not (Get-Command candle.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: candle.exe not found on PATH."
          }
          if (-not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: light.exe not found on PATH."
          }

      - name: Install NSIS (required for EXE builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's NSIS bundler requires makensis.exe. If it's missing, Tauri may
          # skip EXE generation without failing the overall build. Install NSIS
          # deterministically so Windows releases always include both `.exe` and `.msi`.
          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            choco install nsis --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            throw "NSIS installation failed: makensis.exe not found on PATH."
          }

      - name: Cache cargo registry + git
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-${{ runner.os }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-${{ runner.os }}-

      - name: Cache cargo target (release build artifacts)
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            target/**/release/deps
            target/**/release/build
            target/**/release/.fingerprint
            target/**/release/incremental
            target/**/release/wbuild
            target/.rustc_info.json
            target/**/.rustc_info.json
            apps/desktop/src-tauri/target/**/release/deps
            apps/desktop/src-tauri/target/**/release/build
            apps/desktop/src-tauri/target/**/release/.fingerprint
            apps/desktop/src-tauri/target/**/release/incremental
            apps/desktop/src-tauri/target/**/release/wbuild
            apps/desktop/src-tauri/target/.rustc_info.json
            apps/desktop/src-tauri/target/**/.rustc_info.json
          # Keep these caches isolated per Rust target triple + runner arch so cross-compile jobs
          # (e.g. Windows aarch64) don't thrash/overwrite caches or restore host build-script
          # binaries from an incompatible runner architecture.
          # Include the Rust toolchain pin so caches don't leak across rustc upgrades.
          # (Similar to Swatinem/rust-cache's default behavior.)
          key: cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-
            # Backwards-compat: allow restoring caches created before we started keying
            # on the Tauri feature set (so the first run after a workflow update isn't cold).
            cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            file \
            binutils \
            cpio \
            xvfb \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            squashfs-tools \
            fakeroot \
            rpm \
            cpio

          # `appimagetool` is distributed as an AppImage and requires the FUSE 2 runtime.
          # Ubuntu 24.04 uses `libfuse2t64` as part of the time_t 64-bit transition.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64

      - name: Install JS dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cargo/bin/wasm-pack*
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        # Pinned for release reproducibility. Known-good with this repo's WASM build
        # (`crates/formula-wasm` via `packages/engine/scripts/build-wasm.mjs`).
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        run: cargo install wasm-pack --version ${{ env.WASM_PACK_VERSION }} --locked

      - name: Verify wasm-pack version
        shell: bash
        run: |
          set -euo pipefail
          expected="${WASM_PACK_VERSION}"
          actual="$(wasm-pack --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected wasm-pack ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        # COOP/COEP + Worker support can regress per-platform; run on all release targets.
        run: pnpm -C apps/desktop check:coi

      - name: Cache pinned Tauri CLI binary (cargo-tauri)
        id: tauri-cli-cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cargo/bin/cargo-tauri*
          key: cargo-tauri-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            cargo-tauri-${{ runner.os }}-${{ runner.arch }}-

      - name: Install pinned Tauri CLI (cargo tauri)
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ${{ env.TAURI_CLI_VERSION }} --locked --force

      - name: Verify Tauri CLI version
        shell: bash
        run: |
          set -euo pipefail
          expected="${TAURI_CLI_VERSION}"
          actual="$(cargo tauri --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected cargo-tauri ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache Tauri tooling downloads (Linux)
        if: runner.os == 'Linux'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cache/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (macOS)
        if: runner.os == 'macOS'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/Library/Caches/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          # Tauri's cache directory lives under %LOCALAPPDATA% on Windows.
          path: ${{ env.LOCALAPPDATA }}/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Build and upload release assets (macOS universal)
        if: runner.os == 'macOS' && needs.validate-version.outputs.upload == 'true'
        # Pinned for reproducible releases: avoid upstream floating major tags moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: --target universal-apple-darwin
          tagName: ${{ needs.validate-version.outputs.release_tag }}
          releaseName: Formula ${{ needs.validate-version.outputs.release_tag }}
          releaseBody: |
            Automated build for ${{ needs.validate-version.outputs.release_tag }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          # Mark GitHub Releases as prereleases when the semver tag contains a
          # prerelease suffix like `-beta.1` or `-rc.0` (e.g. `v1.2.3-beta.1`).
          prerelease: ${{ contains(needs.validate-version.outputs.release_tag, '-') }}

      - name: Build desktop bundles (macOS universal, dry run)
        if: runner.os == 'macOS' && needs.validate-version.outputs.upload != 'true'
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: --target universal-apple-darwin

      - name: Desktop dist asset report
        if: runner.os == 'macOS'
        run: node scripts/desktop_dist_asset_report.mjs
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Verify macOS signed app includes WKWebView JIT entitlements
        # Only run when code signing is enabled (forks/dry-runs may not have signing secrets).
        if: runner.os == 'macOS' && secrets.APPLE_CERTIFICATE != ''
        run: |
          set -euo pipefail
          # Cargo workspaces typically emit bundle outputs under `<repo>/target/**`, but standalone
          # Tauri projects use `<src-tauri>/target/**`. Support both so signed-release validation
          # doesn't fail when the build output layout changes.
          search_roots=(
            apps/desktop/src-tauri/target/universal-apple-darwin
            target/universal-apple-darwin
            apps/desktop/src-tauri/target
            target
          )

          app=""
          for root in "${search_roots[@]}"; do
            if [[ -d "$root" ]]; then
              candidate="$(find "$root" -maxdepth 12 -type d -path '*/release/bundle/macos/*.app' -print 2>/dev/null | head -n 1 || true)"
              if [[ -n "$candidate" ]]; then
                app="$candidate"
                break
              fi
            fi
          done

          if [[ -z "${app:-}" ]]; then
            echo "::error::No .app bundle found under expected release bundle roots." >&2
            echo "Searched: ${search_roots[*]}" >&2
            for root in "${search_roots[@]}"; do
              if [[ -d "$root" ]]; then
                echo "Available .app directories under $root (first 20):" >&2
                find "$root" -maxdepth 12 -type d -name '*.app' -print 2>/dev/null | head -n 20 || true
              fi
            done
            exit 1
          fi
          echo "Verifying entitlements embedded in: $app"
          codesign --verify --deep --strict --verbose=2 "$app"
          codesign -d --entitlements :- "$app" 2>&1 | grep -q "com.apple.security.cs.allow-jit"
          codesign -d --entitlements :- "$app" 2>&1 | grep -q "com.apple.security.cs.allow-unsigned-executable-memory"

      - name: Build and upload release assets
        if: runner.os != 'macOS' && needs.validate-version.outputs.upload == 'true'
        # Pinned for reproducible releases: avoid upstream floating major tags moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: ${{ matrix.tauri_args }}
          tagName: ${{ needs.validate-version.outputs.release_tag }}
          releaseName: Formula ${{ needs.validate-version.outputs.release_tag }}
          releaseBody: |
            Automated build for ${{ needs.validate-version.outputs.release_tag }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          # Mark GitHub Releases as prereleases when the semver tag contains a
          # prerelease suffix like `-beta.1` or `-rc.0` (e.g. `v1.2.3-beta.1`).
          prerelease: ${{ contains(needs.validate-version.outputs.release_tag, '-') }}

      - name: Build desktop bundles (dry run)
        if: runner.os != 'macOS' && needs.validate-version.outputs.upload != 'true'
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: ${{ matrix.tauri_args }}

      - name: Desktop dist asset report
        if: runner.os != 'macOS'
        run: node scripts/desktop_dist_asset_report.mjs
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Verify Windows ARM64 binary architecture (AA64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $releaseCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release")
          )
          $releaseDir = $releaseCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $releaseDir) {
            $candidatesJoined = $releaseCandidates -join "`n"
            throw "windows-arm64: Expected Rust release directory not found. Looked in:`n$candidatesJoined"
          }
          $exe = Get-ChildItem -Path $releaseDir -Recurse -File -Filter "formula-desktop.exe" | Select-Object -First 1
          if (-not $exe) {
            throw "windows-arm64: Expected compiled binary formula-desktop.exe not found under: $releaseDir"
          }
          $dumpbin = Get-Command dumpbin.exe -ErrorAction SilentlyContinue
          if (-not $dumpbin) {
            throw "windows-arm64: dumpbin.exe not found on PATH (expected after MSVC dev-cmd setup)."
          }
          $headers = & dumpbin.exe /headers $exe.FullName
          $joined = ($headers -join "`n")
          $machineLine = ($headers | Select-String -Pattern "machine" -CaseSensitive:$false | Select-Object -First 1).ToString()
          Write-Host "windows-arm64: dumpbin machine line: $machineLine"
          if ($joined -notmatch "machine \\(AA64\\)") {
            throw "windows-arm64: Expected ARM64 machine type (AA64) in PE headers for $($exe.FullName). If this is x64, the ARM64 target toolchain/environment is misconfigured."
          }

      - name: Smoke test produced AppImage (extract + ldd + arch)
        if: runner.os == 'Linux'
        run: bash scripts/ci/check-appimage.sh

      - name: Verify Linux .deb package (deps + ldd + desktop integration)
        if: matrix.platform == 'ubuntu-24.04'
        shell: bash
        run: |
          set -euo pipefail
          # Preferred location (matches docs/release.md), but fall back to scanning common Cargo target dirs.
          shopt -s nullglob
          debs=(apps/desktop/src-tauri/target/release/bundle/deb/*.deb)
          shopt -u nullglob

          if ((${#debs[@]} == 0)); then
            roots=()
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              roots+=("${CARGO_TARGET_DIR}")
            fi
            roots+=("apps/desktop/src-tauri/target" "apps/desktop/target" "target")

            debs=()
            for root in "${roots[@]}"; do
              [[ -d "${root}" ]] || continue
              while IFS= read -r -d '' f; do
                debs+=("$f")
              done < <(find "${root}" -type f -path '*/release/bundle/deb/*.deb' -print0 2>/dev/null || true)
            done
          fi

          if ((${#debs[@]} == 0)); then
            echo "::error::could not find any .deb artifacts under apps/desktop/src-tauri/target/release/bundle/deb or target/**/release/bundle/deb" >&2
            echo "Debug: searched roots:" >&2
            echo "  - apps/desktop/src-tauri/target/release/bundle/deb/*.deb" >&2
            echo "  - CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-<unset>}" >&2
            echo "  - apps/desktop/src-tauri/target" >&2
            echo "  - apps/desktop/target" >&2
            echo "  - target" >&2
            exit 1
          fi

          if ((${#debs[@]} > 1)); then
            echo "Found multiple .deb artifacts; validating all:"
            printf '  - %s\n' "${debs[@]}"
          fi

          for deb in "${debs[@]}"; do
            echo "Using deb: ${deb}"

            echo "::group::dpkg -I ${deb}"
            dpkg -I "${deb}" | tee dpkg-info.txt
            echo "::endgroup::"

            # Ensure key runtime deps are declared (at least: WebKitGTK + GTK + AppIndicator).
            for needle in "webkit2gtk" "libgtk-3" "appindicator"; do
              if ! grep -qi "$needle" dpkg-info.txt; then
                echo "::error::Expected runtime dependency '$needle' missing from dpkg -I output for ${deb}"
                exit 1
              fi
            done

            tmpdir="$(mktemp -d)"
            trap 'rm -rf "${tmpdir}"' EXIT
            dpkg-deb -x "${deb}" "${tmpdir}"

            bin="${tmpdir}/usr/bin/formula-desktop"
            if [[ ! -f "${bin}" ]]; then
              echo "::error::Expected installed binary not found at ${bin} after extracting ${deb}"
              echo "Extracted file tree (first 200 entries):"
              find "${tmpdir}" -maxdepth 5 -type f -print | head -n 200
              exit 1
            fi

            echo "::group::ldd ${bin}"
            ldd "${bin}" | tee ldd.txt
            echo "::endgroup::"
            if grep -q "not found" ldd.txt; then
              echo "::error::Missing shared library dependencies detected by ldd for ${bin}"
              exit 1
            fi

            python scripts/ci/verify_linux_desktop_integration.py --deb-root "${tmpdir}"

            rm -rf "${tmpdir}"
            trap - EXIT
          done

      - name: Upload desktop bundles (dry run)
        if: needs.validate-version.outputs.upload != 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: desktop-bundles-${{ needs.validate-version.outputs.artifact_label }}-${{ matrix.platform }}${{ matrix.rust_target != '' && format('-{0}', matrix.rust_target) || '' }}
          if-no-files-found: error
          path: |
            apps/desktop/src-tauri/target/**/release/bundle/**
            target/**/release/bundle/**

      - name: Export updater manifest for merge (latest.json)
        if: needs.validate-version.outputs.upload == 'true'
        run: node scripts/ci/export-updater-manifest.mjs "updater-manifest/latest-${{ matrix.cache_target }}.json"

      - name: Upload updater manifest artifact (per-platform)
        if: needs.validate-version.outputs.upload == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: updater-manifest-${{ matrix.cache_target }}
          path: updater-manifest/latest-${{ matrix.cache_target }}.json
          if-no-files-found: error

      - name: Assert Windows installer bundle exists for target
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-bundle: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-bundle: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }

          # Wrap in @() so `.Count` behaves consistently even when 0 or 1 files match.
          #
          # Tauri Windows bundle outputs live under:
          # - bundle/msi/*.msi
          # - bundle/nsis/*.exe (and sometimes bundle/nsis-web/*.exe)
          #
          # We intentionally scope to these directories so random `.exe` files (e.g. helpers)
          # do not satisfy the "Windows installer" requirement.
          $msis = @(
            Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue
          )
          $exes = @()
          $exes += @(
            Get-ChildItem -Path (Join-Path $bundleDir "nsis") -Recurse -File -Filter "*.exe" -ErrorAction SilentlyContinue
          )
          $exes += @(
            Get-ChildItem -Path (Join-Path $bundleDir "nsis-web") -Recurse -File -Filter "*.exe" -ErrorAction SilentlyContinue
          )

          if ($msis.Count -eq 0) {
            throw "windows-bundle: ERROR missing required Windows MSI installer under: $bundleDir`n`nCommon causes:`n- WiX Toolset missing (candle.exe/light.exe not on PATH) so MSI bundling was skipped/failed`n- Tauri MSI bundler does not support target $target on this runner"
          }
          if ($exes.Count -eq 0) {
            throw "windows-bundle: ERROR missing required Windows EXE (NSIS) installer under: $bundleDir`n`nCommon causes:`n- NSIS missing (makensis.exe not on PATH) so EXE bundling was skipped/failed`n- Tauri NSIS bundler does not support target $target on this runner"
          }

          Write-Host "windows-bundle: OK (found $($msis.Count) MSI + $($exes.Count) EXE installer file(s))"
          if ($msis.Count -gt 0) {
            Write-Host "MSI installers:"
            $msis | ForEach-Object { Write-Host " - $($_.FullName)" }
          }
          if ($exes.Count -gt 0) {
            Write-Host "EXE installers:"
            $exes | ForEach-Object { Write-Host " - $($_.FullName)" }
          }

      - name: Verify Windows ARM64 MSI targets ARM64 (template summary)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-arm64-msi: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }
          $msis = @(
            Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue
          )
          if ($msis.Count -eq 0) {
            throw "windows-arm64-msi: ERROR no .msi installers found under: $bundleDir"
          }

          $installer = New-Object -ComObject WindowsInstaller.Installer
          foreach ($msi in $msis) {
            $db = $installer.OpenDatabase($msi.FullName, 0)
            $summary = $db.SummaryInformation(0)
            $template = $summary.Property(7)
            Write-Host "windows-arm64-msi: $($msi.Name) template=$template"
            if ($template -notmatch '(?i)arm64') {
              throw "windows-arm64-msi: ERROR Expected MSI Template Summary to include ARM64 for $($msi.FullName), got: $template"
            }
          }

      - name: Verify Windows installers bundle/reference WebView2 (bootstrapper/runtime)
        if: runner.os == 'Windows'
        run: python scripts/ci/check-windows-webview2-installer.py

      - name: Verify Windows installer Authenticode signatures (signtool)
        # Only run when signing secrets are configured; forks/dry-runs may intentionally build unsigned artifacts.
        if: runner.os == 'Windows' && secrets.WINDOWS_CERTIFICATE != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-sigcheck: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }
          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-sigcheck: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }
          python scripts/ci/check-windows-installer-signatures.py --bundle-dir "$bundleDir"

      - name: Verify Linux release artifacts (AppImage + deb + rpm + signatures)
        if: matrix.platform == 'ubuntu-24.04'
        shell: bash
        env:
          FORMULA_HAS_TAURI_UPDATER_KEY: ${{ secrets.TAURI_PRIVATE_KEY != '' }}
          # Updater signature files (`*.sig`) are only generated when the updater private key is
          # configured. Forks/dry-runs often have no secrets, so we skip `.sig` validation there.
          #
          # In the upstream repo we *require* updater signatures to avoid accidentally publishing
          # a release without auto-update metadata/signatures.
          FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES: ${{ github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '' }}
        run: |
          set -euo pipefail

          # Tauri bundles normally live under `src-tauri/target/release/bundle`, but can also
          # end up under `src-tauri/target/<triple>/release/bundle` if `--target` is used.
          bundle_roots=()
          # Prefer `CARGO_TARGET_DIR` if it's set (some Tauri builds export it), but also scan the
          # common workspace/default target roots.
          if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
            cargo_target_dir="${CARGO_TARGET_DIR}"
            if [[ "${cargo_target_dir}" != /* ]]; then
              cargo_target_dir="${PWD}/${cargo_target_dir}"
            fi
            if [[ -d "${cargo_target_dir}" ]]; then
              bundle_roots+=("${cargo_target_dir}")
            fi
          fi
          for root in "apps/desktop/src-tauri/target" "apps/desktop/target" "target"; do
            if [[ -d "$root" ]]; then
              bundle_roots+=("$root")
            fi
          done
          if ((${#bundle_roots[@]} == 0)); then
            echo "Expected Tauri target directory not found. Looked in: CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-} apps/desktop/src-tauri/target apps/desktop/target target" >&2
            exit 1
          fi

          # Canonicalize + de-dupe bundle roots (avoid duplicate scanning when CARGO_TARGET_DIR overlaps defaults).
          declare -A seen_bundle_roots=()
          uniq_bundle_roots=()
          for root in "${bundle_roots[@]}"; do
            abs="$(cd "$root" && pwd -P)"
            if [[ -n "${seen_bundle_roots[${abs}]:-}" ]]; then
              continue
            fi
            seen_bundle_roots["${abs}"]=1
            uniq_bundle_roots+=("${abs}")
          done
          bundle_roots=("${uniq_bundle_roots[@]}")

          # Use predictable bundle globs (fast) rather than `find` (which traverses the entire Cargo target dir).
          shopt -s nullglob
          appimages=()
          debs=()
          rpms=()
          for root in "${bundle_roots[@]}"; do
            appimages+=("$root"/release/bundle/appimage/*.AppImage)
            appimages+=("$root"/*/release/bundle/appimage/*.AppImage)
            debs+=("$root"/release/bundle/deb/*.deb)
            debs+=("$root"/*/release/bundle/deb/*.deb)
            rpms+=("$root"/release/bundle/rpm/*.rpm)
            rpms+=("$root"/*/release/bundle/rpm/*.rpm)
          done
          shopt -u nullglob

          if ((${#appimages[@]} > 0)); then mapfile -t appimages < <(printf '%s\n' "${appimages[@]}" | sort -u); fi
          if ((${#debs[@]} > 0)); then mapfile -t debs < <(printf '%s\n' "${debs[@]}" | sort -u); fi
          if ((${#rpms[@]} > 0)); then mapfile -t rpms < <(printf '%s\n' "${rpms[@]}" | sort -u); fi

          echo "Bundle outputs:"
          printf '  AppImage: %s\n' "${#appimages[@]}"
          printf '  deb:      %s\n' "${#debs[@]}"
          printf '  rpm:      %s\n' "${#rpms[@]}"

          if ((${#appimages[@]} == 0)); then
            echo "Missing required Linux artifact: .AppImage" >&2
            exit 1
          fi
          if ((${#debs[@]} == 0)); then
            echo "Missing required Linux artifact: .deb" >&2
            exit 1
          fi
          if ((${#rpms[@]} == 0)); then
            echo "Missing required Linux artifact: .rpm" >&2
            exit 1
          fi

          if [[ "${FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES}" == "true" && "${FORMULA_HAS_TAURI_UPDATER_KEY}" != "true" ]]; then
            echo "TAURI_PRIVATE_KEY is required to validate updater signatures but is not configured." >&2
            exit 1
          fi

          if [[ "${FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES}" == "true" ]]; then
            # Ensure updater signature files exist for each bundle type.
            for artifact in "${appimages[@]}" "${debs[@]}" "${rpms[@]}"; do
              if [[ ! -f "${artifact}.sig" ]]; then
                echo "Missing signature file for ${artifact} (expected ${artifact}.sig)" >&2
                exit 1
              fi
            done
          else
            echo "TAURI_PRIVATE_KEY not configured; skipping updater signature (*.sig) verification."
          fi

      - name: Verify Linux package dependency metadata (deb + rpm)
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/verify-linux-package-deps.sh

      - name: Verify macOS universal binary (lipo)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Locate the packaged `.app` under the Tauri bundle output directory and verify the
          # main executable is a universal binary (x86_64 + arm64).
          #
          # Prefer the universal target output (`**/universal-apple-darwin/**`) to avoid
          # accidentally validating an intermediate single-arch bundle.
          app_path=""

          app_path="$(
            find apps/desktop/src-tauri/target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
          )"
          if [[ -z "$app_path" ]]; then
            # Some Tauri builds export `CARGO_TARGET_DIR`. Check it next so this verification stays
            # correct even if the workflow tweaks target dir routing for caching.
            cargo_target_dir="${CARGO_TARGET_DIR:-}"
            if [[ -n "$cargo_target_dir" && "$cargo_target_dir" != /* ]]; then
              cargo_target_dir="${PWD}/${cargo_target_dir}"
            fi
            if [[ -n "$cargo_target_dir" && -d "$cargo_target_dir" ]]; then
              app_path="$(
                find "$cargo_target_dir/universal-apple-darwin" -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
              )"
              if [[ -z "$app_path" ]]; then
                app_path="$(
                  find "$cargo_target_dir" -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
                )"
              fi
            fi
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/src-tauri/target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi

          if [[ -z "$app_path" ]]; then
            echo "::error::No .app bundle found under the expected Cargo target directories (CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-})." >&2
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              echo
              echo "CARGO_TARGET_DIR *.app bundles:"
              find "${cargo_target_dir}" -type d -name '*.app' -print 2>/dev/null || true
            fi
            echo "apps/desktop/src-tauri/target *.app bundles:"
            find apps/desktop/src-tauri/target -type d -name '*.app' -print 2>/dev/null || true
            echo
            echo "apps/desktop/target *.app bundles:"
            find apps/desktop/target -type d -name '*.app' -print 2>/dev/null || true
            echo
            echo "target *.app bundles:"
            find target -type d -name '*.app' -print 2>/dev/null || true
            exit 1
          fi

          echo "Found app bundle: $app_path"
          macos_dir="$app_path/Contents/MacOS"
          if [[ ! -d "$macos_dir" ]]; then
            echo "::error::Expected Contents/MacOS directory not found: $macos_dir" >&2
            find "$app_path/Contents" -maxdepth 2 -print 2>/dev/null || true
            exit 1
          fi

          # Prefer the bundle-declared executable (CFBundleExecutable) so this check stays correct
          # even if the binary name changes.
          exe_name=""
          info_plist="$app_path/Contents/Info.plist"
          if [[ -f "$info_plist" ]]; then
            exe_name="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$info_plist" 2>/dev/null || true)"
          fi
          if [[ -z "$exe_name" ]]; then
            exe_name="formula-desktop"
          fi

          bin_path="$macos_dir/$exe_name"
          if [[ ! -f "$bin_path" ]]; then
            # Fall back to the first executable file under Contents/MacOS (avoid picking non-binaries).
            bin_path="$(find "$macos_dir" -maxdepth 1 -type f -perm -0100 -print | head -n 1 || true)"
          fi
          if [[ -z "$bin_path" || ! -f "$bin_path" ]]; then
            echo "::error::Could not find app executable under $macos_dir" >&2
            ls -la "$macos_dir" || true
            exit 1
          fi

          echo "Checking architectures for: $bin_path"
          info="$(lipo -info "$bin_path" | tee /dev/stderr)"
          echo "$info" | grep -qw "x86_64" || { echo "::error::macOS binary is missing x86_64 slice"; exit 1; }
          echo "$info" | grep -qw "arm64" || { echo "::error::macOS binary is missing arm64 slice"; exit 1; }

      - name: Verify Windows installers are Authenticode-signed
        if: runner.os == 'Windows' && ((secrets.WINDOWS_CERTIFICATE != '' && secrets.WINDOWS_CERTIFICATE_PASSWORD != '') || vars.FORMULA_REQUIRE_CODESIGN == '1')
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Use signtool for signature validation; it provides more actionable chain/errors than
          # `Get-AuthenticodeSignature` and matches the Windows signing toolchain.
          $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue)?.Source
          if (-not $signtool) {
            $kitsRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\bin"
            if (Test-Path $kitsRoot) {
              $signtool = Get-ChildItem -Path $kitsRoot -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
                Sort-Object FullName -Descending |
                Select-Object -First 1 |
                ForEach-Object { $_.FullName }
            }
          }

          if (-not $signtool) {
            throw "signtool.exe not found (required to verify Authenticode signatures)."
          }

          Write-Host "Using signtool: $signtool"

          # Tauri Windows bundles are emitted under src-tauri/target/**/release/bundle/**.
          # We only enforce signature validity when Windows signing secrets are present (or when
          # FORMULA_REQUIRE_CODESIGN is enabled) so forks/dry runs skip this check cleanly.
          # Cargo workspaces typically emit bundles under `<repo>/target/**`, but standalone Tauri
          # builds may use `apps/desktop/src-tauri/target/**`. Support both so we don't break
          # releases if the build output layout changes.
          $searchRoots = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target"),
            (Join-Path $env:GITHUB_WORKSPACE "target")
          ) | Where-Object { Test-Path $_ }

          if ($searchRoots.Count -eq 0) {
            throw "Expected build output directory not found. Looked for:`n- apps/desktop/src-tauri/target`n- target"
          }

          # Wrap in @() so `.Count` behaves consistently even when 0 or 1 files match.
          $installers = @(Get-ChildItem -Path $searchRoots -Recurse -File -Include *.exe, *.msi |
            Where-Object { $_.FullName -match '[\\/]release[\\/]bundle[\\/]' })

          if ($installers.Count -eq 0) {
            throw "No Windows installers (.exe/.msi) found under target/**/release/bundle/**"
          }

          Write-Host "Found $($installers.Count) installer file(s) to verify:"
          $installers | ForEach-Object { Write-Host " - $($_.FullName)" }

          foreach ($file in $installers) {
            Write-Host "::group::signtool verify /pa /v $($file.FullName)"
            Write-Host "Verifying Authenticode signature for: $($file.FullName)"
            & $signtool verify /pa /v $file.FullName
            if ($LASTEXITCODE -ne 0) {
              throw "codesign-verify: ERROR signtool verification failed for: $($file.FullName)"
            }
            Write-Host "::endgroup::"
          }

      - name: Validate macOS notarization + stapling (Gatekeeper)
        if: ${{ runner.os == 'macOS' && secrets.APPLE_CERTIFICATE != '' && secrets.APPLE_CERTIFICATE_PASSWORD != '' && secrets.APPLE_ID != '' && secrets.APPLE_PASSWORD != '' && secrets.APPLE_TEAM_ID != '' }}
        working-directory: apps/desktop/src-tauri
        shell: bash
        run: |
          set -euo pipefail

          echo "Validating macOS release artifacts are notarized and stapled (Gatekeeper-ready)."
          echo "Working dir: $(pwd)"

          # Tauri builds may emit bundles under either:
          # - apps/desktop/src-tauri/target (tauri sets CARGO_TARGET_DIR)
          # - <repo>/target (Cargo workspace default)
          #
          # Search both so we fail only when the artifacts truly are missing.
          target_roots=()
          if [[ -n "${GITHUB_WORKSPACE:-}" ]]; then
            [[ -d "$GITHUB_WORKSPACE/apps/desktop/src-tauri/target" ]] && target_roots+=("$GITHUB_WORKSPACE/apps/desktop/src-tauri/target")
            [[ -d "$GITHUB_WORKSPACE/target" ]] && target_roots+=("$GITHUB_WORKSPACE/target")
          else
            [[ -d target ]] && target_roots+=("$(pwd)/target")
            [[ -d ../../../target ]] && target_roots+=("$(cd ../../../target && pwd)")
          fi

          if [[ ${#target_roots[@]} -eq 0 ]]; then
            echo "::error::No Cargo target directory found to scan for macOS bundle artifacts."
            echo "Looked for:"
            echo "  - apps/desktop/src-tauri/target"
            echo "  - target"
            exit 1
          fi

          echo "Target directories:"
          printf '  - %s\n' "${target_roots[@]}"

          # Tauri bundler outputs (examples):
          # - target/release/bundle/dmg/*.dmg
          # - target/release/bundle/macos/*.app
          # - target/<triple>/release/bundle/... (when building for non-host targets)
          #
          # Avoid scanning the entire Cargo target directory (can be huge); only look in the expected
          # `release/bundle` directories.
          bundle_dirs=()
          for root in "${target_roots[@]}"; do
            if [[ -d "$root/release/bundle" ]]; then
              bundle_dirs+=("$root/release/bundle")
            fi
            for dir in "$root"/*/release/bundle; do
              [[ -d "$dir" ]] || continue
              bundle_dirs+=("$dir")
            done
          done

          if [[ ${#bundle_dirs[@]} -eq 0 ]]; then
            echo "::error::No Tauri bundle directories found under the Cargo target directories."
            echo "Expected at least one: target/**/release/bundle"
            exit 1
          fi

          echo "Bundle directories:"
          printf '  - %s\n' "${bundle_dirs[@]}"

          # Avoid bash `mapfile` (not available on macOS's system bash 3.x).
          dmgs=()
          apps=()
          tarballs=()

          for bundle_dir in "${bundle_dirs[@]}"; do
            while IFS= read -r -d '' dmg; do
              dmgs+=("$dmg")
            done < <(find "$bundle_dir" -maxdepth 3 -type f -name "*.dmg" -print0)

            # Prune at the first matching .app so we don't accidentally validate nested helper apps.
            while IFS= read -r -d '' app; do
              apps+=("$app")
            done < <(find "$bundle_dir" -maxdepth 2 -type d -name "*.app" -prune -print0)

            # Tauri's macOS updater artifact is typically a tarball (e.g. `Formula.app.tar.gz`).
            # Validate the `.app` inside the archive as well to ensure the updater payload is
            # stapled/notarized, not just the standalone bundle output.
            while IFS= read -r -d '' archive; do
              tarballs+=("$archive")
            done < <(find "$bundle_dir" -maxdepth 2 -type f \( -name "*.tar.gz" -o -name "*.tgz" \) -path "*/macos/*" -print0)
          done

          if [[ ${#dmgs[@]} -eq 0 && ${#apps[@]} -eq 0 ]]; then
            echo "::error::No macOS bundle artifacts (.dmg or .app) were found under target/**/release/bundle/**."
            echo "This step runs only when APPLE_* notarization secrets are configured, and is meant to"
            echo "guarantee tagged releases produce Gatekeeper-ready artifacts (notarized + stapled)."
            echo
            echo "Expected output paths include:"
            echo "  apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg"
            echo "  apps/desktop/src-tauri/target/release/bundle/macos/*.app"
            exit 1
          fi

          echo "Found artifacts:"
          if [[ ${#dmgs[@]} -gt 0 ]]; then
            printf '  - %s\n' "${dmgs[@]}"
          fi
          if [[ ${#apps[@]} -gt 0 ]]; then
            printf '  - %s\n' "${apps[@]}"
          fi
          if [[ ${#tarballs[@]} -gt 0 ]]; then
            printf '  - %s\n' "${tarballs[@]}"
          fi

          fail=0

          validate_dmg() {
            local dmg="$1"
            echo "::group::Validate notarization for DMG: $dmg"

            # Requires the DMG to have a stapled ticket for offline Gatekeeper validation.
            if ! xcrun stapler validate "$dmg"; then
              echo "::error::DMG is not stapled (missing notarization ticket): $dmg"
              fail=1
            fi

            # Gatekeeper assessment for disk images.
            if ! spctl -a -vv --type open "$dmg"; then
              echo "::error::Gatekeeper rejected DMG (not notarized?): $dmg"
              fail=1
            fi

            echo "::endgroup::"
          }

          validate_app() {
            local app="$1"
            echo "::group::Validate notarization for app: $app"

            # Ensure the `.app` bundle is actually signed (including nested frameworks).
            if ! codesign --verify --deep --strict --verbose=2 "$app"; then
              echo "::error::codesign verification failed for app bundle: $app"
              fail=1
            fi

            if ! xcrun stapler validate "$app"; then
              echo "::error::App bundle is not stapled (missing notarization ticket): $app"
              fail=1
            fi

            # Gatekeeper assessment for executables / app bundles.
            if ! spctl -a -vv --type execute "$app"; then
              echo "::error::Gatekeeper rejected app bundle (not notarized?): $app"
              fail=1
            fi

            echo "::endgroup::"
          }

          validate_apps_inside_dmg() {
            local dmg="$1"
            local mount_dir
            mount_dir="$(mktemp -d)"

            echo "::group::Validate .app inside DMG: $dmg"

            if hdiutil attach "$dmg" -nobrowse -readonly -mountpoint "$mount_dir" >/dev/null; then
              mounted_apps=()
              while IFS= read -r -d '' app; do
                mounted_apps+=("$app")
              done < <(find "$mount_dir" -maxdepth 2 -type d -name "*.app" -prune -print0)

              if [[ ${#mounted_apps[@]} -eq 0 ]]; then
                echo "::error::Mounted DMG but did not find a .app bundle inside: $dmg"
                fail=1
              else
                for app in "${mounted_apps[@]}"; do
                  validate_app "$app"
                done
              fi

              hdiutil detach "$mount_dir" >/dev/null || hdiutil detach "$mount_dir" -force >/dev/null || true
            else
              echo "::error::Failed to mount DMG for validation: $dmg"
              fail=1
            fi

            rm -rf "$mount_dir" || true
            echo "::endgroup::"
          }

          validate_apps_inside_archive() {
            local archive="$1"
            local extract_dir
            extract_dir="$(mktemp -d)"

            echo "::group::Validate .app inside archive: $archive"

            if tar -xzf "$archive" -C "$extract_dir"; then
              extracted_apps=()
              while IFS= read -r -d '' app; do
                extracted_apps+=("$app")
              done < <(find "$extract_dir" -maxdepth 3 -type d -name "*.app" -prune -print0)

              if [[ ${#extracted_apps[@]} -eq 0 ]]; then
                echo "::error::Extracted updater archive but did not find a .app bundle inside: $archive"
                fail=1
              else
                for app in "${extracted_apps[@]}"; do
                  validate_app "$app"
                done
              fi
            else
              echo "::error::Failed to extract updater archive for validation: $archive"
              fail=1
            fi

            rm -rf "$extract_dir" || true
            echo "::endgroup::"
          }

          for dmg in "${dmgs[@]}"; do
            validate_dmg "$dmg"
            validate_apps_inside_dmg "$dmg"
          done

          for app in "${apps[@]}"; do
            validate_app "$app"
          done

          for archive in "${tarballs[@]}"; do
            validate_apps_inside_archive "$archive"
          done

          if [[ "$fail" -ne 0 ]]; then
            echo "::error::macOS notarization/stapling validation failed."
            echo "The release build produced artifacts, but at least one was rejected by Gatekeeper or"
            echo "missing a stapled notarization ticket."
            echo
            echo "Troubleshooting:"
            echo "  - Confirm Apple signing + notarization secrets are configured:"
            echo "    - APPLE_CERTIFICATE / APPLE_CERTIFICATE_PASSWORD / APPLE_SIGNING_IDENTITY"
            echo "    - APPLE_ID / APPLE_PASSWORD / APPLE_TEAM_ID"
            echo "  - Check the tauri-action logs for notarization/stapling output."
            exit 1
          fi

          echo "macOS notarization/stapling validation passed."

      - name: Verify Windows ARM64 binary (formula-desktop.exe is AA64)
        if: matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $exeCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/formula-desktop.exe'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/formula-desktop.exe')
          )
          $exe = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$exe) {
            Write-Error "Expected ARM64 executable not found. Looked in:`n$($exeCandidates -join [Environment]::NewLine)`nDid the build run with --target aarch64-pc-windows-msvc?"
            exit 1
          }

          # Locate dumpbin from the installed Visual Studio toolchain.
          $vswhere = Join-Path ${env:ProgramFiles(x86)} 'Microsoft Visual Studio/Installer/vswhere.exe'
          if (!(Test-Path $vswhere)) {
            Write-Error "vswhere.exe not found at: $vswhere"
            exit 1
          }

          $vsInstall = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
          if (!$vsInstall) {
            Write-Error 'Unable to locate a Visual Studio installation via vswhere.'
            exit 1
          }

          $msvcRoot = Join-Path $vsInstall 'VC/Tools/MSVC'
          if (!(Test-Path $msvcRoot)) {
            Write-Error "MSVC tools dir not found at: $msvcRoot"
            exit 1
          }

          $dumpbin = Get-ChildItem -Path $msvcRoot -Filter dumpbin.exe -Recurse -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match '\\bin\\Hostx64\\x64\\dumpbin\.exe$' } |
            Sort-Object -Property FullName -Descending |
            Select-Object -First 1

          if (!$dumpbin) {
            Write-Error "dumpbin.exe not found under: $msvcRoot"
            exit 1
          }

          $headers = & $dumpbin.FullName /headers $exe
          $headersText = ($headers | Out-String)
          Write-Host $headersText

          if ($headersText -notmatch 'AA64') {
            Write-Error "Expected ARM64 machine type 'AA64' in dumpbin output, but it was not found."
            exit 1
          }

          if ($headersText -match '8664') {
            Write-Error "Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
            exit 1
          }

      - name: Verify Windows ARM64 updater signatures exist
        if: matrix.rust_target == 'aarch64-pc-windows-msvc' && secrets.TAURI_PRIVATE_KEY != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/bundle')
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$bundleDir) {
            Write-Error "Bundle output dir not found. Looked in:`n$($bundleCandidates -join [Environment]::NewLine)"
            exit 1
          }

          $sigs = Get-ChildItem -Path $bundleDir -Recurse -File -Filter '*.sig'
          if ($sigs.Count -lt 1) {
            Write-Error "No updater signature files (*.sig) found under: $bundleDir"
            exit 1
          }

          Write-Host "Found updater signatures:"
          $sigs | ForEach-Object { Write-Host "- $($_.FullName)" }

      - name: Validate desktop release artifacts
        env:
          FORMULA_HAS_TAURI_UPDATER_KEY: ${{ secrets.TAURI_PRIVATE_KEY != '' }}
          # `latest.json` is only generated/uploaded when we publish to a GitHub Release.
          # In dry-run (workflow_dispatch upload=false) we still validate installer artifacts exist,
          # but we skip enforcing updater signatures/manifest files.
          FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES: ${{ needs.validate-version.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '') }}
        run: node scripts/ci/check-desktop-release-artifacts.mjs

      - name: Verify macOS bundle file associations + deep link schemes
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Prefer the universal build output path, but fall back to any `.app` under the bundle dirs.
          app_path="$(
            find apps/desktop/src-tauri/target -type d -path '*/release/bundle/macos/*.app' -prune -print 2>/dev/null | head -n 1 || true
          )"
          if [[ -z "${app_path}" ]]; then
            app_path="$(
              find target -type d -path '*/release/bundle/macos/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "${app_path}" ]]; then
            echo "::error::Could not find a built .app bundle under apps/desktop/src-tauri/target/**/release/bundle/macos" >&2
            find apps/desktop/src-tauri/target -maxdepth 12 -type d -name '*.app' -print | head -n 20 || true
            find target -maxdepth 12 -type d -name '*.app' -print | head -n 20 || true
            exit 1
          fi

          info_plist="${app_path}/Contents/Info.plist"
          if [[ ! -f "${info_plist}" ]]; then
            echo "::error::Missing Info.plist at: ${info_plist}" >&2
            exit 1
          fi

          echo "App bundle: ${app_path}"
          echo "Info.plist: ${info_plist}"
          echo "::group::plutil -p ${info_plist} (first 200 lines)"
          plutil -p "${info_plist}" | head -n 200
          echo "::endgroup::"

          python scripts/ci/verify_macos_bundle_associations.py --info-plist "${info_plist}"

      - name: Verify Linux desktop integration in packages (.deb + .rpm)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail

          deb="$(find apps/desktop/src-tauri/target target -type f -path '*/release/bundle/deb/*.deb' -print 2>/dev/null | head -n 1 || true)"
          if [[ -z "${deb}" ]]; then
            echo "::error::Could not find a .deb under apps/desktop/src-tauri/target/**/release/bundle/deb" >&2
            find apps/desktop/src-tauri/target -maxdepth 10 -type f -name '*.deb' -print | head -n 20 || true
            find target -maxdepth 10 -type f -name '*.deb' -print | head -n 20 || true
            exit 1
          fi

          echo "Validating .deb desktop integration: ${deb}"
          tmpdir_deb="$(mktemp -d)"
          dpkg-deb -x "${deb}" "${tmpdir_deb}"
          python scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_deb}"

          rpm_path="$(find apps/desktop/src-tauri/target target -type f -path '*/release/bundle/rpm/*.rpm' -print 2>/dev/null | head -n 1 || true)"
          if [[ -z "${rpm_path}" ]]; then
            echo "::error::Could not find a .rpm under apps/desktop/src-tauri/target/**/release/bundle/rpm" >&2
            find apps/desktop/src-tauri/target -maxdepth 10 -type f -name '*.rpm' -print | head -n 20 || true
            find target -maxdepth 10 -type f -name '*.rpm' -print | head -n 20 || true
            exit 1
          fi

          if ! command -v rpm2cpio >/dev/null 2>&1; then
            echo "::error::rpm2cpio is required to extract .rpm artifacts for validation (missing on PATH)" >&2
            exit 1
          fi
          if ! command -v cpio >/dev/null 2>&1; then
            echo "::error::cpio is required to extract .rpm artifacts for validation (missing on PATH)" >&2
            exit 1
          fi

          echo "Validating .rpm desktop integration: ${rpm_path}"
          tmpdir_rpm="$(mktemp -d)"
          (cd "${tmpdir_rpm}" && rpm2cpio "${rpm_path}" | cpio -idm --quiet --no-absolute-filenames)
          python scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_rpm}"

      - name: Smoke test Linux .deb install in clean Ubuntu container
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/linux-package-install-smoke.sh deb

      - name: Smoke test Linux .rpm install in clean Fedora container
        if: matrix.platform == 'ubuntu-24.04'
        run: bash scripts/ci/linux-package-install-smoke.sh rpm
      - name: Dump macOS effective entitlements (codesign) (signed builds only)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          # Only run when signing secrets are configured. On forks/dry-runs we build unsigned
          # artifacts (see `scripts/ci/prepare-tauri-signing-config.mjs`).
          if [[ -z "${APPLE_CERTIFICATE:-}" || -z "${APPLE_CERTIFICATE_PASSWORD:-}" ]]; then
            echo "Skipping entitlements dump: macOS signing secrets not configured (unsigned build)."
            exit 0
          fi

          search_roots=(target apps/desktop/src-tauri/target)
          app_path=""
          for root in "${search_roots[@]}"; do
            if [[ -d "$root" ]]; then
              candidate="$(find "$root" -type d -path "*/release/bundle/macos/Formula.app" | head -n 1 || true)"
              if [[ -n "$candidate" ]]; then
                app_path="$candidate"
                break
              fi
            fi
          done

          if [[ -z "$app_path" ]]; then
            for root in "${search_roots[@]}"; do
              if [[ -d "$root" ]]; then
                candidate="$(find "$root" -type d -path "*/release/bundle/macos/*.app" | head -n 1 || true)"
                if [[ -n "$candidate" ]]; then
                  app_path="$candidate"
                  break
                fi
              fi
            done
          fi

          if [[ -z "$app_path" ]]; then
            echo "No .app bundle found under expected Tauri bundle roots; skipping."
            exit 0
          fi

          echo "Found app bundle: $app_path"

          echo "::group::codesign --verify $app_path"
          if ! /usr/bin/codesign --verify --deep --strict --verbose=2 "$app_path"; then
            echo "::error::codesign verification failed for app bundle: $app_path" >&2
            exit 1
          fi
          echo "::endgroup::"

          exe_path="$app_path/Contents/MacOS/formula-desktop"
          if [[ ! -f "$exe_path" ]]; then
            exe_path="$(find "$app_path/Contents/MacOS" -maxdepth 1 -type f | head -n 1 || true)"
          fi

          if [[ -z "$exe_path" || ! -f "$exe_path" ]]; then
            echo "Could not locate main executable inside: $app_path"
            exit 0
          fi

          echo "Dumping effective entitlements from: $exe_path"
          /usr/bin/codesign -d --entitlements :- "$exe_path" || true
      - name: Verify desktop binary is stripped (no symbols)
        run: python scripts/verify_desktop_binary_stripped.py

      - name: Verify macOS bundle file associations + URL scheme
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          app_bundle="$(find apps/desktop/src-tauri/target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true)"
          if [[ -z "${app_bundle}" ]]; then
            echo "ERROR: could not find a .app bundle under apps/desktop/src-tauri/target/**/release/bundle" >&2
            find apps/desktop/src-tauri/target -maxdepth 12 -type d -name '*.app' -print | head -n 20 || true
            exit 1
          fi
          info_plist="${app_bundle}/Contents/Info.plist"
          if [[ ! -f "${info_plist}" ]]; then
            echo "ERROR: missing Info.plist at ${info_plist}" >&2
            exit 1
          fi
          echo "App bundle: ${app_bundle}"
          echo "Info.plist: ${info_plist}"
          echo "--- plutil -p Info.plist (first 200 lines) ---"
          plutil -p "${info_plist}" | head -n 200
          echo "--- end plutil output ---"
          python scripts/ci/verify_macos_bundle_associations.py --info-plist "${info_plist}"
      - name: Report desktop bundle sizes
        env:
          # Enforce the bundle size budget on tagged releases by default.
          # Override via GitHub Actions "Variables":
          # - FORMULA_ENFORCE_BUNDLE_SIZE=0 (or "false") to disable enforcement
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE || '1' }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        run: python scripts/desktop_bundle_size_report.py --json desktop-bundle-size-report.json

      - name: Upload desktop bundle size report (JSON)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: desktop-bundle-size-report-${{ needs.validate-version.outputs.artifact_label }}-${{ matrix.platform }}${{ matrix.rust_target != '' && format('-{0}', matrix.rust_target) || '' }}
          path: desktop-bundle-size-report.json
          if-no-files-found: warn

  publish-updater-manifest:
    name: Publish combined updater manifest (latest.json)
    needs: [build, validate-version]
    # Publishing `latest.json` requires updater signatures (`latest.json.sig`) which are only
    # produced when TAURI_PRIVATE_KEY is configured. We only publish in the upstream repo or when
    # forks have configured their own updater key secrets.
    if: needs.validate-version.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download per-platform updater manifests
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: updater-manifest-*
          path: updater-manifest
          merge-multiple: true

      - name: Publish combined updater manifest (latest.json + latest.json.sig)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: node scripts/ci/publish-updater-manifest.mjs "${{ needs.validate-version.outputs.release_tag }}" updater-manifest

  validate-updater-manifest:
    name: Validate combined updater manifest (latest.json)
    needs: [publish-updater-manifest, validate-version]
    # Validating the updater manifest requires updater signatures (`latest.json.sig`), which are
    # only produced when the TAURI_PRIVATE_KEY secret is configured. We always validate in the
    # upstream repo (to avoid accidentally shipping an unsigned updater manifest) and validate in
    # forks only when the user has configured their own updater key secrets.
    if: needs.validate-version.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Validate updater manifest assets + targets
        env:
          # The validator uses the GitHub API to read/download assets from the draft release.
          # Set both token env vars so it works whether it looks for GH_TOKEN or GITHUB_TOKEN.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/verify-tauri-latest-json.mjs "${{ needs.validate-version.outputs.release_tag }}"

      - name: Verify updater manifest signature matches embedded pubkey
        run: node scripts/ci/verify-updater-manifest-signature.mjs latest.json latest.json.sig

      - name: Verify updater asset set (installers + signatures)
        env:
          # This validator also uses the GitHub API to read/download assets from the draft release.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/verify-tauri-updater-assets.mjs "${{ needs.validate-version.outputs.release_tag }}"
  verify-release-assets:
    name: Verify GitHub Release assets (multi-arch safe)
    needs: [build, validate-version]
    if: needs.validate-version.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      - name: Validate release assets are present and uniquely named per target
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ needs.validate-version.outputs.release_tag }}
        shell: bash
        run: |
          set -euo pipefail

          repo="${GITHUB_REPOSITORY}"
          tag="${TAG_NAME}"

          api_base="${GITHUB_API_URL:-https://api.github.com}"
          api_base="${api_base%/}"
          api_url="${api_base}/repos/${repo}/releases/tags/${tag}"
          retry_delays=(2 4 8 12 20)
          # Tauri output naming varies slightly between bundlers (e.g. "x64", "x86_64", "x86-64", "amd64", "win64").
          # Treat these as equivalent x64 markers for collision detection.
          win_x64_re='(x64|x86[_-]64|amd64|win64)'
          win_arm64_re='(arm64|aarch64)'

          fetch_release() {
            curl -sSfL \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H 'Accept: application/vnd.github+json' \
              -H 'X-GitHub-Api-Version: 2022-11-28' \
              "${api_url}"
          }

          fetch_assets() {
            local release_id="$1"
            local per_page=100
            local page=1
            local all='[]'

            while :; do
              page_json="$(curl -sSfL \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H 'Accept: application/vnd.github+json' \
                -H 'X-GitHub-Api-Version: 2022-11-28' \
                "${api_base}/repos/${repo}/releases/${release_id}/assets?per_page=${per_page}&page=${page}")"

              all="$(jq -s '.[0] + .[1]' <(echo "$all") <(echo "$page_json"))"

              page_len="$(echo "$page_json" | jq -r 'length')"
              if [[ "$page_len" -lt "$per_page" ]]; then
                break
              fi
              page=$((page + 1))
            done

            echo "$all"
          }

          # Returns 0 if all required assets are present; 1 otherwise.
          assets_ready() {
            local json="$1"

            local missing=0

            count_matches() {
              local re="$1"
              echo "$json" | jq -r --arg re "$re" '[.[].name | select(test($re; "i"))] | length'
            }

            require_min() {
              local label="$1"
              local re="$2"
              local min="$3"
              local count
              count="$(count_matches "$re")"
              if [[ "$count" -lt "$min" ]]; then
                echo "missing: ${label} (pattern: ${re}, found: ${count}, expected >= ${min})" >&2
                missing=1
              fi
            }

            require_min "latest.json" '^latest\.json$' 1
            require_min "latest.json.sig" '^latest\.json\.sig$' 1
            require_min "macOS DMG" '\.dmg$' 1
            require_min "macOS app archive (.app.tar.gz)" '\.app\.tar\.gz$' 1
            require_min "macOS DMG signature" '\.dmg\.sig$' 1
            require_min "macOS app archive signature (.app.tar.gz.sig)" '\.app\.tar\.gz\.sig$' 1

            # Windows multi-arch: ensure distinct installers per architecture were uploaded.
            count_windows_arch() {
              local ext_re="$1"
              local arch_re="$2"
              local other_arch_re="$3"
              echo "$json" | jq -r --arg ext "$ext_re" --arg arch "$arch_re" --arg other "$other_arch_re" '[.[].name
                | select(test($ext; "i"))
                | select(test($arch; "i"))
                | select(test($other; "i") | not)
              ] | length'
            }

            win_x64_msi_count="$(count_windows_arch '\\.msi$' "$win_x64_re" "$win_arm64_re")"
            win_x64_exe_count="$(count_windows_arch '\\.exe$' "$win_x64_re" "$win_arm64_re")"
            win_arm64_msi_count="$(count_windows_arch '\\.msi$' "$win_arm64_re" "$win_x64_re")"
            win_arm64_exe_count="$(count_windows_arch '\\.exe$' "$win_arm64_re" "$win_x64_re")"

            if [[ "$win_x64_msi_count" -lt 1 ]]; then
              echo "missing: Windows x64 MSI (expected >= 1, found ${win_x64_msi_count})" >&2
              missing=1
            fi
            if [[ "$win_x64_exe_count" -lt 1 ]]; then
              echo "missing: Windows x64 EXE (expected >= 1, found ${win_x64_exe_count})" >&2
              missing=1
            fi
            if [[ "$win_arm64_msi_count" -lt 1 ]]; then
              echo "missing: Windows arm64 MSI (expected >= 1, found ${win_arm64_msi_count})" >&2
              missing=1
            fi
            if [[ "$win_arm64_exe_count" -lt 1 ]]; then
              echo "missing: Windows arm64 EXE (expected >= 1, found ${win_arm64_exe_count})" >&2
              missing=1
            fi

            # Linux artifacts shipped on tagged releases.
            require_min "Linux AppImage" '\.AppImage$' 1
            require_min "Linux DEB" '\.deb$' 1
            require_min "Linux RPM" '\.rpm$' 1
            require_min "Linux AppImage signature" '\.AppImage\.sig$' 1
            require_min "Linux DEB signature" '\.deb\.sig$' 1
            require_min "Linux RPM signature" '\.rpm\.sig$' 1

            windows_archless_count="$(echo "$json" | jq -r --arg x64 "$win_x64_re" --arg arm64 "$win_arm64_re" '[.[].name
              | select(test("\\.(msi|exe)$"; "i"))
              | select((test($x64; "i") or test($arm64; "i")) | not)
            ] | length')"
            if [[ "$windows_archless_count" -ne 0 ]]; then
              echo "missing: found ${windows_archless_count} Windows installer asset(s) without an arch token" >&2
              missing=1
            fi

            windows_ambiguous_count="$(echo "$json" | jq -r --arg x64 "$win_x64_re" --arg arm64 "$win_arm64_re" '[.[].name
              | select(test("\\.(msi|exe)$"; "i"))
              | select(test($x64; "i"))
              | select(test($arm64; "i"))
            ] | length')"
            if [[ "$windows_ambiguous_count" -ne 0 ]]; then
              echo "missing: found ${windows_ambiguous_count} Windows installer asset(s) matching BOTH x64 and arm64 patterns (ambiguous naming)" >&2
              missing=1
            fi

            require_sigs_for_ext() {
              local label="$1"
              local ext_re="$2"
              local missing_sig_bases
              missing_sig_bases="$(echo "$json" | jq -r --arg ext "$ext_re" '
                ([.[].name] | unique) as $names |
                [ $names[]
                  | select(test($ext; "i"))
                  | select(($names | index(. + ".sig")) == null)
                ] | .[]')"
              if [[ -n "${missing_sig_bases}" ]]; then
                echo "missing: ${label} signature files (<asset>.sig) for:" >&2
                echo "${missing_sig_bases}" | sed 's/^/  - /' >&2
                missing=1
              fi
            }

            require_sigs_for_arch() {
              local label="$1"
              local arch_re="$2"
              local other_arch_re="$3"
              local missing_sig_bases
              missing_sig_bases="$(echo "$json" | jq -r --arg arch "$arch_re" --arg other "$other_arch_re" '
                ([.[].name] | unique) as $names |
                [ $names[]
                  | select(test("\\.(msi|exe)$"; "i"))
                  | select(test($arch; "i"))
                  | select(test($other; "i") | not)
                  | select(($names | index(. + ".sig")) == null)
                ] | .[]')"
              if [[ -n "${missing_sig_bases}" ]]; then
                echo "missing: ${label} signature files (<asset>.sig) for:" >&2
                echo "${missing_sig_bases}" | sed 's/^/  - /' >&2
                missing=1
              fi
            }

            # For Tauri auto-update, each Windows installer asset must have a corresponding
            # signature file uploaded alongside it (<asset>.sig). Missing signatures can be a
            # sign of partial uploads or asset clobbering in multi-arch runs.
            require_sigs_for_arch "Windows x64 installer" "$win_x64_re" "$win_arm64_re"
            require_sigs_for_arch "Windows arm64 installer" "$win_arm64_re" "$win_x64_re"

            # Require signatures for each macOS/Linux installer/bundle artifact, not just at least
            # one signature file. This catches partial uploads where the bundle exists but its `.sig`
            # was not attached to the GitHub Release.
            require_sigs_for_ext "macOS DMG" '\\.dmg$'
            require_sigs_for_ext "macOS app archive" '\\.app\\.tar\\.gz$'
            require_sigs_for_ext "Linux AppImage" '\\.AppImage$'
            require_sigs_for_ext "Linux DEB" '\\.deb$'
            require_sigs_for_ext "Linux RPM" '\\.rpm$'

            [[ "$missing" -eq 0 ]]
          }

          release_json="$(fetch_release)"
          release_id="$(echo "$release_json" | jq -r '.id')"
          if [[ -z "${release_id}" || "${release_id}" == "null" ]]; then
            echo "::error::Failed to resolve GitHub Release id for tag ${tag}." >&2
            echo "$release_json" | jq -r '.' >&2 || true
            exit 1
          fi
          assets_json="$(fetch_assets "$release_id")"

          if ! assets_ready "$assets_json"; then
            for delay in "${retry_delays[@]}"; do
              echo "Release assets not fully visible yet; retrying in ${delay}s..." >&2
              sleep "$delay"
              release_json="$(fetch_release)"
              release_id="$(echo "$release_json" | jq -r '.id')"
              if [[ -z "${release_id}" || "${release_id}" == "null" ]]; then
                echo "::error::Failed to resolve GitHub Release id for tag ${tag} during retry." >&2
                echo "$release_json" | jq -r '.' >&2 || true
                exit 1
              fi
              assets_json="$(fetch_assets "$release_id")"
              if assets_ready "$assets_json"; then
                break
              fi
            done
          fi

          if ! assets_ready "$assets_json"; then
            echo "::error::Release asset verification failed after retries." >&2
            echo "$assets_json" | jq -r '.[].name' | sort | sed 's/^/::error:: - /' || true
            exit 1
          fi

          release_url="$(echo "$release_json" | jq -r '.html_url')"
          draft="$(echo "$release_json" | jq -r '.draft')"
          asset_count="$(echo "$assets_json" | jq -r 'length')"

          echo "Release: ${tag} (draft=${draft})"
          echo "URL: ${release_url}"
          echo "Assets: ${asset_count}"
          echo

          mapfile -t asset_names < <(echo "$assets_json" | jq -r '.[].name' | sort)
          printf '%s\n' "${asset_names[@]}"

          dup_names="$(printf '%s\n' "${asset_names[@]}" | sort | uniq -d || true)"
          if [[ -n "${dup_names}" ]]; then
            echo "::error::Duplicate asset names found on the release (unexpected):"
            echo "${dup_names}"
            exit 1
          fi

          bucket_for() {
            local name="$1"
            local base="$name"
            [[ "$base" == *.sig ]] && base="${base%.sig}"

            shopt -s nocasematch
            if [[ "$base" == "latest.json" ]]; then
              echo "updater-manifest"
            elif [[ "$base" == *.msi || "$base" == *.exe ]]; then
              if [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "windows-arm64"
              elif [[ "$base" =~ (x64|x86[_-]64|amd64|win64) ]]; then
                echo "windows-x64"
              else
                echo "windows-unknown"
              fi
            elif [[ "$base" == *.dmg || "$base" == *.app.tar.gz ]]; then
              if [[ "$base" =~ universal ]]; then
                echo "macos-universal"
              elif [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "macos-arm64"
              elif [[ "$base" =~ (x64|x86_64) ]]; then
                echo "macos-x64"
              else
                echo "macos-unknown"
              fi
            elif [[ "$base" == *.deb || "$base" == *.rpm || "$base" == *.AppImage || "$base" == *.AppImage.tar.gz ]]; then
              if [[ "$base" =~ (amd64|x86_64|x64) ]]; then
                echo "linux-x64"
              elif [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "linux-arm64"
              else
                echo "linux-unknown"
              fi
            else
              echo "other"
            fi
            shopt -u nocasematch
          }

          declare -A bucket_assets
          for name in "${asset_names[@]}"; do
            bucket="$(bucket_for "$name")"
            bucket_assets["$bucket"]+="${name}"$'\n'
          done

          render_table() {
            echo "| Bucket | Asset |"
            echo "| --- | --- |"
            for bucket in macos-universal windows-x64 windows-arm64 linux-x64 updater-manifest other macos-unknown windows-unknown linux-unknown macos-x64 macos-arm64 linux-arm64; do
              [[ -z "${bucket_assets[$bucket]+x}" ]] && continue
              while IFS= read -r name; do
                [[ -z "$name" ]] && continue
                echo "| ${bucket} | \`${name}\` |"
              done <<< "${bucket_assets[$bucket]}"
            done
          }

          {
            echo "## Release assets (${tag})"
            echo
            render_table
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          echo
          echo "Grouped release assets:"
          render_table

          echo
          echo "Release asset verification passed."

  checksums:
    name: Generate SHA256SUMS.txt
    needs:
      - validate-version
      - validate-updater-manifest
      - verify-release-assets
    if: needs.validate-version.outputs.upload == 'true'
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Download release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p release-assets
          gh release download "${{ needs.validate-version.outputs.release_tag }}" \
            --repo "${{ github.repository }}" \
            --dir release-assets

      - name: Generate SHA256SUMS.txt
        run: bash scripts/ci/generate-release-checksums.sh release-assets SHA256SUMS.txt

      - name: Upload SHA256SUMS.txt to the draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh release upload "${{ needs.validate-version.outputs.release_tag }}" SHA256SUMS.txt \
            --repo "${{ github.repository }}" \
            --clobber
