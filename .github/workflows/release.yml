name: Desktop Release

# NOTE: Third-party GitHub Actions are pinned to an immutable commit SHA for
# supply-chain hardening. To update, pick the desired upstream tag (same major
# version), resolve it to a commit with `git ls-remote <repo> <tag> <tag>^{}`,
# then replace the SHA below and update the trailing comment.

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Git tag to use for the release (optional). Example: v0.2.3"
        required: false
        type: string
      version:
        description: "Version label for artifacts (optional). Example: 0.2.3"
        required: false
        type: string
      upload:
        description: "If true, create/update a draft GitHub Release and attach assets. If false, upload bundles as workflow artifacts."
        required: false
        type: boolean
        default: false
      windows_timestamp_url:
        description: "Override Windows Authenticode timestamp server URL for this run (optional; must be https://). Example: https://timestamp.digicert.com"
        required: false
        type: string

# Prevent multiple runs for the same tag/ref from racing while uploading GitHub Release
# assets (including Tauri updater manifests like `latest.json`). Without this,
# manual re-runs or tag updates can overlap and clobber/partially overwrite the
# release asset set.
concurrency:
  # For `workflow_dispatch`, `github.ref` is the branch the workflow is run from, but the release
  # tag may come from inputs. Key concurrency off the *effective* release tag when we're actually
  # uploading to a GitHub Release (`upload=true`) so dispatch release runs for a given tag can't
  # overlap with the corresponding tag push run.
  #
  # NOTE: `github.event.inputs.*` may be empty/undefined for optional inputs, so guard `startsWith`
  # with truthy checks to avoid evaluation errors.
  #
  # In dry-run mode (`upload=false`), fall back to the branch ref so dry runs don't block releases.
  group: desktop-release-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.upload == 'true' && ((github.event.inputs.tag && (startsWith(github.event.inputs.tag, 'refs/tags/') && github.event.inputs.tag || (startsWith(github.event.inputs.tag, 'v') && format('refs/tags/{0}', github.event.inputs.tag) || format('refs/tags/v{0}', github.event.inputs.tag)))) || (github.event.inputs.version && (startsWith(github.event.inputs.version, 'refs/tags/') && github.event.inputs.version || (startsWith(github.event.inputs.version, 'v') && format('refs/tags/{0}', github.event.inputs.version) || format('refs/tags/v{0}', github.event.inputs.version)))) || github.ref) || github.ref }}
  cancel-in-progress: false

env:
  # Keep release builds on the same Node.js major as CI (see ci.yml) to avoid
  # "works in CI, breaks in release" drift.
  NODE_VERSION: 22
  # Keep in sync with apps/desktop/scripts/ensure-pyodide-assets.mjs
  PYODIDE_VERSION: "0.25.1"
  # Pin wasm-pack for reproducible tagged releases (avoid `cargo install wasm-pack`
  # pulling newer incompatible versions). Keep this in sync with ci.yml/perf.yml.
  WASM_PACK_VERSION: 0.13.1
  # Pin the Tauri CLI (`cargo tauri`) version used by release builds so the toolchain
  # can't drift independently from the repo's pinned Tauri crates.
  #
  # Keep this in sync with:
  # - apps/desktop/src-tauri/Cargo.toml (tauri = "2.9")
  # - docs/release.md (local release prep instructions)
  TAURI_CLI_VERSION: "2.9.5"

jobs:
  conflict-marker-guard:
    name: "Guard: no merge conflict markers"
    permissions:
      contents: read
    # Pinned runner images keep release workflows deterministic and avoid breakages
    # when GitHub updates the default `*-latest` hosted runner images. Update
    # these pins deliberately after validating the newer runner images.
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh
      - name: "Guard: release workflow runner images are pinned (no *-latest)"
        run: bash scripts/ci/check-gha-runner-pins.sh
      - name: "Guard: Rust toolchain pins match rust-toolchain.toml"
        run: bash scripts/ci/check-rust-toolchain-pins.sh
      - name: "Guard: Node version pins match CI workflow"
        run: bash scripts/ci/check-node-version-pins.sh
      - name: "Guard: pnpm version pins match package.json + CI workflow"
        run: bash scripts/ci/check-pnpm-version-pins.sh
      - name: "Guard: wasm-pack version pins match CI workflow"
        run: bash scripts/ci/check-wasm-pack-version-pins.sh
      - name: "Guard: Tauri CLI version pins match CI workflow"
        run: bash scripts/ci/check-tauri-cli-version-pins.sh

  preflight:
    name: Preflight validations
    needs: conflict-marker-guard
    permissions:
      contents: read
      actions: read
    runs-on: ubuntu-24.04
    outputs:
      upload: ${{ steps.params.outputs.upload }}
      release_tag: ${{ steps.params.outputs.release_tag }}
      artifact_label: ${{ steps.params.outputs.artifact_label }}
      should_validate_version: ${{ steps.params.outputs.should_validate_version }}
      windows_timestamp_url: ${{ steps.params.outputs.windows_timestamp_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Compute release parameters
        id: params
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          INPUT_VERSION: ${{ github.event.inputs.version }}
          INPUT_UPLOAD: ${{ github.event.inputs.upload }}
          INPUT_WINDOWS_TIMESTAMP_URL: ${{ github.event.inputs.windows_timestamp_url }}
        run: |
          set -euo pipefail

          # Defaults:
          upload="false"
          release_tag=""
          windows_timestamp_url=""

          # Derive the release tag / artifact label.
          if [[ "${EVENT_NAME}" == "push" ]]; then
            upload="true"
            release_tag="${REF_NAME}"
            artifact_label="${REF_NAME}"
          else
            # workflow_dispatch
            if [[ "${INPUT_UPLOAD:-}" == "true" ]]; then
              upload="true"
            fi

            tag="${INPUT_TAG:-}"
            version="${INPUT_VERSION:-}"
            windows_timestamp_url="${INPUT_WINDOWS_TIMESTAMP_URL:-}"

            # Some users may paste full ref names. Normalize to a bare tag/version string.
            tag="${tag#refs/tags/}"
            version="${version#refs/tags/}"
            windows_timestamp_url="${windows_timestamp_url#refs/tags/}"
            # Strip common whitespace/newlines from the URL input (copy/paste hygiene).
            windows_timestamp_url="$(echo "${windows_timestamp_url}" | tr -d '\r\n' | xargs || true)"

            if [[ -n "${tag}" ]]; then
              if [[ "${tag}" == v* ]]; then
                release_tag="${tag}"
              else
                release_tag="v${tag}"
              fi
              artifact_label="${release_tag}"
            elif [[ -n "${version}" ]]; then
              # `version` is primarily for labeling dry-run artifacts. When `upload=true`, we
              # still need a GitHub Release tag, so we normalize it to a `v*` tag.
              artifact_label="${version}"
              if [[ "${version}" == v* ]]; then
                release_tag="${version}"
              else
                release_tag="v${version}"
              fi
            else
              short_sha="$(echo "${GITHUB_SHA}" | cut -c1-7)"
              artifact_label="manual-${short_sha}"
            fi

            if [[ "${upload}" == "true" && -z "${release_tag}" ]]; then
              echo "error: upload=true requires either the 'tag' or 'version' workflow input." >&2
              exit 1
            fi
          fi

          should_validate_version="false"
          if [[ "${EVENT_NAME}" == "push" || "${upload}" == "true" ]]; then
            should_validate_version="true"
          fi

          # Artifact names should be safe as directory/file-ish identifiers. GitHub allows many
          # characters, but keep it simple for consumers and avoid surprises.
          artifact_label_sanitized="$(echo "${artifact_label}" | sed -E 's/[^A-Za-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
          if [[ -z "${artifact_label_sanitized}" ]]; then
            artifact_label_sanitized="manual-$(echo "${GITHUB_SHA}" | cut -c1-7)"
          fi

          echo "upload=${upload}" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${release_tag}" >> "${GITHUB_OUTPUT}"
          echo "artifact_label=${artifact_label_sanitized}" >> "${GITHUB_OUTPUT}"
          echo "should_validate_version=${should_validate_version}" >> "${GITHUB_OUTPUT}"
          echo "windows_timestamp_url=${windows_timestamp_url}" >> "${GITHUB_OUTPUT}"

      - name: "Guard: tag must be on main"
        if: steps.params.outputs.upload == 'true'
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main --depth=1

          if git merge-base --is-ancestor "$GITHUB_SHA" origin/main; then
            exit 0
          fi

          # In a shallow checkout, `origin/main` may not include enough history to
          # prove the tagged commit is reachable. Fetch full main history and retry.
          git fetch --unshallow origin main 2>/dev/null || git fetch origin main --depth=1000000

          if ! git merge-base --is-ancestor "$GITHUB_SHA" origin/main; then
            echo "::error::Releases must be tagged from the main branch. Commit $GITHUB_SHA is not reachable from origin/main."
            exit 1
          fi

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Verify tagged commit has successful CI run
        if: steps.params.outputs.upload == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/check-tag-ci-status.mjs --sha "${{ github.sha }}" --workflow "CI"

      - name: Check pinned Tauri CLI version matches Tauri crates
        run: node scripts/ci/check-tauri-cli-version.mjs

      - name: Check desktop version matches release tag
        if: steps.params.outputs.should_validate_version == 'true'
        run: node scripts/check-desktop-version.mjs "${{ steps.params.outputs.release_tag }}"

      - name: Validate Tauri updater config
        run: node scripts/check-updater-config.mjs

      - name: Validate Tauri updater signing secrets
        # Forks/dry-runs often do not configure release secrets. We always validate updater
        # signing secrets in the upstream repo (so official releases can't ship without
        # auto-update signatures), and validate in forks only when the user has configured their
        # own updater keys.
        #
        # Only enforce when we're publishing to a GitHub Release (tag push or workflow_dispatch upload=true).
        if: steps.params.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
        run: node scripts/check-updater-signing-secrets.mjs
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

      - name: Validate Windows WebView2 installer configuration
        run: node scripts/ci/check-webview2-install-mode.mjs

      - name: Validate Windows Authenticode timestamp URL (HTTPS)
        run: node scripts/ci/check-windows-timestamp-url.mjs
        env:
          FORMULA_WINDOWS_TIMESTAMP_URL: ${{ steps.params.outputs.windows_timestamp_url }}

      - name: Validate Windows downgrade / rollback support (allowDowngrades)
        run: node scripts/ci/check-windows-allow-downgrades.mjs

      # Fail fast (before any platform builds start) if maintainers require code signing or if
      # signing secrets are partially configured. This avoids wasting build time and uploading
      # a partial set of GitHub Release assets.
      - name: "Preflight: warn when APPLE_SIGNING_IDENTITY is missing (recommended)"
        if: secrets.APPLE_CERTIFICATE != '' && secrets.APPLE_SIGNING_IDENTITY == ''
        shell: bash
        run: |
          set -euo pipefail
          echo "::warning::APPLE_CERTIFICATE is configured but APPLE_SIGNING_IDENTITY is missing. CI will fall back to the generic \"Developer ID Application\" selector, which can be ambiguous if multiple certificates exist. Set APPLE_SIGNING_IDENTITY (e.g. \"Developer ID Application: Your Company (TEAMID)\") for deterministic signing."

      - name: "Preflight: verify macOS code signing secrets (base64 + PKCS#12)"
        if: secrets.APPLE_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh macos

      - name: "Preflight: verify Windows code signing secrets (base64 + PKCS#12)"
        if: secrets.WINDOWS_CERTIFICATE != '' || vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: bash scripts/ci/verify-codesign-secrets.sh windows

      - name: "Preflight: require macOS notarization creds when FORMULA_REQUIRE_CODESIGN=1"
        if: vars.FORMULA_REQUIRE_CODESIGN == '1'
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          missing=()
          for name in APPLE_SIGNING_IDENTITY APPLE_ID APPLE_PASSWORD APPLE_TEAM_ID; do
            if [[ -z "${!name:-}" ]]; then
              missing+=("$name")
            fi
          done

          if ((${#missing[@]} > 0)); then
            echo "" >&2
            echo "Code signing is required (FORMULA_REQUIRE_CODESIGN=1) but macOS notarization/signing secrets are missing:" >&2
            for m in "${missing[@]}"; do
              echo "  - ${m}" >&2
            done
            echo "" >&2
            echo "Set these in GitHub: Settings → Secrets and variables → Actions → New repository secret." >&2
            echo "See docs/release.md (\"Code signing\")." >&2
            exit 1
          fi

  build:
    name: Build (${{ matrix.label }})
    needs: preflight
    permissions:
      contents: write
    strategy:
      fail-fast: false
      # NOTE: `tauri-apps/tauri-action` updates shared GitHub Release assets (notably `latest.json`)
      # for the updater. Matrix jobs remain parallel for fast releases; we publish a single combined
      # updater manifest in a dedicated job after all platform builds complete.
      matrix:
        # Pinned runner images keep release workflows deterministic and avoid breakages
        # when GitHub updates the default `*-latest` hosted runner images. Update
        # these pins deliberately after validating the newer runner images.
        include:
          - platform: macos-14
            label: macos-14
            # The macOS job builds a universal bundle (x86_64 + arm64).
            cache_target: universal-apple-darwin
            cache_features: desktop
            rust_target: ""
            tauri_args: ""
          - platform: ubuntu-24.04
            label: ubuntu-24.04
            cache_target: x86_64-unknown-linux-gnu
            cache_features: desktop
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: ubuntu-24.04-arm64
            label: ubuntu-24.04 (arm64)
            cache_target: aarch64-unknown-linux-gnu
            cache_features: desktop
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: windows-2022
            label: windows-2022 (x64)
            cache_target: x86_64-pc-windows-msvc
            cache_features: desktop
            rust_target: x86_64-pc-windows-msvc
            tauri_args: "--target x86_64-pc-windows-msvc --bundles msi,nsis"
          - platform: windows-2022
            label: windows-2022 (arm64)
            cache_target: aarch64-pc-windows-msvc
            cache_features: desktop
            rust_target: aarch64-pc-windows-msvc
            tauri_args: "--target aarch64-pc-windows-msvc --bundles msi,nsis"

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0

      # Ensure all Cargo builds (including `cargo tauri build`) emit artifacts under the
      # expected path `apps/desktop/src-tauri/target/**`. This keeps release assertions
      # deterministic and matches docs/CI checks that look under src-tauri/target.
      - name: Set CARGO_TARGET_DIR for desktop builds (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $targetDir = Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target'
          "CARGO_TARGET_DIR=$targetDir" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Set CARGO_TARGET_DIR for desktop builds (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: echo "CARGO_TARGET_DIR=$GITHUB_WORKSPACE/apps/desktop/src-tauri/target" >> "$GITHUB_ENV"
      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          # Pin the pnpm patch version for deterministic tagged-release builds.
          # Keep this in sync with the root package.json `packageManager` field.
          version: 9.0.0

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Validate macOS entitlements (hardened runtime)
        if: runner.os == 'macOS'
        run: node scripts/check-macos-entitlements.mjs

      # Code signing is optional and frequently unavailable in forks/dry-runs (no repo secrets).
      # When signing secrets are missing, we patch `tauri.conf.json` for this CI run so bundling
      # still succeeds (unsigned artifacts), and we only export notarization env vars when all
      # required credentials are configured.
      #
      # When maintainers set FORMULA_REQUIRE_CODESIGN=1, this step switches to enforcement mode and
      # fails early if platform signing secrets are missing.
      - name: Prepare optional Tauri signing config (macOS/Windows)
        run: node scripts/ci/prepare-tauri-signing-config.mjs
        env:
          # Optional: set as a GitHub Actions "Variable" to enforce platform code signing.
          # - FORMULA_REQUIRE_CODESIGN=1 to fail when required signing secrets are missing
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}
          # Optional override: allow re-runs to switch timestamp servers without changing the repo.
          FORMULA_WINDOWS_TIMESTAMP_URL: ${{ needs.preflight.outputs.windows_timestamp_url }}

          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

          # Optional: Tauri updater signing secrets. Forks/dry-runs often do not configure these,
          # so the helper only exports them to subsequent steps when non-empty.
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@9bc92bc5598b4f3bec5d910d352094982cb0c3b9 # 1.92.0

      - name: Install Rust targets (WASM)
        run: rustup target add wasm32-unknown-unknown

      - name: Install macOS Rust targets (universal build)
        if: runner.os == 'macOS'
        run: rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Install Rust target (${{ matrix.rust_target }})
        if: matrix.rust_target != ''
        run: rustup target add ${{ matrix.rust_target }}

      - name: Ensure MSVC ARM64 build tools are installed (Windows ARM64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (!(Test-Path $vswhere)) {
            throw "vswhere not found at $vswhere (expected on GitHub-hosted Windows runners)."
          }
          $installPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (!$installPath) {
            throw "Failed to locate a Visual Studio installation via vswhere."
          }
          Write-Host "Visual Studio install path: $installPath"
          $msvcRoot = Join-Path $installPath "VC\Tools\MSVC"
          $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (!$msvcVersionDir) {
            throw "MSVC toolset directory not found under $msvcRoot"
          }
          $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
          $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
          $arm64Cl = Join-Path $arm64BinDir "cl.exe"
          $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          $hasArm64Toolchain = (Test-Path $arm64LibDir) -and (Test-Path $arm64Cl) -and (Test-Path $arm64LinkExe)

          if (-not $hasArm64Toolchain) {
            Write-Host "MSVC ARM64 toolchain not found; installing Visual Studio component Microsoft.VisualStudio.Component.VC.Tools.ARM64"
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            & $vsInstaller modify --installPath $installPath --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --includeRecommended --passive --norestart
            $exitCode = $LASTEXITCODE
            # 3010 is a common "success, reboot required" code for Windows installers.
            if ($exitCode -ne 0 -and $exitCode -ne 3010) {
              throw "vs_installer.exe failed with exit code $exitCode while installing MSVC ARM64 components."
            }

            $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
            $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
            $arm64Cl = Join-Path $arm64BinDir "cl.exe"
            $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          }

          if (!(Test-Path $arm64LibDir) -or !(Test-Path $arm64Cl) -or !(Test-Path $arm64LinkExe)) {
            throw "MSVC ARM64 build tools were not found. Expected:\n  - $arm64LibDir\n  - $arm64Cl\n  - $arm64LinkExe\nWindows ARM64 builds require the MSVC ARM64 toolchain to be present on the runner."
          }

          Write-Host "MSVC ARM64 tools present:"
          Write-Host "  - libs: $arm64LibDir"
          Write-Host "  - cl.exe: $arm64Cl"
          Write-Host "  - link.exe: $arm64LinkExe"

          $sdkLibRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\Lib"
          if (!(Test-Path $sdkLibRoot)) {
            throw "Windows SDK lib root not found at $sdkLibRoot. Windows ARM64 builds require the Windows 10/11 SDK with ARM64 libraries."
          }

          function Find-SdkArm64($root) {
            $dirs = @(Get-ChildItem -Path $root -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending)
            foreach ($dir in $dirs) {
              $um = Join-Path $dir.FullName "um\arm64"
              $ucrt = Join-Path $dir.FullName "ucrt\arm64"
              if ((Test-Path $um) -and (Test-Path $ucrt)) {
                return [pscustomobject]@{ VersionDir = $dir; Um = $um; Ucrt = $ucrt; AllDirs = $dirs }
              }
            }
            return [pscustomobject]@{ VersionDir = $null; Um = $null; Ucrt = $null; AllDirs = $dirs }
          }

          $sdkInfo = Find-SdkArm64 $sdkLibRoot
          if (-not $sdkInfo.AllDirs -or $sdkInfo.AllDirs.Count -eq 0) {
            throw "No Windows SDK lib versions found under $sdkLibRoot. Windows ARM64 builds require a Windows SDK installation with ARM64 libraries."
          }

          if (-not $sdkInfo.VersionDir) {
            # Some runner images can have the Windows SDK installed without the ARM64 lib subset.
            # Attempt to add the matching Windows 10 SDK component via the Visual Studio installer.
            $candidateName = $sdkInfo.AllDirs[0].Name
            $sdkBuild = $null
            if ($candidateName -match '^10\.0\.(\d+)\.\d+$') {
              $sdkBuild = $Matches[1]
            }
            if (-not $sdkBuild) {
              # Reasonable fallback for windows-2022 images (10.0.20348.0).
              $sdkBuild = "20348"
            }

            $sdkComponents = @(
              "Microsoft.VisualStudio.Component.Windows10SDK.$sdkBuild",
              "Microsoft.VisualStudio.Component.Windows11SDK.$sdkBuild"
            ) | Select-Object -Unique
            Write-Host "Windows SDK ARM64 libs not found; attempting to install one of:"
            $sdkComponents | ForEach-Object { Write-Host "  - $_" }
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            $installErrors = @()
            foreach ($sdkComponent in $sdkComponents) {
              Write-Host "Installing Windows SDK component: $sdkComponent"
              & $vsInstaller modify --installPath $installPath --add $sdkComponent --includeRecommended --passive --norestart
              $exitCode = $LASTEXITCODE
              # 3010 is a common "success, reboot required" code for Windows installers.
              if ($exitCode -ne 0 -and $exitCode -ne 3010) {
                $installErrors += "$sdkComponent (exit code $exitCode)"
                continue
              }
              $sdkInfo = Find-SdkArm64 $sdkLibRoot
              if ($sdkInfo.VersionDir) {
                break
              }
            }

            if (-not $sdkInfo.VersionDir -and $installErrors.Count -gt 0) {
              Write-Host "Windows SDK component install attempts failed:"
              $installErrors | ForEach-Object { Write-Host "  - $_" }
            }
          }

          if (-not $sdkInfo.VersionDir) {
            throw "Windows SDK ARM64 UM/UCRT libraries were not found under $sdkLibRoot. The runner image may be missing the Windows SDK ARM64 components."
          }

          $sdkVersionDir = $sdkInfo.VersionDir
          $sdkUmArm64 = $sdkInfo.Um
          $sdkUcrtArm64 = $sdkInfo.Ucrt

          Write-Host "windows-arm64-toolchain: OK"
          Write-Host " - MSVC: $($msvcVersionDir.FullName)"
          Write-Host " - link.exe: $arm64LinkExe"
          Write-Host " - MSVC lib: $arm64LibDir"
          Write-Host " - SDK um/arm64: $sdkUmArm64"
          Write-Host " - SDK ucrt/arm64: $sdkUcrtArm64"

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Use shared Cargo home for CI caching (Unix)
        if: runner.os != 'Windows'
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Install WiX Toolset (required for MSI builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's MSI bundler requires WiX (candle.exe/light.exe) to be on PATH.
          # GitHub runners don't consistently have it available, and Tauri may skip
          # MSI generation without failing. Install WiX deterministically.
          $candle = Get-Command candle.exe -ErrorAction SilentlyContinue
          $light = Get-Command light.exe -ErrorAction SilentlyContinue
          if (-not $candle -or -not $light) {
            choco install wixtoolset --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            # (Chocolatey may update PATH via the registry; refreshenv reloads it.)
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          # Add common WiX install locations to PATH for subsequent steps.
          $wixRoots = Get-ChildItem -Path (Join-Path ${env:ProgramFiles(x86)} "WiX Toolset v*") -Directory -ErrorAction SilentlyContinue
          foreach ($root in $wixRoots) {
            $bin = Join-Path $root.FullName "bin"
            if (Test-Path $bin) {
              $env:PATH = "$bin;$env:PATH"
              $bin | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
            }
          }

          if (-not (Get-Command candle.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: candle.exe not found on PATH."
          }
          if (-not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: light.exe not found on PATH."
          }

      - name: Install NSIS (required for EXE builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's NSIS bundler requires makensis.exe. If it's missing, Tauri may
          # skip EXE generation without failing the overall build. Install NSIS
          # deterministically so Windows releases always include both `.exe` and `.msi`.
          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            choco install nsis --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            throw "NSIS installation failed: makensis.exe not found on PATH."
          }

      - name: Cache Rust (cargo registry + git)
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2
        with:
          # We cache build artifacts separately (see "Cache cargo target") to keep cache sizes
          # bounded for tagged releases. rust-cache still provides fast restores for the Cargo
          # registry/git index and respects our CARGO_HOME override above.
          cache-targets: "false"

      - name: Cache cargo target (release build artifacts)
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            target/**/release/deps
            target/**/release/build
            target/**/release/.fingerprint
            target/**/release/incremental
            target/**/release/wbuild
            target/.rustc_info.json
            target/**/.rustc_info.json
            apps/desktop/src-tauri/target/**/release/deps
            apps/desktop/src-tauri/target/**/release/build
            apps/desktop/src-tauri/target/**/release/.fingerprint
            apps/desktop/src-tauri/target/**/release/incremental
            apps/desktop/src-tauri/target/**/release/wbuild
            apps/desktop/src-tauri/target/.rustc_info.json
            apps/desktop/src-tauri/target/**/.rustc_info.json
          # Keep these caches isolated per Rust target triple + runner arch so cross-compile jobs
          # (e.g. Windows aarch64) don't thrash/overwrite caches or restore host build-script
          # binaries from an incompatible runner architecture.
          # Include the Rust toolchain pin so caches don't leak across rustc upgrades.
          # (Similar to Swatinem/rust-cache's default behavior.)
          key: cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-
            # Backwards-compat: allow restoring caches created before we started keying
            # on the Tauri feature set (so the first run after a workflow update isn't cold).
            cargo-target-desktop-release-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            file \
            binutils \
            cpio \
            xvfb \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            squashfs-tools \
            fakeroot \
            rpm \
            rpm2cpio

          # `appimagetool` is distributed as an AppImage and requires the FUSE 2 runtime.
          # Ubuntu 24.04 uses `libfuse2t64` as part of the time_t 64-bit transition.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64

          # AppImage-based tooling (including `appimagetool`) supports "extract and run" mode.
          # Prefer it in CI to reduce reliance on a working FUSE setup.
          echo "APPIMAGE_EXTRACT_AND_RUN=1" >> "${GITHUB_ENV}"
      - name: Install JS dependencies
        # Prefer cached pnpm store entries to reduce network flakiness on reruns.
        env:
          # Release builds don't run Playwright tests, so skip the ~GB browser downloads
          # performed by `@playwright/test`'s postinstall script. (CI test workflows that
          # run Playwright should not set this.)
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
        run: pnpm install --frozen-lockfile --prefer-offline

      - name: Detect Pyodide version (for caching)
        id: pyodide
        shell: bash
        run: |
          set -euo pipefail
          version="$(node -p 'const fs=require("fs");const src=fs.readFileSync("apps/desktop/scripts/ensure-pyodide-assets.mjs","utf8");const m=src.match(/const\s+PYODIDE_VERSION\s*=\s*[\"\\x27]([^\"\\x27]+)[\"\\x27]/);if(!m){throw new Error("PYODIDE_VERSION not found in ensure-pyodide-assets.mjs");}m[1];')"
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Restore Pyodide asset cache
        id: pyodide-cache
        uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Ensure Pyodide assets are present (populate cache on miss)
        shell: bash
        run: node apps/desktop/scripts/ensure-pyodide-assets.mjs

      - name: Save Pyodide asset cache
        if: steps.pyodide-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cargo/bin/wasm-pack*
          # Include the Rust toolchain pin so Rust upgrades force rebuilding the cached binary.
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Cache wasm-pack tool downloads (Linux)
        if: runner.os == 'Linux'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          # wasm-pack downloads wasm-bindgen + binaryen (wasm-opt) into this cache dir.
          path: ~/.cache/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache wasm-pack tool downloads (macOS)
        if: runner.os == 'macOS'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/Library/Caches/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache wasm-pack tool downloads (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ${{ env.LOCALAPPDATA }}/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        # Pinned for release reproducibility. Known-good with this repo's WASM build
        # (`crates/formula-wasm` via `packages/engine/scripts/build-wasm.mjs`).
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        run: cargo install wasm-pack --version ${{ env.WASM_PACK_VERSION }} --locked

      - name: Verify wasm-pack version
        shell: bash
        run: |
          set -euo pipefail
          expected="${WASM_PACK_VERSION}"
          actual="$(wasm-pack --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected wasm-pack ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        # COOP/COEP + Worker support can regress per-platform; run on all release targets by default.
        #
        # Optional: set `FORMULA_COI_CHECK_ALL_PLATFORMS=0` (or `false`) as a GitHub Actions variable to
        # only run this step on Linux (useful if a hosted-runner regression makes the check flaky on
        # macOS/Windows while keeping at least one COI signal before publishing).
        if: needs.preflight.outputs.upload == 'true' && (runner.os == 'Linux' || (vars.FORMULA_COI_CHECK_ALL_PLATFORMS != '0' && vars.FORMULA_COI_CHECK_ALL_PLATFORMS != 'false'))
        run: pnpm -C apps/desktop check:coi
      - name: Cache pinned Tauri CLI binary (cargo-tauri)
        id: tauri-cli-cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cargo/bin/cargo-tauri*
          # Include the Rust toolchain pin so Rust upgrades force rebuilding the cached binary.
          key: cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install pinned Tauri CLI (cargo tauri)
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ${{ env.TAURI_CLI_VERSION }} --locked

      - name: Verify Tauri CLI version
        shell: bash
        run: |
          set -euo pipefail
          expected="${TAURI_CLI_VERSION}"
          actual="$(cargo tauri --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected cargo-tauri ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache Tauri tooling downloads (Linux)
        if: runner.os == 'Linux'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cache/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (macOS)
        if: runner.os == 'macOS'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/Library/Caches/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          # Tauri's cache directory lives under %LOCALAPPDATA% on Windows.
          path: ${{ env.LOCALAPPDATA }}/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Validate Tauri capability permission identifiers
        # Fail the release early if `apps/desktop/src-tauri/capabilities/*.json` references
        # permissions that do not exist in the pinned toolchain (`cargo tauri permission ls`).
        if: runner.os == 'Linux'
        run: node scripts/check-tauri-permissions.mjs

      - name: Build and upload release assets (macOS universal)
        if: runner.os == 'macOS' && needs.preflight.outputs.upload == 'true'
        # Pinned for reproducible releases: avoid upstream floating major tags moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: --target universal-apple-darwin
          tagName: ${{ needs.preflight.outputs.release_tag }}
          releaseName: Formula ${{ needs.preflight.outputs.release_tag }}
          releaseBody: |
            Automated build for ${{ needs.preflight.outputs.release_tag }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          # Mark GitHub Releases as prereleases when the semver tag contains a
          # prerelease suffix like `-beta.1` or `-rc.0` (e.g. `v1.2.3-beta.1`).
          prerelease: ${{ contains(needs.preflight.outputs.release_tag, '-') }}

      - name: Build desktop bundles (macOS universal, dry run)
        if: runner.os == 'macOS' && needs.preflight.outputs.upload != 'true'
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: --target universal-apple-darwin

      # Debug symbols are not end-user installer assets, but they are needed for post-release crash
      # symbolication. Package them separately so they can be downloaded from the workflow run
      # without bloating installer bundles.
      - name: Package macOS debug symbols (dSYM)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p debug-symbols

          roots=()
          if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
            cargo_target_dir="${CARGO_TARGET_DIR}"
            if [[ "${cargo_target_dir}" != /* ]]; then
              cargo_target_dir="${PWD}/${cargo_target_dir}"
            fi
            if [[ -d "${cargo_target_dir}" ]]; then
              roots+=("${cargo_target_dir}")
            fi
          fi
          for root in "apps/desktop/src-tauri/target" "apps/desktop/target" "target"; do
            if [[ -d "${root}" ]]; then
              roots+=("${root}")
            fi
          done
          if ((${#roots[@]} == 0)); then
            echo "debug-symbols: ERROR no Cargo target directories found (CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-<unset>})" >&2
            exit 1
          fi

          shopt -s nullglob
          dsym_dirs=()
          for root in "${roots[@]}"; do
            dsym_dirs+=("${root}"/release/bundle/macos/*.dSYM)
            dsym_dirs+=("${root}"/*/release/bundle/macos/*.dSYM)
          done
          shopt -u nullglob

          if ((${#dsym_dirs[@]} == 0)); then
            echo "debug-symbols: ERROR no .dSYM bundles found under **/release/bundle/macos/**" >&2
            exit 1
          fi
          mapfile -t dsym_dirs < <(printf '%s\n' "${dsym_dirs[@]}" | sort -u)

          for dsym in "${dsym_dirs[@]}"; do
            base="$(basename "$dsym")"
            out="debug-symbols/${base}.zip"
            echo "debug-symbols: zipping $dsym -> $out"
            rm -f "$out"
            # Use `ditto` to preserve bundle structure/metadata for dSYM directories.
            ditto -c -k --sequesterRsrc --keepParent "$dsym" "$out"
          done

          ls -lah debug-symbols

      - name: Upload debug symbol archives (macOS)
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: debug-symbols-${{ needs.preflight.outputs.artifact_label }}-${{ matrix.cache_target }}
          path: debug-symbols/*.zip
          if-no-files-found: error

      - name: Desktop dist asset report
        if: runner.os == 'macOS'
        run: node scripts/desktop_dist_asset_report.mjs --json-out desktop-dist-assets-report.json
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Validate macOS bundle
        if: runner.os == 'macOS'
        run: bash scripts/validate-macos-bundle.sh

      - name: Verify macOS signed app entitlements (hardened runtime)
        # Only run when code signing is enabled (forks/dry-runs may not have signing secrets).
        if: runner.os == 'macOS' && secrets.APPLE_CERTIFICATE != '' && secrets.APPLE_CERTIFICATE_PASSWORD != '' && secrets.APPLE_SIGNING_IDENTITY != ''
        run: |
          set -euo pipefail
          # Cargo workspaces typically emit bundle outputs under `<repo>/target/**`, but standalone
          # Tauri projects use `<src-tauri>/target/**`. Support both so signed-release validation
          # doesn't fail when the build output layout changes.
          search_roots=(
            apps/desktop/src-tauri/target/universal-apple-darwin
            apps/desktop/target/universal-apple-darwin
            target/universal-apple-darwin
            apps/desktop/src-tauri/target
            apps/desktop/target
            target
          )

          app=""
          for root in "${search_roots[@]}"; do
            if [[ -d "$root" ]]; then
              candidate="$(find "$root" -maxdepth 12 -type d -path '*/release/bundle/macos/*.app' -print 2>/dev/null | head -n 1 || true)"
              if [[ -n "$candidate" ]]; then
                app="$candidate"
                break
              fi
            fi
          done

          if [[ -z "${app:-}" ]]; then
            echo "::error::No .app bundle found under expected release bundle roots." >&2
            echo "Searched: ${search_roots[*]}" >&2
            for root in "${search_roots[@]}"; do
              if [[ -d "$root" ]]; then
                echo "Available .app directories under $root (first 20):" >&2
                find "$root" -maxdepth 12 -type d -name '*.app' -print 2>/dev/null | head -n 20 || true
              fi
            done
            exit 1
          fi
          echo "Verifying entitlements embedded in: $app"
          codesign --verify --deep --strict --verbose=2 "$app"
          tmp_entitlements="$(mktemp -t formula-entitlements.XXXXXX)"
          tmp_raw="$(mktemp -t formula-entitlements-raw.XXXXXX)"
          trap 'rm -f "$tmp_entitlements" "$tmp_raw"' EXIT

          # `codesign -d` may print non-XML metadata (e.g. "Executable=...") alongside the entitlements.
          # Extract just the plist so we can lint + validate it using the same guardrail script.
          codesign -d --entitlements :- "$app" 2>&1 | tee "$tmp_raw" \
            | awk 'BEGIN{p=0} /^[[:space:]]*<\\?xml/{p=1} /^[[:space:]]*<plist/{if(p==0)p=1} p{print} p && /<\\/plist>/{exit}' \
            > "$tmp_entitlements"

          if [[ ! -s "$tmp_entitlements" ]]; then
            echo "::error::Failed to extract entitlements plist from codesign output." >&2
            echo "Raw codesign output:" >&2
            cat "$tmp_raw" >&2 || true
            exit 1
          fi

          node scripts/check-macos-entitlements.mjs --path "$tmp_entitlements"

      - name: Setup MSVC cross-compilation environment (amd64 → arm64)
        # Only needed for the Windows ARM64 bundle job; set it immediately before the Tauri build so
        # earlier host-target `cargo install` steps (wasm-pack, tauri-cli) and the COI smoke check run
        # in the default x64 environment.
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        uses: ilammy/msvc-dev-cmd@7defe9254715b088f12dddd9942945a3d75cdad5 # v1.9.0
        with:
          arch: amd64_arm64

      - name: Build and upload release assets
        if: runner.os != 'macOS' && needs.preflight.outputs.upload == 'true'
        # Pinned for reproducible releases: avoid upstream floating major tags moving and breaking builds.
        # To upgrade, bump to a newer `v0.x.y` tag in a PR after verifying the release workflow.
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: ${{ matrix.tauri_args }}
          tagName: ${{ needs.preflight.outputs.release_tag }}
          releaseName: Formula ${{ needs.preflight.outputs.release_tag }}
          releaseBody: |
            Automated build for ${{ needs.preflight.outputs.release_tag }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          # Mark GitHub Releases as prereleases when the semver tag contains a
          # prerelease suffix like `-beta.1` or `-rc.0` (e.g. `v1.2.3-beta.1`).
          prerelease: ${{ contains(needs.preflight.outputs.release_tag, '-') }}

      - name: Build desktop bundles (dry run)
        if: runner.os != 'macOS' && needs.preflight.outputs.upload != 'true'
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: ${{ matrix.tauri_args }}

      - name: Validate bundles include LICENSE/NOTICE
        run: python scripts/ci/validate-desktop-bundle-compliance.py

      - name: Package Windows debug symbols (PDB)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "debug-symbols: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $candidatePdbs = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/formula-desktop.pdb"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release/formula-desktop.pdb"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/formula-desktop.pdb")
          )

          $pdbPath = $candidatePdbs | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $pdbPath) {
            $joined = $candidatePdbs -join "`n"
            throw "debug-symbols: ERROR formula-desktop.pdb not found. Looked in:`n$joined"
          }

          New-Item -ItemType Directory -Force -Path "debug-symbols" | Out-Null
          Copy-Item -Force $pdbPath "debug-symbols/formula-desktop.pdb"

          $zipPath = "debug-symbols/formula-desktop.pdb.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path "debug-symbols/formula-desktop.pdb" -DestinationPath $zipPath

          Get-ChildItem -Path "debug-symbols" | Format-Table Name,Length

      - name: Upload debug symbol archives (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: debug-symbols-${{ needs.preflight.outputs.artifact_label }}-${{ matrix.cache_target }}
          path: debug-symbols/*.zip
          if-no-files-found: error

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        # Run against the already-built Tauri artifacts from the previous step.
        # Skip Windows ARM64 cross-compile builds (the produced binary isn't runnable on x64 runners).
        if: >-
          (runner.os == 'Linux' || (vars.FORMULA_COI_CHECK_ALL_PLATFORMS != '0' && vars.FORMULA_COI_CHECK_ALL_PLATFORMS != 'false'))
          && (runner.os != 'Windows' || matrix.rust_target != 'aarch64-pc-windows-msvc')
        run: pnpm -C apps/desktop check:coi -- --no-build

      - name: Desktop dist asset report
        if: runner.os != 'macOS'
        run: node scripts/desktop_dist_asset_report.mjs --json-out desktop-dist-assets-report.json
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Upload desktop dist asset report (JSON)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: desktop-dist-assets-report-${{ needs.preflight.outputs.artifact_label }}-${{ matrix.cache_target }}
          path: desktop-dist-assets-report.json
          if-no-files-found: ignore

      - name: Validate Linux AppImage bundle
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          for script in scripts/validate-linux-appimage.*; do
            echo "Running $script"
            case "$script" in
              *.mjs|*.js) node "$script" ;;
              *.py) python "$script" ;;
              *) bash "$script" ;;
            esac
          done

      - name: Validate Linux RPM bundle
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          for script in scripts/validate-linux-rpm.*; do
            echo "Running $script"
            case "$script" in
              *.mjs|*.js) node "$script" ;;
              *.py) python "$script" ;;
              *) bash "$script" ;;
            esac
          done

      - name: Validate Windows bundles
        if: runner.os == 'Windows'
        shell: pwsh
        run: ./scripts/validate-windows-bundles.ps1

      - name: Verify Windows ARM64 binary architecture (AA64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $releaseCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release")
          )
          $releaseDir = $releaseCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $releaseDir) {
            $candidatesJoined = $releaseCandidates -join "`n"
            throw "windows-arm64: Expected Rust release directory not found. Looked in:`n$candidatesJoined"
          }
          $exe = Get-ChildItem -Path $releaseDir -Recurse -File -Filter "formula-desktop.exe" | Select-Object -First 1
          if (-not $exe) {
            throw "windows-arm64: Expected compiled binary formula-desktop.exe not found under: $releaseDir"
          }
          $dumpbin = Get-Command dumpbin.exe -ErrorAction SilentlyContinue
          if (-not $dumpbin) {
            throw "windows-arm64: dumpbin.exe not found on PATH (expected after MSVC dev-cmd setup)."
          }
          $headers = & dumpbin.exe /headers $exe.FullName
          $joined = ($headers -join "`n")
          $machineLine = ($headers | Select-String -Pattern "machine" -CaseSensitive:$false | Select-Object -First 1).ToString()
          Write-Host "windows-arm64: dumpbin machine line: $machineLine"
          if ($joined -notmatch '\bAA64\b') {
            throw "windows-arm64: Expected ARM64 machine type 'AA64' in dumpbin output for $($exe.FullName), but it was not found. If this is x64, the ARM64 target toolchain/environment is misconfigured."
          }
          if ($joined -match '\b8664\b') {
            throw "windows-arm64: Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
          }

      - name: Smoke test produced AppImage (extract + ldd + arch)
        if: runner.os == 'Linux'
        run: bash scripts/ci/check-appimage.sh

      - name: Validate produced AppImage desktop integration (.desktop + xlsx MIME)
        if: runner.os == 'Linux'
        run: bash scripts/validate-linux-appimage.sh

      - name: Verify Linux .deb package (deps + ldd + desktop integration)
        if: matrix.platform == 'ubuntu-24.04'
        shell: bash
        run: |
          set -euo pipefail
          # Preferred location (matches docs/release.md), but fall back to scanning common Cargo target dirs.
          #
          # Use globs instead of `find` to avoid traversing the entire Cargo target directory (which can be large).
          shopt -s nullglob
          debs=(apps/desktop/src-tauri/target/release/bundle/deb/*.deb)

          if ((${#debs[@]} == 0)); then
            roots=()
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              roots+=("${CARGO_TARGET_DIR}")
            fi
            roots+=("apps/desktop/src-tauri/target" "apps/desktop/target" "target")

            debs=()
            for root in "${roots[@]}"; do
              [[ -d "${root}" ]] || continue
              debs+=("${root}"/release/bundle/deb/*.deb)
              debs+=("${root}"/*/release/bundle/deb/*.deb)
            done
          fi

          # De-dupe for deterministic logs (and to avoid double-validating when roots overlap).
          if ((${#debs[@]} > 0)); then mapfile -t debs < <(printf '%s\n' "${debs[@]}" | sort -u); fi
          shopt -u nullglob

          if ((${#debs[@]} == 0)); then
            echo "::error::could not find any .deb artifacts under apps/desktop/src-tauri/target/release/bundle/deb or target/**/release/bundle/deb" >&2
            echo "Debug: searched roots:" >&2
            echo "  - apps/desktop/src-tauri/target/release/bundle/deb/*.deb" >&2
            echo "  - CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-<unset>}" >&2
            echo "  - apps/desktop/src-tauri/target" >&2
            echo "  - apps/desktop/target" >&2
            echo "  - target" >&2
            exit 1
          fi

          if ((${#debs[@]} > 1)); then
            echo "Found multiple .deb artifacts; validating all:"
            printf '  - %s\n' "${debs[@]}"
          fi

          for deb in "${debs[@]}"; do
            echo "Using deb: ${deb}"

            echo "::group::dpkg -I ${deb}"
            dpkg -I "${deb}" | tee dpkg-info.txt
            echo "::endgroup::"

            # Ensure key runtime deps are declared (at least: WebKitGTK + GTK + AppIndicator).
            depends="$(awk '
              BEGIN { in_dep=0; out="" }
              /^[[:space:]]*Depends:/ {
                in_dep=1
                sub(/^[[:space:]]*Depends:[[:space:]]*/, "", $0)
                out=$0
                next
              }
              in_dep==1 {
                if ($0 ~ /^[[:space:]]+[A-Za-z0-9-]+:/) { exit }
                sub(/^[[:space:]]+/, "", $0)
                if (out == "") out=$0; else out=out " " $0
              }
              END { print out }
            ' dpkg-info.txt)"
            if [[ -z "${depends// }" ]]; then
              echo "::error::Could not parse Depends from dpkg -I output for ${deb}" >&2
              exit 1
            fi
            echo "dpkg Depends: ${depends}"
            for needle in "webkit2gtk" "libgtk-3" "appindicator"; do
              if ! grep -qi "$needle" <<<"${depends}"; then
                echo "::error::Expected runtime dependency '$needle' missing from dpkg Depends for ${deb}" >&2
                exit 1
              fi
            done

            tmpdir="$(mktemp -d)"
            trap 'rm -rf "${tmpdir}"' EXIT
            dpkg-deb -x "${deb}" "${tmpdir}"

            bin="${tmpdir}/usr/bin/formula-desktop"
            if [[ ! -f "${bin}" ]]; then
              echo "::error::Expected installed binary not found at ${bin} after extracting ${deb}"
              echo "Extracted file tree (first 200 entries):"
              find "${tmpdir}" -maxdepth 5 -type f -print | head -n 200
              exit 1
            fi

            echo "::group::ldd ${bin}"
            ldd "${bin}" | tee ldd.txt
            echo "::endgroup::"
            if grep -q "not found" ldd.txt; then
              echo "::error::Missing shared library dependencies detected by ldd for ${bin}"
              exit 1
            fi

            # Optional lightweight runtime smoke test: the desktop binary supports a special
            # `--cross-origin-isolation-check` mode that starts the webview under a virtual display
            # and exits quickly with a status code.
            echo "::group::Run packaged binary smoke check (--cross-origin-isolation-check)"
            (
              export HOME="${tmpdir}/home"
              export XDG_CONFIG_HOME="${HOME}/.config"
              export XDG_DATA_HOME="${HOME}/.local/share"
              mkdir -p "${XDG_CONFIG_HOME}" "${XDG_DATA_HOME}"
              if [[ -z "${XDG_RUNTIME_DIR:-}" ]]; then
                export XDG_RUNTIME_DIR="${HOME}/.run"
                mkdir -p "${XDG_RUNTIME_DIR}"
                chmod 700 "${XDG_RUNTIME_DIR}"
              fi
              # Run `timeout` *inside* the xvfb helper so the helper's EXIT trap can reliably
              # clean up the background Xvfb process even when the command times out.
              bash scripts/xvfb-run-safe.sh timeout 45s "${bin}" --cross-origin-isolation-check
            )
            echo "::endgroup::"

            python scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir}"

            rm -rf "${tmpdir}"
            trap - EXIT
          done

      - name: Upload desktop bundles (dry run)
        if: needs.preflight.outputs.upload != 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: desktop-bundles-${{ needs.preflight.outputs.artifact_label }}-${{ matrix.platform }}${{ matrix.rust_target != '' && format('-{0}', matrix.rust_target) || '' }}
          if-no-files-found: error
          path: |
            apps/desktop/src-tauri/target/**/release/bundle/**
            target/**/release/bundle/**

      - name: Export updater manifest for merge (latest.json)
        if: needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
        run: node scripts/ci/export-updater-manifest.mjs "updater-manifest/latest-${{ matrix.cache_target }}.json"

      - name: Upload updater manifest artifact (per-platform)
        if: needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: updater-manifest-${{ matrix.cache_target }}
          path: updater-manifest/latest-${{ matrix.cache_target }}.json
          if-no-files-found: error

      - name: Validate Windows installer bundles (presence + Authenticode)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-bundle: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $bundleDir = Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"
          if (-not (Test-Path $bundleDir)) {
            throw "windows-bundle: ERROR expected Tauri bundle dir not found at: $bundleDir`nThis should be produced by the release build for target '$target'."
          }

          # Lightweight post-build assertion: ensure we produced at least one Windows installer file
          # (either MSI or EXE) under the per-target bundle directory.
          ./scripts/validate-windows-bundles.ps1 -BundleDir $bundleDir

      - name: Verify Windows installer signatures (signtool verify /pa /v)
        if: runner.os == 'Windows' && ((secrets.WINDOWS_CERTIFICATE != '' && secrets.WINDOWS_CERTIFICATE_PASSWORD != '') || vars.FORMULA_REQUIRE_CODESIGN == '1')
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-sigcheck: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-sigcheck: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }

          python scripts/ci/check-windows-installer-signatures.py --bundle-dir "$bundleDir"

      - name: Verify Windows ARM64 MSI targets ARM64 (template summary)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-arm64-msi: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }
          $msis = @(
            Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue
          )
          if ($msis.Count -eq 0) {
            throw "windows-arm64-msi: ERROR no .msi installers found under: $bundleDir"
          }

          $installer = New-Object -ComObject WindowsInstaller.Installer
          foreach ($msi in $msis) {
            $db = $installer.OpenDatabase($msi.FullName, 0)
            $summary = $db.SummaryInformation(0)
            $template = $summary.Property(7)
            Write-Host "windows-arm64-msi: $($msi.Name) template=$template"
            if ($template -notmatch '(?i)arm64') {
              throw "windows-arm64-msi: ERROR Expected MSI Template Summary to include ARM64 for $($msi.FullName), got: $template"
            }
          }

      - name: Verify Windows installers bundle/reference WebView2 (bootstrapper/runtime)
        if: runner.os == 'Windows'
        run: python scripts/ci/check-windows-webview2-installer.py

      - name: Verify Linux release artifacts (AppImage + deb + rpm + signatures)
        if: runner.os == 'Linux'
        shell: bash
        env:
          FORMULA_HAS_TAURI_UPDATER_KEY: ${{ secrets.TAURI_PRIVATE_KEY != '' }}
          # Updater signature files (`*.sig`) are only generated when the updater private key is
          # configured. Forks/dry-runs often have no secrets, so we skip `.sig` validation there.
          #
          # In the upstream repo we *require* updater signatures to avoid accidentally publishing
          # a release without auto-update metadata/signatures.
          FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES: ${{ github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '' }}
        run: |
          set -euo pipefail

          # Tauri bundles normally live under `src-tauri/target/release/bundle`, but can also
          # end up under `src-tauri/target/<triple>/release/bundle` if `--target` is used.
          bundle_roots=()
          # Prefer `CARGO_TARGET_DIR` if it's set (some Tauri builds export it), but also scan the
          # common workspace/default target roots.
          if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
            cargo_target_dir="${CARGO_TARGET_DIR}"
            if [[ "${cargo_target_dir}" != /* ]]; then
              cargo_target_dir="${PWD}/${cargo_target_dir}"
            fi
            if [[ -d "${cargo_target_dir}" ]]; then
              bundle_roots+=("${cargo_target_dir}")
            fi
          fi
          for root in "apps/desktop/src-tauri/target" "apps/desktop/target" "target"; do
            if [[ -d "$root" ]]; then
              bundle_roots+=("$root")
            fi
          done
          if ((${#bundle_roots[@]} == 0)); then
            echo "Expected Tauri target directory not found. Looked in: CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-} apps/desktop/src-tauri/target apps/desktop/target target" >&2
            exit 1
          fi

          # Canonicalize + de-dupe bundle roots (avoid duplicate scanning when CARGO_TARGET_DIR overlaps defaults).
          declare -A seen_bundle_roots=()
          uniq_bundle_roots=()
          for root in "${bundle_roots[@]}"; do
            abs="$(cd "$root" && pwd -P)"
            if [[ -n "${seen_bundle_roots[${abs}]:-}" ]]; then
              continue
            fi
            seen_bundle_roots["${abs}"]=1
            uniq_bundle_roots+=("${abs}")
          done
          bundle_roots=("${uniq_bundle_roots[@]}")

          # Use predictable bundle globs (fast) rather than `find` (which traverses the entire Cargo target dir).
          shopt -s nullglob
          appimages=()
          debs=()
          rpms=()
          for root in "${bundle_roots[@]}"; do
            appimages+=("$root"/release/bundle/appimage/*.AppImage)
            appimages+=("$root"/*/release/bundle/appimage/*.AppImage)
            debs+=("$root"/release/bundle/deb/*.deb)
            debs+=("$root"/*/release/bundle/deb/*.deb)
            rpms+=("$root"/release/bundle/rpm/*.rpm)
            rpms+=("$root"/*/release/bundle/rpm/*.rpm)
          done
          shopt -u nullglob

          if ((${#appimages[@]} > 0)); then mapfile -t appimages < <(printf '%s\n' "${appimages[@]}" | sort -u); fi
          if ((${#debs[@]} > 0)); then mapfile -t debs < <(printf '%s\n' "${debs[@]}" | sort -u); fi
          if ((${#rpms[@]} > 0)); then mapfile -t rpms < <(printf '%s\n' "${rpms[@]}" | sort -u); fi

          echo "Bundle outputs:"
          printf '  AppImage: %s\n' "${#appimages[@]}"
          printf '  deb:      %s\n' "${#debs[@]}"
          printf '  rpm:      %s\n' "${#rpms[@]}"

          if ((${#appimages[@]} == 0)); then
            echo "Missing required Linux artifact: .AppImage" >&2
            exit 1
          fi
          if ((${#debs[@]} == 0)); then
            echo "Missing required Linux artifact: .deb" >&2
            exit 1
          fi
          if ((${#rpms[@]} == 0)); then
            echo "Missing required Linux artifact: .rpm" >&2
            exit 1
          fi

          if [[ "${FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES}" == "true" && "${FORMULA_HAS_TAURI_UPDATER_KEY}" != "true" ]]; then
            echo "TAURI_PRIVATE_KEY is required to validate updater signatures but is not configured." >&2
            exit 1
          fi

          if [[ "${FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES}" == "true" ]]; then
            # Ensure updater signature files exist for each bundle type.
            for artifact in "${appimages[@]}" "${debs[@]}" "${rpms[@]}"; do
              if [[ ! -f "${artifact}.sig" ]]; then
                echo "Missing signature file for ${artifact} (expected ${artifact}.sig)" >&2
                exit 1
              fi
            done
          else
            echo "TAURI_PRIVATE_KEY not configured; skipping updater signature (*.sig) verification."
          fi

      - name: Verify Linux package dependency metadata (deb + rpm)
        if: runner.os == 'Linux'
        run: bash scripts/ci/verify-linux-package-deps.sh

      - name: Verify macOS universal binary (lipo)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Locate the packaged `.app` under the Tauri bundle output directory and verify the
          # main executable is a universal binary (x86_64 + arm64).
          #
          # Prefer the universal target output (`**/universal-apple-darwin/**`) to avoid
          # accidentally validating an intermediate single-arch bundle.
          app_path=""

          app_path="$(
            find apps/desktop/src-tauri/target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
          )"
          if [[ -z "$app_path" ]]; then
            # Some Tauri builds export `CARGO_TARGET_DIR`. Check it next so this verification stays
            # correct even if the workflow tweaks target dir routing for caching.
            cargo_target_dir="${CARGO_TARGET_DIR:-}"
            if [[ -n "$cargo_target_dir" && "$cargo_target_dir" != /* ]]; then
              cargo_target_dir="${PWD}/${cargo_target_dir}"
            fi
            if [[ -n "$cargo_target_dir" && -d "$cargo_target_dir" ]]; then
              app_path="$(
                find "$cargo_target_dir/universal-apple-darwin" -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
              )"
              if [[ -z "$app_path" ]]; then
                app_path="$(
                  find "$cargo_target_dir" -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
                )"
              fi
            fi
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/target/universal-apple-darwin -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/src-tauri/target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find apps/desktop/target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            app_path="$(
              find target -type d -path '*/release/bundle/*/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi

          if [[ -z "$app_path" ]]; then
            echo "::error::No .app bundle found under the expected Cargo target directories (CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-})." >&2
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              echo
              echo "CARGO_TARGET_DIR *.app bundles:"
              find "${cargo_target_dir}" -type d -name '*.app' -print 2>/dev/null || true
            fi
            echo "apps/desktop/src-tauri/target *.app bundles:"
            find apps/desktop/src-tauri/target -type d -name '*.app' -print 2>/dev/null || true
            echo
            echo "apps/desktop/target *.app bundles:"
            find apps/desktop/target -type d -name '*.app' -print 2>/dev/null || true
            echo
            echo "target *.app bundles:"
            find target -type d -name '*.app' -print 2>/dev/null || true
            exit 1
          fi

          echo "Found app bundle: $app_path"
          macos_dir="$app_path/Contents/MacOS"
          if [[ ! -d "$macos_dir" ]]; then
            echo "::error::Expected Contents/MacOS directory not found: $macos_dir" >&2
            find "$app_path/Contents" -maxdepth 2 -print 2>/dev/null || true
            exit 1
          fi

          # Prefer the bundle-declared executable (CFBundleExecutable) so this check stays correct
          # even if the binary name changes.
          exe_name=""
          info_plist="$app_path/Contents/Info.plist"
          if [[ -f "$info_plist" ]]; then
            exe_name="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleExecutable' "$info_plist" 2>/dev/null || true)"
          fi
          if [[ -z "$exe_name" ]]; then
            exe_name="formula-desktop"
          fi

          bin_path="$macos_dir/$exe_name"
          if [[ ! -f "$bin_path" ]]; then
            # Fall back to the first executable file under Contents/MacOS (avoid picking non-binaries).
            bin_path="$(find "$macos_dir" -maxdepth 1 -type f -perm -0100 -print | head -n 1 || true)"
          fi
          if [[ -z "$bin_path" || ! -f "$bin_path" ]]; then
            echo "::error::Could not find app executable under $macos_dir" >&2
            ls -la "$macos_dir" || true
            exit 1
          fi

          echo "Checking architectures for: $bin_path"
          info="$(lipo -info "$bin_path" | tee /dev/stderr)"
          echo "$info" | grep -qw "x86_64" || { echo "::error::macOS binary is missing x86_64 slice"; exit 1; }
          echo "$info" | grep -qw "arm64" || { echo "::error::macOS binary is missing arm64 slice"; exit 1; }

      - name: Validate macOS bundle (DMG, Info.plist, signing)
        # Always run on macOS so unsigned fork/dry-run builds still validate bundle structure.
        # Codesign + notarization checks are conditional on env vars (APPLE_* secrets) and are
        # skipped automatically when signing is not configured.
        if: runner.os == 'macOS'
        shell: bash
        run: bash scripts/validate-macos-bundle.sh

      - name: Verify Windows ARM64 binary (formula-desktop.exe is AA64)
        if: matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $exeCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/formula-desktop.exe'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/formula-desktop.exe')
          )
          $exe = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$exe) {
            Write-Error "Expected ARM64 executable not found. Looked in:`n$($exeCandidates -join [Environment]::NewLine)`nDid the build run with --target aarch64-pc-windows-msvc?"
            exit 1
          }

          # Locate dumpbin from the installed Visual Studio toolchain.
          $vswhere = Join-Path ${env:ProgramFiles(x86)} 'Microsoft Visual Studio/Installer/vswhere.exe'
          if (!(Test-Path $vswhere)) {
            Write-Error "vswhere.exe not found at: $vswhere"
            exit 1
          }

          $vsInstall = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
          if (!$vsInstall) {
            Write-Error 'Unable to locate a Visual Studio installation via vswhere.'
            exit 1
          }

          $msvcRoot = Join-Path $vsInstall 'VC/Tools/MSVC'
          if (!(Test-Path $msvcRoot)) {
            Write-Error "MSVC tools dir not found at: $msvcRoot"
            exit 1
          }

          $dumpbin = Get-ChildItem -Path $msvcRoot -Filter dumpbin.exe -Recurse -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match '\\bin\\Hostx64\\x64\\dumpbin\.exe$' } |
            Sort-Object -Property FullName -Descending |
            Select-Object -First 1

          if (!$dumpbin) {
            Write-Error "dumpbin.exe not found under: $msvcRoot"
            exit 1
          }

          $headers = & $dumpbin.FullName /headers $exe
          $headersText = ($headers | Out-String)
          Write-Host $headersText

          if ($headersText -notmatch 'AA64') {
            Write-Error "Expected ARM64 machine type 'AA64' in dumpbin output, but it was not found."
            exit 1
          }

          if ($headersText -match '8664') {
            Write-Error "Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
            exit 1
          }

      - name: Verify Windows ARM64 updater signatures exist
        if: matrix.rust_target == 'aarch64-pc-windows-msvc' && secrets.TAURI_PRIVATE_KEY != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target/aarch64-pc-windows-msvc/release/bundle'),
            (Join-Path $env:GITHUB_WORKSPACE 'target/aarch64-pc-windows-msvc/release/bundle')
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (!$bundleDir) {
            Write-Error "Bundle output dir not found. Looked in:`n$($bundleCandidates -join [Environment]::NewLine)"
            exit 1
          }

          $sigs = Get-ChildItem -Path $bundleDir -Recurse -File -Filter '*.sig'
          if ($sigs.Count -lt 1) {
            Write-Error "No updater signature files (*.sig) found under: $bundleDir"
            exit 1
          }

          Write-Host "Found updater signatures:"
          $sigs | ForEach-Object { Write-Host "- $($_.FullName)" }

      - name: Validate desktop release artifacts
        env:
          FORMULA_HAS_TAURI_UPDATER_KEY: ${{ secrets.TAURI_PRIVATE_KEY != '' }}
          # `latest.json` is only generated/uploaded when we publish to a GitHub Release.
          # In dry-run (workflow_dispatch upload=false) we still validate installer artifacts exist,
          # but we skip enforcing updater signatures/manifest files.
          FORMULA_REQUIRE_TAURI_UPDATER_SIGNATURES: ${{ needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '') }}
        run: node scripts/ci/check-desktop-release-artifacts.mjs

      - name: Verify macOS bundle file associations + deep link schemes
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Prefer the universal build output path, but fall back to any `.app` under the bundle dirs.
          app_path="$(
            find apps/desktop/src-tauri/target -type d -path '*/release/bundle/macos/*.app' -prune -print 2>/dev/null | head -n 1 || true
          )"
          if [[ -z "${app_path}" ]]; then
            app_path="$(
              find target -type d -path '*/release/bundle/macos/*.app' -prune -print 2>/dev/null | head -n 1 || true
            )"
          fi
          if [[ -z "${app_path}" ]]; then
            echo "::error::Could not find a built .app bundle under apps/desktop/src-tauri/target/**/release/bundle/macos" >&2
            find apps/desktop/src-tauri/target -maxdepth 12 -type d -name '*.app' -print | head -n 20 || true
            find target -maxdepth 12 -type d -name '*.app' -print | head -n 20 || true
            exit 1
          fi

          info_plist="${app_path}/Contents/Info.plist"
          if [[ ! -f "${info_plist}" ]]; then
            echo "::error::Missing Info.plist at: ${info_plist}" >&2
            exit 1
          fi

          echo "App bundle: ${app_path}"
          echo "Info.plist: ${info_plist}"
          echo "::group::plutil -p ${info_plist} (first 200 lines)"
          plutil -p "${info_plist}" | head -n 200
          echo "::endgroup::"

          python scripts/ci/verify_macos_bundle_associations.py --info-plist "${info_plist}"

      - name: Verify Linux desktop integration in packages (.deb + .rpm)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail

          deb="$(find apps/desktop/src-tauri/target target -type f -path '*/release/bundle/deb/*.deb' -print 2>/dev/null | head -n 1 || true)"
          if [[ -z "${deb}" ]]; then
            echo "::error::Could not find a .deb under apps/desktop/src-tauri/target/**/release/bundle/deb" >&2
            find apps/desktop/src-tauri/target -maxdepth 10 -type f -name '*.deb' -print | head -n 20 || true
            find target -maxdepth 10 -type f -name '*.deb' -print | head -n 20 || true
            exit 1
          fi

          echo "Validating .deb desktop integration: ${deb}"
          tmpdir_deb="$(mktemp -d)"
          dpkg-deb -x "${deb}" "${tmpdir_deb}"
          python scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_deb}"

          rpm_path="$(find apps/desktop/src-tauri/target target -type f -path '*/release/bundle/rpm/*.rpm' -print 2>/dev/null | head -n 1 || true)"
          if [[ -z "${rpm_path}" ]]; then
            echo "::error::Could not find a .rpm under apps/desktop/src-tauri/target/**/release/bundle/rpm" >&2
            find apps/desktop/src-tauri/target -maxdepth 10 -type f -name '*.rpm' -print | head -n 20 || true
            find target -maxdepth 10 -type f -name '*.rpm' -print | head -n 20 || true
            exit 1
          fi

          if ! command -v rpm2cpio >/dev/null 2>&1; then
            echo "::error::rpm2cpio is required to extract .rpm artifacts for validation (missing on PATH)" >&2
            exit 1
          fi
          if ! command -v cpio >/dev/null 2>&1; then
            echo "::error::cpio is required to extract .rpm artifacts for validation (missing on PATH)" >&2
            exit 1
          fi

          echo "Validating .rpm desktop integration: ${rpm_path}"
          tmpdir_rpm="$(mktemp -d)"
          (cd "${tmpdir_rpm}" && rpm2cpio "${rpm_path}" | cpio -idm --quiet --no-absolute-filenames)
          python scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_rpm}"

      - name: Smoke test Linux .deb install in clean Ubuntu container
        if: runner.os == 'Linux'
        run: bash scripts/ci/linux-package-install-smoke.sh deb

      - name: Smoke test Linux .rpm install in clean Fedora container
        if: runner.os == 'Linux'
        run: bash scripts/ci/linux-package-install-smoke.sh rpm

      - name: Smoke test Linux .rpm install in clean openSUSE container (optional)
        if: runner.os == 'Linux' && vars.FORMULA_OPENSUSE_SMOKE == '1'
        env:
          FORMULA_RPM_SMOKE_IMAGE: opensuse/tumbleweed:latest
        run: bash scripts/ci/linux-package-install-smoke.sh rpm
      - name: Dump macOS effective entitlements (codesign) (signed builds only)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          # Only run when signing secrets are configured. On forks/dry-runs we build unsigned
          # artifacts (see `scripts/ci/prepare-tauri-signing-config.mjs`).
          if [[ -z "${APPLE_CERTIFICATE:-}" || -z "${APPLE_CERTIFICATE_PASSWORD:-}" ]]; then
            echo "Skipping entitlements dump: macOS signing secrets not configured (unsigned build)."
            exit 0
          fi

          search_roots=(target apps/desktop/src-tauri/target apps/desktop/target)
          app_path=""
          for root in "${search_roots[@]}"; do
            if [[ -d "$root" ]]; then
              candidate="$(find "$root" -type d -path "*/release/bundle/macos/Formula.app" | head -n 1 || true)"
              if [[ -n "$candidate" ]]; then
                app_path="$candidate"
                break
              fi
            fi
          done

          if [[ -z "$app_path" ]]; then
            for root in "${search_roots[@]}"; do
              if [[ -d "$root" ]]; then
                candidate="$(find "$root" -type d -path "*/release/bundle/macos/*.app" | head -n 1 || true)"
                if [[ -n "$candidate" ]]; then
                  app_path="$candidate"
                  break
                fi
              fi
            done
          fi

          if [[ -z "$app_path" ]]; then
            echo "No .app bundle found under expected Tauri bundle roots; skipping."
            exit 0
          fi

          echo "Found app bundle: $app_path"

          echo "::group::codesign --verify $app_path"
          if ! /usr/bin/codesign --verify --deep --strict --verbose=2 "$app_path"; then
            echo "::error::codesign verification failed for app bundle: $app_path" >&2
            exit 1
          fi
          echo "::endgroup::"

          exe_path="$app_path/Contents/MacOS/formula-desktop"
          if [[ ! -f "$exe_path" ]]; then
            exe_path="$(find "$app_path/Contents/MacOS" -maxdepth 1 -type f | head -n 1 || true)"
          fi

          if [[ -z "$exe_path" || ! -f "$exe_path" ]]; then
            echo "Could not locate main executable inside: $app_path"
            exit 0
          fi

          echo "Dumping effective entitlements from: $exe_path"
          /usr/bin/codesign -d --entitlements :- "$exe_path" || true
      - name: Verify desktop binary is stripped (no symbols)
        run: python scripts/verify_desktop_binary_stripped.py

      - name: Report desktop installer artifact sizes
        env:
          # Enforce the installer artifact size budget on tagged releases by default.
          # Override via GitHub Actions "Variables":
          # - FORMULA_ENFORCE_BUNDLE_SIZE=0 (or "false") to disable enforcement
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE || '1' }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        run: python scripts/desktop_bundle_size_report.py --json desktop-bundle-size-report.json

      - name: Upload desktop installer artifact size report (JSON)
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: desktop-bundle-size-report-${{ needs.preflight.outputs.artifact_label }}-${{ matrix.platform }}${{ matrix.rust_target != '' && format('-{0}', matrix.rust_target) || '' }}
          path: desktop-bundle-size-report.json
          if-no-files-found: warn

  publish-updater-manifest:
    name: Publish combined updater manifest (latest.json)
    needs: [build, preflight]
    # Publishing `latest.json` requires updater signatures (`latest.json.sig`) which are only
    # produced when TAURI_PRIVATE_KEY is configured. We only publish in the upstream repo or when
    # forks have configured their own updater key secrets.
    if: needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download per-platform updater manifests
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: updater-manifest-*
          path: updater-manifest
          merge-multiple: true

      - name: Publish combined updater manifest (latest.json + latest.json.sig)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: node scripts/ci/publish-updater-manifest.mjs "${{ needs.preflight.outputs.release_tag }}" updater-manifest

  verify-updater-manifest:
    name: Verify updater manifest (latest.json)
    needs: [publish-updater-manifest, preflight]
    # Validating the updater manifest requires updater signatures (`latest.json.sig`), which are
    # only produced when the TAURI_PRIVATE_KEY secret is configured. We always validate in the
    # upstream repo (to avoid accidentally shipping an unsigned updater manifest) and validate in
    # forks only when the user has configured their own updater key secrets.
    if: needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Validate updater manifest assets + targets
        env:
          # The validator uses the GitHub API to read/download assets from the draft release.
          # Set both token env vars so it works whether it looks for GH_TOKEN or GITHUB_TOKEN.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/verify-tauri-latest-json.mjs "${{ needs.preflight.outputs.release_tag }}"

      - name: Verify updater manifest signature matches embedded pubkey
        run: node scripts/ci/verify-updater-manifest-signature.mjs latest.json latest.json.sig

      - name: Verify updater asset set (installers + signatures)
        env:
          # This validator also uses the GitHub API to read/download assets from the draft release.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/verify-tauri-updater-assets.mjs "${{ needs.preflight.outputs.release_tag }}"
  verify-release-assets:
    name: Verify GitHub Release assets (multi-arch safe)
    # Wait for the combined updater manifest publish step so we don't race while `latest.json`
    # is being deleted/re-uploaded.
    needs: [publish-updater-manifest, preflight]
    if: needs.preflight.outputs.upload == 'true' && (github.repository == 'wilson-anysphere/formula' || secrets.TAURI_PRIVATE_KEY != '')
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      - name: Validate release assets are present and uniquely named per target
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ needs.preflight.outputs.release_tag }}
        shell: bash
        run: |
          set -euo pipefail

          repo="${GITHUB_REPOSITORY}"
          tag="${TAG_NAME}"

          api_base="${GITHUB_API_URL:-https://api.github.com}"
          api_base="${api_base%/}"
          api_url="${api_base}/repos/${repo}/releases/tags/${tag}"
          retry_delays=(2 4 8 12 20)
          # Tauri output naming varies slightly between bundlers (e.g. "x64", "x86_64", "x86-64", "amd64", "win64").
          # Treat these as equivalent x64 markers for collision detection.
          win_x64_re='(x64|x86[_-]64|amd64|win64)'
          win_arm64_re='(arm64|aarch64)'

          fetch_release() {
            curl -sSfL \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H 'Accept: application/vnd.github+json' \
              -H 'X-GitHub-Api-Version: 2022-11-28' \
              "${api_url}"
          }

          fetch_assets() {
            local release_id="$1"
            local per_page=100
            local page=1
            local all='[]'

            while :; do
              page_json="$(curl -sSfL \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H 'Accept: application/vnd.github+json' \
                -H 'X-GitHub-Api-Version: 2022-11-28' \
                "${api_base}/repos/${repo}/releases/${release_id}/assets?per_page=${per_page}&page=${page}")"

              all="$(jq -s '.[0] + .[1]' <(echo "$all") <(echo "$page_json"))"

              page_len="$(echo "$page_json" | jq -r 'length')"
              if [[ "$page_len" -lt "$per_page" ]]; then
                break
              fi
              page=$((page + 1))
            done

            echo "$all"
          }

          # Returns 0 if all required assets are present; 1 otherwise.
          assets_ready() {
            local json="$1"

            local missing=0

            count_matches() {
              local re="$1"
              echo "$json" | jq -r --arg re "$re" '[.[].name | select(test($re; "i"))] | length'
            }

            require_min() {
              local label="$1"
              local re="$2"
              local min="$3"
              local count
              count="$(count_matches "$re")"
              if [[ "$count" -lt "$min" ]]; then
                echo "missing: ${label} (pattern: ${re}, found: ${count}, expected >= ${min})" >&2
                missing=1
              fi
            }

            require_min "latest.json" '^latest\.json$' 1
            require_min "latest.json.sig" '^latest\.json\.sig$' 1
            require_min "macOS DMG" '\.dmg$' 1

            # Tauri's macOS updater artifact is typically a tarball (often `*.app.tar.gz`), but
            # some configurations/tools may emit a plain `*.tar.gz`/`*.tgz`. Accept either while
            # avoiding false positives from Linux `.AppImage.tar.gz` bundles.
            mac_archive_count="$(echo "$json" | jq -r '[.[].name
              | select(test("\\.(tar\\.gz|tgz)$"; "i"))
              | select(test("\\.AppImage\\.tar\\.gz$"; "i") | not)
              | select(test("\\.AppImage\\.tgz$"; "i") | not)
            ] | length')"
            if [[ "$mac_archive_count" -lt 1 ]]; then
              echo "missing: macOS updater archive (expected >= 1 tarball: *.app.tar.gz preferred; allow *.tar.gz/*.tgz). Found ${mac_archive_count}." >&2
              missing=1
            fi

            # Windows multi-arch: ensure distinct installers per architecture were uploaded.
            count_windows_arch() {
              local ext_re="$1"
              local arch_re="$2"
              local other_arch_re="$3"
              echo "$json" | jq -r --arg ext "$ext_re" --arg arch "$arch_re" --arg other "$other_arch_re" '[.[].name
                | select(test($ext; "i"))
                | select(test($arch; "i"))
                | select(test($other; "i") | not)
              ] | length'
            }

            win_x64_msi_count="$(count_windows_arch '\\.msi$' "$win_x64_re" "$win_arm64_re")"
            win_x64_exe_count="$(count_windows_arch '\\.exe$' "$win_x64_re" "$win_arm64_re")"
            win_arm64_msi_count="$(count_windows_arch '\\.msi$' "$win_arm64_re" "$win_x64_re")"
            win_arm64_exe_count="$(count_windows_arch '\\.exe$' "$win_arm64_re" "$win_x64_re")"

            if [[ "$win_x64_msi_count" -lt 1 ]]; then
              echo "missing: Windows x64 MSI (expected >= 1, found ${win_x64_msi_count})" >&2
              missing=1
            fi
            if [[ "$win_x64_exe_count" -lt 1 ]]; then
              echo "missing: Windows x64 EXE (expected >= 1, found ${win_x64_exe_count})" >&2
              missing=1
            fi
            if [[ "$win_arm64_msi_count" -lt 1 ]]; then
              echo "missing: Windows arm64 MSI (expected >= 1, found ${win_arm64_msi_count})" >&2
              missing=1
            fi
            if [[ "$win_arm64_exe_count" -lt 1 ]]; then
              echo "missing: Windows arm64 EXE (expected >= 1, found ${win_arm64_exe_count})" >&2
              missing=1
            fi

            # Linux artifacts shipped on tagged releases.
            require_min "Linux AppImage" '\.AppImage$' 1
            require_min "Linux DEB" '\.deb$' 1
            require_min "Linux RPM" '\.rpm$' 1

            windows_archless_count="$(echo "$json" | jq -r --arg x64 "$win_x64_re" --arg arm64 "$win_arm64_re" '[.[].name
              | select(test("\\.(msi|exe)$"; "i"))
              | select((test($x64; "i") or test($arm64; "i")) | not)
            ] | length')"
            if [[ "$windows_archless_count" -ne 0 ]]; then
              echo "missing: found ${windows_archless_count} Windows installer asset(s) without an arch token" >&2
              missing=1
            fi

            windows_ambiguous_count="$(echo "$json" | jq -r --arg x64 "$win_x64_re" --arg arm64 "$win_arm64_re" '[.[].name
              | select(test("\\.(msi|exe)$"; "i"))
              | select(test($x64; "i"))
              | select(test($arm64; "i"))
            ] | length')"
            if [[ "$windows_ambiguous_count" -ne 0 ]]; then
              echo "missing: found ${windows_ambiguous_count} Windows installer asset(s) matching BOTH x64 and arm64 patterns (ambiguous naming)" >&2
              missing=1
            fi

            require_sigs_for_ext() {
              local label="$1"
              local ext_re="$2"
              local exclude_re="${3:-}"
              local missing_sig_bases
              if [[ -n "${exclude_re}" ]]; then
                missing_sig_bases="$(echo "$json" | jq -r --arg ext "$ext_re" --arg exclude "$exclude_re" '
                  ([.[].name] | unique) as $names |
                  [ $names[]
                    | select(test($ext; "i"))
                    | select(test($exclude; "i") | not)
                    | select(($names | index(. + ".sig")) == null)
                  ] | .[]')"
              else
                missing_sig_bases="$(echo "$json" | jq -r --arg ext "$ext_re" '
                  ([.[].name] | unique) as $names |
                  [ $names[]
                    | select(test($ext; "i"))
                    | select(($names | index(. + ".sig")) == null)
                  ] | .[]')"
              fi
              if [[ -n "${missing_sig_bases}" ]]; then
                echo "missing: ${label} signature files (<asset>.sig) for:" >&2
                echo "${missing_sig_bases}" | sed 's/^/  - /' >&2
                missing=1
              fi
            }

            require_sigs_for_arch() {
              local label="$1"
              local arch_re="$2"
              local other_arch_re="$3"
              local missing_sig_bases
              missing_sig_bases="$(echo "$json" | jq -r --arg arch "$arch_re" --arg other "$other_arch_re" '
                ([.[].name] | unique) as $names |
                [ $names[]
                  | select(test("\\.(msi|exe)$"; "i"))
                  | select(test($arch; "i"))
                  | select(test($other; "i") | not)
                  | select(($names | index(. + ".sig")) == null)
                ] | .[]')"
              if [[ -n "${missing_sig_bases}" ]]; then
                echo "missing: ${label} signature files (<asset>.sig) for:" >&2
                echo "${missing_sig_bases}" | sed 's/^/  - /' >&2
                missing=1
              fi
            }

            # For Tauri auto-update, each Windows installer asset must have a corresponding
            # signature file uploaded alongside it (<asset>.sig). Missing signatures can be a
            # sign of partial uploads or asset clobbering in multi-arch runs.
            require_sigs_for_arch "Windows x64 installer" "$win_x64_re" "$win_arm64_re"
            require_sigs_for_arch "Windows arm64 installer" "$win_arm64_re" "$win_x64_re"

            # Require signatures for each macOS/Linux installer/bundle artifact, not just at least
            # one signature file. This catches partial uploads where the bundle exists but its `.sig`
            # was not attached to the GitHub Release.
            require_sigs_for_ext "macOS DMG" '\\.dmg$'
            require_sigs_for_ext "macOS updater archive" '\\.(tar\\.gz|tgz)$' '\\.AppImage\\.tar\\.gz$|\\.AppImage\\.tgz$'
            require_sigs_for_ext "Linux AppImage" '\\.AppImage$'
            require_sigs_for_ext "Linux DEB" '\\.deb$'
            require_sigs_for_ext "Linux RPM" '\\.rpm$'

            [[ "$missing" -eq 0 ]]
          }

          release_json="$(fetch_release)"
          release_id="$(echo "$release_json" | jq -r '.id')"
          if [[ -z "${release_id}" || "${release_id}" == "null" ]]; then
            echo "::error::Failed to resolve GitHub Release id for tag ${tag}." >&2
            echo "$release_json" | jq -r '.' >&2 || true
            exit 1
          fi
          assets_json="$(fetch_assets "$release_id")"

          if ! assets_ready "$assets_json"; then
            for delay in "${retry_delays[@]}"; do
              echo "Release assets not fully visible yet; retrying in ${delay}s..." >&2
              sleep "$delay"
              release_json="$(fetch_release)"
              release_id="$(echo "$release_json" | jq -r '.id')"
              if [[ -z "${release_id}" || "${release_id}" == "null" ]]; then
                echo "::error::Failed to resolve GitHub Release id for tag ${tag} during retry." >&2
                echo "$release_json" | jq -r '.' >&2 || true
                exit 1
              fi
              assets_json="$(fetch_assets "$release_id")"
              if assets_ready "$assets_json"; then
                break
              fi
            done
          fi

          if ! assets_ready "$assets_json"; then
            echo "::error::Release asset verification failed after retries." >&2
            echo "$assets_json" | jq -r '.[].name' | sort | sed 's/^/::error:: - /' || true
            exit 1
          fi

          release_url="$(echo "$release_json" | jq -r '.html_url')"
          draft="$(echo "$release_json" | jq -r '.draft')"
          asset_count="$(echo "$assets_json" | jq -r 'length')"

          echo "Release: ${tag} (draft=${draft})"
          echo "URL: ${release_url}"
          echo "Assets: ${asset_count}"
          echo

          mapfile -t asset_names < <(echo "$assets_json" | jq -r '.[].name' | sort)
          printf '%s\n' "${asset_names[@]}"

          dup_names="$(printf '%s\n' "${asset_names[@]}" | sort | uniq -d || true)"
          if [[ -n "${dup_names}" ]]; then
            echo "::error::Duplicate asset names found on the release (unexpected):"
            echo "${dup_names}"
            exit 1
          fi

          bucket_for() {
            local name="$1"
            local base="$name"
            [[ "$base" == *.sig ]] && base="${base%.sig}"

            shopt -s nocasematch
            if [[ "$base" == "latest.json" ]]; then
              echo "updater-manifest"
            elif [[ "$base" == *.msi || "$base" == *.exe ]]; then
              if [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "windows-arm64"
              elif [[ "$base" =~ (x64|x86[_-]64|amd64|win64) ]]; then
                echo "windows-x64"
              else
                echo "windows-unknown"
              fi
            elif [[ "$base" == *.dmg || ( ( "$base" == *.tar.gz || "$base" == *.tgz ) && "$base" != *.AppImage.tar.gz && "$base" != *.AppImage.tgz ) ]]; then
              if [[ "$base" =~ universal ]]; then
                echo "macos-universal"
              elif [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "macos-arm64"
              elif [[ "$base" =~ (x64|x86_64) ]]; then
                echo "macos-x64"
              else
                echo "macos-unknown"
              fi
            elif [[ "$base" == *.deb || "$base" == *.rpm || "$base" == *.AppImage || "$base" == *.AppImage.tar.gz ]]; then
              if [[ "$base" =~ (amd64|x86_64|x64) ]]; then
                echo "linux-x64"
              elif [[ "$base" =~ (arm64|aarch64) ]]; then
                echo "linux-arm64"
              else
                echo "linux-unknown"
              fi
            else
              echo "other"
            fi
            shopt -u nocasematch
          }

          declare -A bucket_assets
          for name in "${asset_names[@]}"; do
            bucket="$(bucket_for "$name")"
            bucket_assets["$bucket"]+="${name}"$'\n'
          done

          render_table() {
            echo "| Bucket | Asset |"
            echo "| --- | --- |"
            for bucket in macos-universal windows-x64 windows-arm64 linux-x64 updater-manifest other macos-unknown windows-unknown linux-unknown macos-x64 macos-arm64 linux-arm64; do
              [[ -z "${bucket_assets[$bucket]+x}" ]] && continue
              while IFS= read -r name; do
                [[ -z "$name" ]] && continue
                echo "| ${bucket} | \`${name}\` |"
              done <<< "${bucket_assets[$bucket]}"
            done
          }

          {
            echo "## Release assets (${tag})"
            echo
            render_table
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          echo
          echo "Grouped release assets:"
          render_table

          echo
          echo "Release asset verification passed."

  checksums:
    name: Generate SHA256SUMS.txt
    needs:
      - build
      - preflight
      - verify-updater-manifest
      - verify-release-assets
    if: needs.preflight.outputs.upload == 'true'
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Verify desktop release assets + latest.json and generate SHA256SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/verify-desktop-release-assets.mjs --tag "${{ needs.preflight.outputs.release_tag }}"

      - name: Upload SHA256SUMS.txt to the draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh release upload "${{ needs.preflight.outputs.release_tag }}" SHA256SUMS.txt \
            --repo "${{ github.repository }}" \
            --clobber
