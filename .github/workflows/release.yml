name: Desktop Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

# Prevent multiple runs for the same tag from racing while uploading GitHub Release
# assets (including Tauri updater manifests like `latest.json`). Without this,
# manual re-runs or tag updates can overlap and clobber/partially overwrite the
# release asset set.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  # Queue (don't cancel) subsequent runs so each tag's release assets are written
  # atomically by a single workflow run.
  cancel-in-progress: false

jobs:
  conflict-marker-guard:
    name: "Guard: no merge conflict markers"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh

  validate-version:
    name: Validate desktop version matches tag
    needs: conflict-marker-guard
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check desktop version matches release tag
        run: node scripts/check-desktop-version.mjs "${{ github.ref_name }}"

  build:
    name: Build (${{ matrix.platform }})
    needs: validate-version
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-24.04, windows-latest]

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate Tauri updater config
        run: node scripts/check-updater-config.mjs

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install macOS Rust targets (universal build)
        if: matrix.platform == 'macos-latest'
        run: rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Use shared Cargo home for CI caching (Unix)
        if: matrix.platform != 'windows-latest'
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-24.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            rpm

          # `appimagetool` is distributed as an AppImage and requires the FUSE 2 runtime.
          # Ubuntu 24.04 uses `libfuse2t64` as part of the time_t 64-bit transition.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64

      - name: Install JS dependencies
        run: pnpm install --frozen-lockfile

      - name: Install wasm-pack (required for @formula/engine WASM build)
        run: cargo install wasm-pack --locked

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        run: pnpm -C apps/desktop check:coi

      - name: Build and upload release assets (macOS universal)
        if: matrix.platform == 'macos-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

          # Optional platform code signing (see docs/release.md)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        with:
          projectPath: apps/desktop
          args: --target universal-apple-darwin
          tagName: ${{ github.ref_name }}
          releaseName: Formula ${{ github.ref_name }}
          releaseBody: |
            Automated build for ${{ github.ref_name }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          prerelease: false

      - name: Build and upload release assets
        if: matrix.platform != 'macos-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Tauri updater signing (required for auto-update; see docs/release.md)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

          # Optional platform code signing (see docs/release.md)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        with:
          projectPath: apps/desktop
          tagName: ${{ github.ref_name }}
          releaseName: Formula ${{ github.ref_name }}
          releaseBody: |
            Automated build for ${{ github.ref_name }}.
            See the assets below for the installers/bundles.
          releaseDraft: true
          prerelease: false
          # Explicitly build all required Linux artifact types. We keep `bundle.targets: "all"`
          # in `tauri.conf.json`, but some formats can be skipped if system tooling is missing.
          # This forces the bundler to attempt each required output so the post-build check can
          # catch regressions early.
          args: ${{ matrix.platform == 'ubuntu-24.04' && '--bundles appimage,deb,rpm' || '' }}

      - name: Verify Linux release artifacts (AppImage + deb + rpm + signatures)
        if: matrix.platform == 'ubuntu-24.04'
        shell: bash
        run: |
          set -euo pipefail

          bundle_dir="apps/desktop/src-tauri/target/release/bundle"
          if [[ ! -d "$bundle_dir" ]]; then
            echo "Expected bundle output directory not found: $bundle_dir" >&2
            exit 1
          fi

          shopt -s nullglob
          appimages=("$bundle_dir/appimage"/*.AppImage)
          debs=("$bundle_dir/deb"/*.deb)
          rpms=("$bundle_dir/rpm"/*.rpm)

          echo "Bundle outputs:"
          printf '  AppImage: %s\n' "${#appimages[@]}"
          printf '  deb:      %s\n' "${#debs[@]}"
          printf '  rpm:      %s\n' "${#rpms[@]}"

          if ((${#appimages[@]} == 0)); then
            echo "Missing required Linux artifact: .AppImage" >&2
            exit 1
          fi
          if ((${#debs[@]} == 0)); then
            echo "Missing required Linux artifact: .deb" >&2
            exit 1
          fi
          if ((${#rpms[@]} == 0)); then
            echo "Missing required Linux artifact: .rpm" >&2
            exit 1
          fi

          # Ensure updater signature files exist for each bundle type.
          for artifact in "${appimages[@]}" "${debs[@]}" "${rpms[@]}"; do
            if [[ ! -f "${artifact}.sig" ]]; then
              echo "Missing signature file for ${artifact} (expected ${artifact}.sig)" >&2
              exit 1
            fi
          done

      - name: Verify macOS universal binary (lipo)
        if: matrix.platform == 'macos-latest'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          # Prefer the universal target output when present (Tauri's universal build writes
          # to `target/universal-apple-darwin/...`). Fall back to searching the entire
          # target dir so we fail loudly with useful debugging output if layouts change.
          candidates=(
            apps/desktop/src-tauri/target/universal-apple-darwin/release/bundle/macos/Formula.app/Contents/MacOS/formula-desktop
          )

          bin_path=""
          for candidate in "${candidates[@]}"; do
            if [[ -f "$candidate" ]]; then
              bin_path="$candidate"
              break
            fi
          done

          if [[ -z "$bin_path" ]]; then
            bin_path="$(find apps/desktop/src-tauri/target -type f -path "*/universal-apple-darwin/*/Formula.app/Contents/MacOS/formula-desktop" | head -n 1 || true)"
          fi

          if [[ -z "$bin_path" ]]; then
            bin_path="$(find apps/desktop/src-tauri/target -type f -path "*Formula.app/Contents/MacOS/formula-desktop" | head -n 1 || true)"
          fi

          if [[ -z "$bin_path" ]]; then
            echo "::error::Could not find packaged macOS app binary (expected **/Formula.app/Contents/MacOS/formula-desktop)"
            echo "Searched under: apps/desktop/src-tauri/target"
            echo "Formula.app bundles found:"
            find apps/desktop/src-tauri/target -type d -name "Formula.app" -print || true
            exit 1
          fi

          echo "Found packaged app binary: $bin_path"
          info="$(lipo -info "$bin_path" | tee /dev/stderr)"

          echo "$info" | grep -q "x86_64" || { echo "::error::macOS binary is missing x86_64 slice"; exit 1; }
          echo "$info" | grep -q "arm64" || { echo "::error::macOS binary is missing arm64 slice"; exit 1; }

      - name: Verify Windows installers are Authenticode-signed
        if: runner.os == 'Windows' && secrets.WINDOWS_CERTIFICATE != '' && secrets.WINDOWS_CERTIFICATE_PASSWORD != ''
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Tauri Windows bundles are emitted under src-tauri/target/**/release/bundle/**.
          # We only enforce signature validity when Windows signing secrets are present
          # so forks/dry runs (which cannot access secrets) skip this check cleanly.
          $searchRoot = "apps/desktop/src-tauri/target"
          if (-not (Test-Path $searchRoot)) {
            Write-Error "Expected build output directory not found: $searchRoot"
          }

          $installers = Get-ChildItem -Path $searchRoot -Recurse -File -Include *.exe, *.msi |
            Where-Object { $_.FullName -match '[\\/]release[\\/]bundle[\\/]' }

          if ($installers.Count -eq 0) {
            Write-Error "No Windows installers (.exe/.msi) found under target/**/release/bundle/**"
          }

          $failed = $false
          foreach ($file in $installers) {
            Write-Host "Checking Authenticode signature: $($file.FullName)"
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -ne 'Valid') {
              Write-Host ($sig | Format-List | Out-String)
              Write-Error "Authenticode signature is not valid for $($file.FullName): Status=$($sig.Status) $($sig.StatusMessage)"
              $failed = $true
            }
          }

          if ($failed) {
            exit 1
          }

      - name: Validate macOS notarization + stapling (Gatekeeper)
        if: ${{ matrix.platform == 'macos-latest' && secrets.APPLE_ID != '' && secrets.APPLE_PASSWORD != '' && secrets.APPLE_TEAM_ID != '' }}
        working-directory: apps/desktop/src-tauri
        shell: bash
        run: |
          set -euo pipefail

          echo "Validating macOS release artifacts are notarized and stapled (Gatekeeper-ready)."
          echo "Search root: $(pwd)"

          if [[ ! -d target ]]; then
            echo "::error::Expected build output directory 'apps/desktop/src-tauri/target' does not exist."
            exit 1
          fi

          # Tauri bundler outputs (examples):
          # - target/release/bundle/dmg/*.dmg
          # - target/release/bundle/macos/*.app
          # - target/<triple>/release/bundle/... (when building for non-host targets)
          mapfile -t dmgs < <(find target -type f -path "*/release/bundle/*/*.dmg" -print | sort)
          mapfile -t apps < <(find target -type d -path "*/release/bundle/*/*.app" -print | sort)

          if [[ ${#dmgs[@]} -eq 0 && ${#apps[@]} -eq 0 ]]; then
            echo "::error::No macOS bundle artifacts (.dmg or .app) were found under target/**/release/bundle/**."
            echo "This step runs only when APPLE_* notarization secrets are configured, and is meant to"
            echo "guarantee tagged releases produce Gatekeeper-ready artifacts (notarized + stapled)."
            echo
            echo "Expected output paths include:"
            echo "  apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg"
            echo "  apps/desktop/src-tauri/target/release/bundle/macos/*.app"
            exit 1
          fi

          echo "Found artifacts:"
          if [[ ${#dmgs[@]} -gt 0 ]]; then
            printf '  - %s\n' "${dmgs[@]}"
          fi
          if [[ ${#apps[@]} -gt 0 ]]; then
            printf '  - %s\n' "${apps[@]}"
          fi

          fail=0

          validate_dmg() {
            local dmg="$1"
            echo "::group::Validate notarization for DMG: $dmg"

            # Requires the DMG to have a stapled ticket for offline Gatekeeper validation.
            if ! xcrun stapler validate "$dmg"; then
              echo "::error::DMG is not stapled (missing notarization ticket): $dmg"
              fail=1
            fi

            # Gatekeeper assessment for disk images.
            if ! spctl -a -vv --type open "$dmg"; then
              echo "::error::Gatekeeper rejected DMG (not notarized?): $dmg"
              fail=1
            fi

            echo "::endgroup::"
          }

          validate_app() {
            local app="$1"
            echo "::group::Validate notarization for app: $app"

            if ! xcrun stapler validate "$app"; then
              echo "::error::App bundle is not stapled (missing notarization ticket): $app"
              fail=1
            fi

            # Gatekeeper assessment for executables / app bundles.
            if ! spctl -a -vv --type execute "$app"; then
              echo "::error::Gatekeeper rejected app bundle (not notarized?): $app"
              fail=1
            fi

            echo "::endgroup::"
          }

          for dmg in "${dmgs[@]}"; do
            validate_dmg "$dmg"
          done

          for app in "${apps[@]}"; do
            validate_app "$app"
          done

          # Some setups only publish a DMG; if no standalone .app bundle is present, validate the
          # app inside the DMG as well.
          if [[ ${#apps[@]} -eq 0 && ${#dmgs[@]} -gt 0 ]]; then
            dmg="${dmgs[0]}"
            mount_dir="$(mktemp -d)"
            echo "::group::No standalone .app found; validating the .app inside DMG: $dmg"

            if hdiutil attach "$dmg" -nobrowse -readonly -mountpoint "$mount_dir" >/dev/null; then
              mapfile -t mounted_apps < <(find "$mount_dir" -maxdepth 2 -type d -name "*.app" -print | sort)
              if [[ ${#mounted_apps[@]} -eq 0 ]]; then
                echo "::error::Mounted DMG but did not find a .app bundle inside: $dmg"
                fail=1
              else
                for app in "${mounted_apps[@]}"; do
                  validate_app "$app"
                done
              fi
              hdiutil detach "$mount_dir" >/dev/null || hdiutil detach "$mount_dir" -force >/dev/null || true
            else
              echo "::error::Failed to mount DMG for validation: $dmg"
              fail=1
            fi

            rm -rf "$mount_dir" || true
            echo "::endgroup::"
          fi

          if [[ "$fail" -ne 0 ]]; then
            echo "::error::macOS notarization/stapling validation failed."
            echo "The release build produced artifacts, but at least one was rejected by Gatekeeper or"
            echo "missing a stapled notarization ticket."
            echo
            echo "Troubleshooting:"
            echo "  - Confirm APPLE_ID / APPLE_PASSWORD / APPLE_TEAM_ID (and signing cert/identity) are configured."
            echo "  - Check the tauri-action logs for notarization/stapling output."
            exit 1
          fi

          echo "macOS notarization/stapling validation passed."

      - name: Report desktop bundle sizes
        env:
          # Optional: set these as GitHub Actions "Variables" to enable gating.
          # - FORMULA_ENFORCE_BUNDLE_SIZE=1 to fail when any artifact exceeds the limit
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        run: python scripts/desktop_bundle_size_report.py

  validate-updater-manifest:
    name: Validate combined updater manifest (latest.json)
    needs: build
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate updater manifest assets + targets
        env:
          # gh respects GH_TOKEN (recommended) and GITHUB_TOKEN. We set both so the validator can
          # use the GitHub API directly and via gh for downloading draft release assets.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node scripts/ci/validate-updater-manifest.mjs "${{ github.ref_name }}"
