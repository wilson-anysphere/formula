name: Desktop Release (dry run)

# NOTE: Third-party GitHub Actions are pinned to immutable commit SHAs for
# supply-chain hardening. To update, pick the desired upstream tag (same major
# version), resolve it to a commit with `git ls-remote <repo> <tag> <tag>^{}`,
# then replace the SHA below and update the trailing comment.

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref (branch/tag/SHA) to build (optional; defaults to the workflow ref)"
        required: false
        default: ""
        type: string
      enableSigning:
        description: "Enable updater + platform signing (uses repository secrets)"
        required: false
        default: false
        type: boolean

# This workflow builds the same desktop bundles as the release pipeline, but:
# - does NOT create/update a GitHub Release
# - uploads bundles to Actions artifacts for inspection
permissions:
  contents: read

env:
  # Keep release builds on the same Node.js major as CI (see ci.yml) to avoid
  # "works in CI, breaks in release" drift.
  NODE_VERSION: 22
  # Pin the pnpm patch version for deterministic builds.
  # Keep this in sync with the root package.json `packageManager` field.
  PNPM_VERSION: 9.0.0
  # Pin wasm-pack for reproducible bundling.
  WASM_PACK_VERSION: 0.13.1
  # Pin the Tauri CLI (`cargo tauri`) version used by bundling.
  TAURI_CLI_VERSION: "2.9.5"
  # Opt-in: bundle Pyodide assets into `apps/desktop/dist` (otherwise Pyodide is downloaded
  # on-demand at runtime and cached in the app data directory).
  FORMULA_BUNDLE_PYODIDE_ASSETS: ${{ vars.FORMULA_BUNDLE_PYODIDE_ASSETS }}

jobs:
  conflict-marker-guard:
    name: "Guard: repo sanity checks"
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh

      - name: "Guard: Rust toolchain pins match rust-toolchain.toml"
        run: bash scripts/ci/check-rust-toolchain-pins.sh

      - name: "Guard: Node version pins match CI workflow"
        run: bash scripts/ci/check-node-version-pins.sh

      - name: "Guard: pnpm version pins match package.json + CI workflow"
        run: bash scripts/ci/check-pnpm-version-pins.sh

      - name: "Guard: wasm-pack version pins match CI workflow"
        run: bash scripts/ci/check-wasm-pack-version-pins.sh

      - name: "Guard: Tauri CLI version pins match CI workflow"
        run: bash scripts/ci/check-tauri-cli-version-pins.sh

  preflight:
    name: Preflight validations
    needs: conflict-marker-guard
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check pinned Tauri CLI version matches Tauri crates
        run: node scripts/ci/check-tauri-cli-version.mjs

      - name: Validate desktop compliance artifact bundling config (LICENSE/NOTICE)
        run: node scripts/ci/check-desktop-compliance-artifacts.mjs

      # Optional: only runs when a tag-like ref is explicitly requested.
      - name: Check desktop version matches tag (optional)
        if: ${{ inputs.ref != '' && (startsWith(inputs.ref, 'v') || startsWith(inputs.ref, 'refs/tags/v')) }}
        run: node scripts/check-desktop-version.mjs "${{ inputs.ref }}"

      - name: Validate Tauri updater config
        run: node scripts/check-updater-config.mjs

      - name: Validate Windows WebView2 installer configuration
        run: node scripts/ci/check-webview2-install-mode.mjs

      - name: Validate Windows Authenticode timestamp URL (HTTPS)
        run: node scripts/ci/check-windows-timestamp-url.mjs

      - name: Validate Windows downgrade / rollback support (allowDowngrades)
        run: node scripts/ci/check-windows-allow-downgrades.mjs

      - name: Validate Tauri updater signing secrets (optional)
        if: inputs.enableSigning == 'true'
        run: node scripts/check-updater-signing-secrets.mjs
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@e97e2d8cc328f1b50210efc529dca0028893a2d9 # v1
        with:
          toolchain: 1.92.0

      - name: Cache Rust (cargo registry + git) (preflight)
        # Cache restores can fail due to transient GitHub issues or permission settings.
        # Lockfile validation should still run (just slower), so treat caching as best-effort.
        continue-on-error: true
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2
        with:
          cache-targets: "false"
          cache-bin: "false"
          cache-on-failure: "true"

      - name: Check Cargo.lock is up-to-date (no implicit lockfile updates)
        shell: bash
        run: bash scripts/ci/check-cargo-lock-reproducible.sh

      - name: Fail if preflight modified tracked files
        run: git diff --exit-code

  build:
    name: Build (${{ matrix.label }})
    needs: preflight
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-14
            label: macos-14 (universal)
            cache_target: universal-apple-darwin
            cache_features: desktop
            rust_target: ""
            tauri_args: "--target universal-apple-darwin"
          - platform: ubuntu-24.04
            label: ubuntu-24.04 (x64)
            cache_target: x86_64-unknown-linux-gnu
            cache_features: desktop
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: ubuntu-24.04-arm64
            label: ubuntu-24.04 (arm64)
            cache_target: aarch64-unknown-linux-gnu
            cache_features: desktop
            rust_target: ""
            tauri_args: "--bundles appimage,deb,rpm"
          - platform: windows-2022
            label: windows-2022 (x64)
            cache_target: x86_64-pc-windows-msvc
            cache_features: desktop
            rust_target: x86_64-pc-windows-msvc
            tauri_args: "--target x86_64-pc-windows-msvc --bundles msi,nsis"
          - platform: windows-2022
            label: windows-2022 (arm64)
            cache_target: aarch64-pc-windows-msvc
            cache_features: desktop
            rust_target: aarch64-pc-windows-msvc
            tauri_args: "--target aarch64-pc-windows-msvc --bundles msi,nsis"

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          ref: ${{ inputs.ref || github.ref }}

      # Ensure all Cargo builds (including `cargo tauri build`) emit artifacts under the
      # expected path `apps/desktop/src-tauri/target/**`. This keeps validation deterministic.
      - name: Set CARGO_TARGET_DIR for desktop builds (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $targetDir = Join-Path $env:GITHUB_WORKSPACE 'apps/desktop/src-tauri/target'
          "CARGO_TARGET_DIR=$targetDir" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Set CARGO_TARGET_DIR for desktop builds (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: echo "CARGO_TARGET_DIR=$GITHUB_WORKSPACE/apps/desktop/src-tauri/target" >> "$GITHUB_ENV"

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Validate macOS entitlements (hardened runtime)
        if: runner.os == 'macOS'
        run: node scripts/check-macos-entitlements.mjs

      # Code signing is optional and frequently unavailable in forks/dry-runs (no repo secrets).
      # When signing is disabled, patch `tauri.conf.json` so unsigned bundles can still be built.
      - name: Prepare optional Tauri signing config (macOS/Windows, signing disabled)
        if: inputs.enableSigning != 'true'
        run: node scripts/ci/prepare-tauri-signing-config.mjs
        env:
          FORMULA_REQUIRE_CODESIGN: "0"

      - name: Prepare optional Tauri signing config (macOS/Windows, signing enabled)
        if: inputs.enableSigning == 'true'
        run: node scripts/ci/prepare-tauri-signing-config.mjs
        env:
          # Optional: set as a GitHub Actions "Variable" to enforce platform code signing.
          # - FORMULA_REQUIRE_CODESIGN=1 to fail when required signing secrets are missing
          FORMULA_REQUIRE_CODESIGN: ${{ vars.FORMULA_REQUIRE_CODESIGN }}

          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

          # Optional: Tauri updater signing secrets. Forks/dry-runs often do not configure these,
          # so the helper only exports them to subsequent steps when non-empty.
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@e97e2d8cc328f1b50210efc529dca0028893a2d9 # v1
        with:
          toolchain: 1.92.0

      - name: Install Rust targets (WASM)
        run: rustup target add wasm32-unknown-unknown

      - name: Install macOS Rust targets (universal build)
        if: runner.os == 'macOS'
        run: rustup target add x86_64-apple-darwin aarch64-apple-darwin

      - name: Install Rust target (${{ matrix.rust_target }})
        if: matrix.rust_target != ''
        run: rustup target add ${{ matrix.rust_target }}

      - name: Ensure MSVC ARM64 build tools are installed (Windows ARM64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (!(Test-Path $vswhere)) {
            throw "vswhere not found at $vswhere (expected on GitHub-hosted Windows runners)."
          }
          $installPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (!$installPath) {
            throw "Failed to locate a Visual Studio installation via vswhere."
          }
          Write-Host "Visual Studio install path: $installPath"
          $msvcRoot = Join-Path $installPath "VC\Tools\MSVC"
          $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (!$msvcVersionDir) {
            throw "MSVC toolset directory not found under $msvcRoot"
          }
          $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
          $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
          $arm64Cl = Join-Path $arm64BinDir "cl.exe"
          $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          $hasArm64Toolchain = (Test-Path $arm64LibDir) -and (Test-Path $arm64Cl) -and (Test-Path $arm64LinkExe)

          if (-not $hasArm64Toolchain) {
            Write-Host "MSVC ARM64 toolchain not found; installing Visual Studio component Microsoft.VisualStudio.Component.VC.Tools.ARM64"
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            & $vsInstaller modify --installPath $installPath --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --includeRecommended --passive --norestart
            $exitCode = $LASTEXITCODE
            # 3010 is a common "success, reboot required" code for Windows installers.
            if ($exitCode -ne 0 -and $exitCode -ne 3010) {
              throw "vs_installer.exe failed with exit code $exitCode while installing MSVC ARM64 components."
            }

            $msvcVersionDir = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            $arm64LibDir = Join-Path $msvcVersionDir.FullName "lib\arm64"
            $arm64BinDir = Join-Path $msvcVersionDir.FullName "bin\Hostx64\arm64"
            $arm64Cl = Join-Path $arm64BinDir "cl.exe"
            $arm64LinkExe = Join-Path $arm64BinDir "link.exe"
          }

          if (!(Test-Path $arm64LibDir) -or !(Test-Path $arm64Cl) -or !(Test-Path $arm64LinkExe)) {
            throw "MSVC ARM64 build tools were not found. Expected:`n  - $arm64LibDir`n  - $arm64Cl`n  - $arm64LinkExe`nWindows ARM64 builds require the MSVC ARM64 toolchain to be present on the runner."
          }

          Write-Host "MSVC ARM64 tools present:"
          Write-Host "  - libs: $arm64LibDir"
          Write-Host "  - cl.exe: $arm64Cl"
          Write-Host "  - link.exe: $arm64LinkExe"

          $sdkLibRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\Lib"
          if (!(Test-Path $sdkLibRoot)) {
            throw "Windows SDK lib root not found at $sdkLibRoot. Windows ARM64 builds require the Windows 10/11 SDK with ARM64 libraries."
          }

          function Find-SdkArm64($root) {
            $dirs = @(Get-ChildItem -Path $root -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending)
            foreach ($dir in $dirs) {
              $um = Join-Path $dir.FullName "um\arm64"
              $ucrt = Join-Path $dir.FullName "ucrt\arm64"
              if ((Test-Path $um) -and (Test-Path $ucrt)) {
                return [pscustomobject]@{ VersionDir = $dir; Um = $um; Ucrt = $ucrt; AllDirs = $dirs }
              }
            }
            return [pscustomobject]@{ VersionDir = $null; Um = $null; Ucrt = $null; AllDirs = $dirs }
          }

          $sdkInfo = Find-SdkArm64 $sdkLibRoot
          if (-not $sdkInfo.AllDirs -or $sdkInfo.AllDirs.Count -eq 0) {
            throw "No Windows SDK lib versions found under $sdkLibRoot. Windows ARM64 builds require a Windows SDK installation with ARM64 libraries."
          }

          if (-not $sdkInfo.VersionDir) {
            # Some runner images can have the Windows SDK installed without the ARM64 lib subset.
            # Attempt to add the matching Windows 10 SDK component via the Visual Studio installer.
            $candidateName = $sdkInfo.AllDirs[0].Name
            $sdkBuild = $null
            if ($candidateName -match '^10\.0\.(\d+)\.\d+$') {
              $sdkBuild = $Matches[1]
            }
            if (-not $sdkBuild) {
              # Reasonable fallback for windows-2022 images (10.0.20348.0).
              $sdkBuild = "20348"
            }

            $sdkComponents = @(
              "Microsoft.VisualStudio.Component.Windows10SDK.$sdkBuild",
              "Microsoft.VisualStudio.Component.Windows11SDK.$sdkBuild"
            ) | Select-Object -Unique
            Write-Host "Windows SDK ARM64 libs not found; attempting to install one of:"
            $sdkComponents | ForEach-Object { Write-Host "  - $_" }
            $vsInstaller = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vs_installer.exe"
            if (!(Test-Path $vsInstaller)) {
              throw "Visual Studio installer not found at $vsInstaller"
            }
            $installErrors = @()
            foreach ($sdkComponent in $sdkComponents) {
              Write-Host "Installing Windows SDK component: $sdkComponent"
              & $vsInstaller modify --installPath $installPath --add $sdkComponent --includeRecommended --passive --norestart
              $exitCode = $LASTEXITCODE
              # 3010 is a common "success, reboot required" code for Windows installers.
              if ($exitCode -ne 0 -and $exitCode -ne 3010) {
                $installErrors += "$sdkComponent (exit code $exitCode)"
                continue
              }
              $sdkInfo = Find-SdkArm64 $sdkLibRoot
              if ($sdkInfo.VersionDir) {
                break
              }
            }

            if (-not $sdkInfo.VersionDir -and $installErrors.Count -gt 0) {
              Write-Host "Windows SDK component install attempts failed:"
              $installErrors | ForEach-Object { Write-Host "  - $_" }
            }
          }

          if (-not $sdkInfo.VersionDir) {
            throw "Windows SDK ARM64 UM/UCRT libraries were not found under $sdkLibRoot. The runner image may be missing the Windows SDK ARM64 components."
          }

          $sdkVersionDir = $sdkInfo.VersionDir
          $sdkUmArm64 = $sdkInfo.Um
          $sdkUcrtArm64 = $sdkInfo.Ucrt

          Write-Host "windows-arm64-toolchain: OK"
          Write-Host " - MSVC: $($msvcVersionDir.FullName)"
          Write-Host " - link.exe: $arm64LinkExe"
          Write-Host " - MSVC lib: $arm64LibDir"
          Write-Host " - SDK um/arm64: $sdkUmArm64"
          Write-Host " - SDK ucrt/arm64: $sdkUcrtArm64"

      - name: Setup Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
        with:
          python-version: "3.11"

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent contention on shared ~/.cargo.
      # In GitHub Actions we prefer the default CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $cargoHome = Join-Path $env:USERPROFILE ".cargo"
          "CARGO_HOME=$cargoHome" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Use shared Cargo home for CI caching (Unix)
        if: runner.os != 'Windows'
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Install WiX Toolset (required for MSI builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's MSI bundler requires WiX (candle.exe/light.exe) to be on PATH.
          # GitHub runners don't consistently have it available, and Tauri may skip
          # MSI generation without failing. Install WiX deterministically.
          $candle = Get-Command candle.exe -ErrorAction SilentlyContinue
          $light = Get-Command light.exe -ErrorAction SilentlyContinue
          if (-not $candle -or -not $light) {
            choco install wixtoolset --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            # (Chocolatey may update PATH via the registry; refreshenv reloads it.)
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          # Add common WiX install locations to PATH for subsequent steps.
          $wixRoots = Get-ChildItem -Path (Join-Path ${env:ProgramFiles(x86)} "WiX Toolset v*") -Directory -ErrorAction SilentlyContinue
          foreach ($root in $wixRoots) {
            $bin = Join-Path $root.FullName "bin"
            if (Test-Path $bin) {
              $env:PATH = "$bin;$env:PATH"
              $bin | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
            }
          }

          if (-not (Get-Command candle.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: candle.exe not found on PATH."
          }
          if (-not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            throw "WiX Toolset installation failed: light.exe not found on PATH."
          }

      - name: Install NSIS (required for EXE builds)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Tauri's NSIS bundler requires makensis.exe. If it's missing, Tauri may
          # skip EXE generation without failing the overall build. Install NSIS
          # deterministically so Windows bundles always include both `.exe` and `.msi`.
          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            choco install nsis --yes --no-progress

            # Ensure the newly-installed tools are visible in the current step.
            if (Test-Path "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1") {
              Import-Module "$env:ChocolateyInstall\\helpers\\chocolateyProfile.psm1"
              refreshenv
            }
          }

          if (-not (Get-Command makensis.exe -ErrorAction SilentlyContinue)) {
            throw "NSIS installation failed: makensis.exe not found on PATH."
          }

      - name: Cache Rust (cargo registry + git)
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2
        with:
          # We cache build artifacts separately (see "Cache cargo target") to keep cache sizes
          # bounded. rust-cache still provides fast restores for the Cargo registry/git index.
          cache-targets: "false"

      - name: Cache cargo target (release build artifacts)
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: |
            # Avoid recursive `target/**/...` patterns here: Cargo target directories can be large,
            # and GitHub Actions globbing will traverse the tree to find matches. The release output
            # layout is predictable:
            #   - target/release/<dir>
            #   - target/<triple>/release/<dir>
            target/release/deps
            target/*/release/deps
            target/release/build
            target/*/release/build
            target/release/.fingerprint
            target/*/release/.fingerprint
            target/release/incremental
            target/*/release/incremental
            target/release/wbuild
            target/*/release/wbuild
            target/.rustc_info.json
            target/*/.rustc_info.json
            apps/desktop/src-tauri/target/release/deps
            apps/desktop/src-tauri/target/*/release/deps
            apps/desktop/src-tauri/target/release/build
            apps/desktop/src-tauri/target/*/release/build
            apps/desktop/src-tauri/target/release/.fingerprint
            apps/desktop/src-tauri/target/*/release/.fingerprint
            apps/desktop/src-tauri/target/release/incremental
            apps/desktop/src-tauri/target/*/release/incremental
            apps/desktop/src-tauri/target/release/wbuild
            apps/desktop/src-tauri/target/*/release/wbuild
            apps/desktop/src-tauri/target/.rustc_info.json
            apps/desktop/src-tauri/target/*/.rustc_info.json
          # Keep these caches isolated per Rust target triple + runner arch so cross-compile jobs
          # don't thrash/overwrite caches or restore host build-script binaries from an incompatible
          # runner architecture. Include the Rust toolchain pin so caches don't leak across upgrades.
          key: cargo-target-desktop-dry-run-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            cargo-target-desktop-dry-run-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ matrix.cache_features }}-${{ hashFiles('rust-toolchain.toml') }}-
            cargo-target-desktop-dry-run-${{ runner.os }}-${{ runner.arch }}-${{ matrix.cache_target }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            file \
            binutils \
            cpio \
            xvfb \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            squashfs-tools \
            fakeroot \
            rpm \
            rpm2cpio

          # AppImage-based tooling (including `appimagetool`) supports "extract and run" mode.
          # Prefer it in CI to reduce reliance on a working FUSE setup.
          echo "APPIMAGE_EXTRACT_AND_RUN=1" >> "${GITHUB_ENV}"

          # `appimagetool` is distributed as an AppImage and may require the FUSE 2 runtime on some hosts.
          # Ubuntu 24.04 uses `libfuse2t64` as part of the time_t 64-bit transition.
          #
          # Best-effort install: extract-and-run mode means the build can proceed without FUSE.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64 || true

      - name: Install JS dependencies
        # Prefer cached pnpm store entries to reduce network flakiness on reruns.
        env:
          # Release builds don't run Playwright tests, so skip the ~GB browser downloads
          # performed by `@playwright/test`'s postinstall script.
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
        run: pnpm install --frozen-lockfile --prefer-offline

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/.cargo/bin/wasm-pack*
          # Include the Rust toolchain pin so Rust upgrades force rebuilding the cached binary.
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Cache wasm-pack tool downloads (Linux)
        if: runner.os == 'Linux'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          # wasm-pack downloads wasm-bindgen + binaryen (wasm-opt) into this cache dir.
          path: ~/.cache/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache wasm-pack tool downloads (macOS)
        if: runner.os == 'macOS'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/Library/Caches/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache wasm-pack tool downloads (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ${{ env.LOCALAPPDATA }}/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        # Use --force so cache restore-keys (or other CI caches) can't strand a stale/untracked
        # wasm-pack binary that would otherwise block `cargo install` from overwriting it.
        run: cargo install wasm-pack --version ${{ env.WASM_PACK_VERSION }} --locked --force

      - name: Verify wasm-pack version
        shell: bash
        run: |
          set -euo pipefail
          expected="${WASM_PACK_VERSION}"
          actual="$(wasm-pack --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected wasm-pack ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache pinned Tauri CLI binary (cargo-tauri)
        id: tauri-cli-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/.cargo/bin/cargo-tauri*
          key: cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install pinned Tauri CLI (cargo tauri)
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ${{ env.TAURI_CLI_VERSION }} --locked --force

      - name: Verify Tauri CLI version
        shell: bash
        run: |
          set -euo pipefail
          expected="${TAURI_CLI_VERSION}"
          actual="$(cargo tauri --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected cargo-tauri ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache Tauri tooling downloads (Linux)
        if: runner.os == 'Linux'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/.cache/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (macOS)
        if: runner.os == 'macOS'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: ~/Library/Caches/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Cache Tauri tooling downloads (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          # Tauri's cache directory lives under %LOCALAPPDATA% on Windows.
          path: ${{ env.LOCALAPPDATA }}/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Validate Tauri capability permission identifiers
        if: runner.os == 'Linux'
        run: node scripts/check-tauri-permissions.mjs

      - name: Detect Pyodide version (for caching)
        id: pyodide
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        shell: bash
        run: |
          set -euo pipefail
          version="$(node -e "const fs=require('node:fs'); const src=fs.readFileSync('apps/desktop/scripts/ensure-pyodide-assets.mjs','utf8'); const m=src.match(/const\\s+PYODIDE_VERSION\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/); if(!m) throw new Error('PYODIDE_VERSION not found'); process.stdout.write(m[1]);")"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Restore Pyodide asset cache
        id: pyodide-cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        uses: actions/cache/restore@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Ensure Pyodide assets are present
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        run: node apps/desktop/scripts/ensure-pyodide-assets.mjs

      - name: Save Pyodide asset cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1' && steps.pyodide-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v5.0.2
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Setup MSVC cross-compilation environment (amd64 â†’ arm64)
        # Only needed for the Windows ARM64 bundle job; set it immediately before the Tauri build so
        # earlier host-target `cargo install` steps (wasm-pack, tauri-cli) run in the default x64 environment.
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        uses: ilammy/msvc-dev-cmd@0b201ec74fa43914dc39ae48a89fd1d8cb592756 # v1.13.0
        with:
          arch: amd64_arm64

      - name: Build desktop bundles (dry run)
        uses: tauri-apps/tauri-action@73fb865345c54760d875b94642314f8c0c894afa # v0.6.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: apps/desktop
          # Use the Cargo-installed Tauri CLI (`cargo tauri`) instead of letting the
          # action install a floating `@tauri-apps/cli@v2` toolchain.
          tauriScript: cargo tauri
          args: ${{ matrix.tauri_args }}

      - name: Verify desktop binary is stripped (no symbols)
        run: python scripts/verify_desktop_binary_stripped.py

      - name: Smoke check packaged cross-origin isolation (COOP/COEP)
        # Run against the already-built Tauri artifacts from the previous step.
        # Skip Windows ARM64 cross-compile builds (the produced binary isn't runnable on x64 runners).
        if: >-
          (runner.os == 'Linux' || !contains(fromJson('["0","false","False","FALSE"]'), vars.FORMULA_COI_CHECK_ALL_PLATFORMS))
          && (runner.os != 'Windows' || matrix.rust_target != 'aarch64-pc-windows-msvc')
        run: pnpm -C apps/desktop check:coi -- --no-build

      - name: Desktop dist asset report
        if: runner.os != 'macOS'
        run: node scripts/desktop_dist_asset_report.mjs --json-out desktop-dist-assets-report.json
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Upload desktop dist asset report (JSON)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: desktop-dist-assets-report-dry-run-${{ matrix.cache_target }}
          path: desktop-dist-assets-report.json
          if-no-files-found: ignore

      - name: Validate macOS bundle
        if: runner.os == 'macOS'
        run: bash scripts/validate-macos-bundle.sh

      - name: Verify macOS bundle file associations + deep link schemes
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail

          # Prefer predictable globs over `find` to avoid traversing large Cargo target directories.
          app_path=""
          roots=(apps/desktop/src-tauri/target apps/desktop/target target)
          nullglob_was_set=0
          if shopt -q nullglob; then nullglob_was_set=1; fi
          shopt -s nullglob
          for root in "${roots[@]}"; do
            [[ -d "${root}" ]] || continue
            candidates=(
              "${root}"/release/bundle/macos/*.app
              "${root}"/*/release/bundle/macos/*.app
            )
            if ((${#candidates[@]} > 0)); then
              app_path="${candidates[0]}"
              break
            fi
          done
          if [[ "${nullglob_was_set}" -eq 0 ]]; then shopt -u nullglob; fi

          # Fallback (slower): scan with `find` if the bundle layout is unexpected.
          if [[ -z "${app_path}" ]]; then
            app_path="$(
              find apps/desktop/src-tauri/target apps/desktop/target target \
                -type d \
                -path '*/release/bundle/macos/*.app' \
                -prune \
                -print 2>/dev/null \
                | head -n 1 || true
            )"
          fi
          if [[ -z "$app_path" ]]; then
            echo "::error::Could not find a built .app bundle under expected target roots." >&2
            find apps/desktop/src-tauri/target apps/desktop/target target -maxdepth 12 -type d -name '*.app' -print 2>/dev/null | head -n 20 || true
            exit 1
          fi

          info_plist="${app_path}/Contents/Info.plist"
          if [[ ! -f "${info_plist}" ]]; then
            echo "::error::Missing Info.plist at: ${info_plist}" >&2
            exit 1
          fi

          echo "App bundle: ${app_path}"
          echo "Info.plist: ${info_plist}"
          echo "::group::plutil -p ${info_plist} (first 200 lines)"
          plutil -p "${info_plist}" | head -n 200
          echo "::endgroup::"

          python3 scripts/ci/verify_macos_bundle_associations.py --info-plist "${info_plist}"

      - name: Validate Linux AppImage bundle
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          for script in scripts/validate-linux-appimage.*; do
            echo "Running $script"
            case "$script" in
              *.mjs|*.js) node "$script" ;;
              *.py) python "$script" ;;
              *) bash "$script" ;;
            esac
          done

      - name: Validate Linux RPM bundle
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          for script in scripts/validate-linux-rpm.*; do
            echo "Running $script"
            case "$script" in
              *.mjs|*.js) node "$script" ;;
              *.py) python "$script" ;;
              *) bash "$script" ;;
            esac
          done

      - name: Validate Windows installer bundles (presence + Authenticode + file associations/protocol)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ inputs.enableSigning == 'true' && secrets.WINDOWS_CERTIFICATE || '' }}
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          if ([string]::IsNullOrWhiteSpace($target)) {
            throw "windows-bundle: ERROR matrix.rust_target is empty; expected an explicit Windows target triple."
          }

          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            $candidatesJoined = $bundleCandidates -join "`n"
            throw "windows-bundle: ERROR expected Tauri bundle dir not found. Looked in:`n$candidatesJoined"
          }

          pwsh -NoProfile -ExecutionPolicy Bypass -File ./scripts/validate-windows-bundles.ps1 -BundleDir $bundleDir -RequireExe -RequireMsi

      - name: Verify Windows ARM64 binary architecture (AA64)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $releaseCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release"),
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/target/$target/release"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release")
          )
          $releaseDir = $releaseCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $releaseDir) {
            $candidatesJoined = $releaseCandidates -join "`n"
            throw "windows-arm64: Expected Rust release directory not found. Looked in:`n$candidatesJoined"
          }
          # Avoid scanning the entire Cargo target release directory (can be large in CI). The binary
          # is expected at <releaseDir>/formula-desktop.exe; fall back to a recursive search only if
          # the direct path is missing (defensive against unusual build layouts).
          $exePath = Join-Path $releaseDir "formula-desktop.exe"
          if (Test-Path $exePath) {
            $exe = Get-Item -LiteralPath $exePath
          } else {
            $exe = Get-ChildItem -Path $releaseDir -Recurse -File -Filter "formula-desktop.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          }
          if (-not $exe) {
            throw "windows-arm64: Expected compiled binary formula-desktop.exe not found under: $releaseDir"
          }
          $dumpbin = Get-Command dumpbin.exe -ErrorAction SilentlyContinue
          if (-not $dumpbin) {
            throw "windows-arm64: dumpbin.exe not found on PATH (expected after MSVC dev-cmd setup)."
          }
          $headers = & dumpbin.exe /headers $exe.FullName
          $joined = ($headers -join "`n")
          if ($joined -notmatch '\\bAA64\\b') {
            throw "windows-arm64: Expected ARM64 machine type 'AA64' in dumpbin output for $($exe.FullName), but it was not found."
          }
          if ($joined -match '\\b8664\\b') {
            throw "windows-arm64: Binary appears to be x64 (machine type '8664'), expected ARM64 (AA64)."
          }

      - name: Verify Windows ARM64 MSI targets ARM64 (template summary)
        if: runner.os == 'Windows' && matrix.rust_target == 'aarch64-pc-windows-msvc'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $target = "${{ matrix.rust_target }}"
          $bundleCandidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "apps/desktop/src-tauri/target/$target/release/bundle"),
            (Join-Path $env:GITHUB_WORKSPACE "target/$target/release/bundle")
          )
          $bundleDir = $bundleCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $bundleDir) {
            throw "windows-arm64-msi: ERROR expected Tauri bundle dir not found."
          }
          $msis = @(
            Get-ChildItem -Path (Join-Path $bundleDir "msi") -Recurse -File -Filter "*.msi" -ErrorAction SilentlyContinue
          )
          if ($msis.Count -eq 0) {
            throw "windows-arm64-msi: ERROR no .msi installers found under: $bundleDir"
          }

          $installer = New-Object -ComObject WindowsInstaller.Installer
          foreach ($msi in $msis) {
            $db = $installer.OpenDatabase($msi.FullName, 0)
            $summary = $db.SummaryInformation(0)
            $template = $summary.Property(7)
            Write-Host "windows-arm64-msi: $($msi.Name) template=$template"
            if ($template -notmatch '(?i)arm64') {
              throw "windows-arm64-msi: ERROR Expected MSI Template Summary to include ARM64 for $($msi.FullName), got: $template"
            }
          }

      - name: Verify Windows installers bundle/reference WebView2 (bootstrapper/runtime)
        if: runner.os == 'Windows'
        run: python scripts/ci/check-windows-webview2-installer.py

      - name: Smoke test produced AppImage (extract + ldd + arch)
        if: runner.os == 'Linux'
        run: bash scripts/ci/check-appimage.sh

      - name: Verify Linux .deb package (deps + ldd + desktop integration)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          # Preferred location (matches docs/release.md), but fall back to scanning common Cargo target dirs.
          shopt -s nullglob
          debs=(apps/desktop/src-tauri/target/release/bundle/deb/*.deb)

          if ((${#debs[@]} == 0)); then
            roots=()
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              roots+=("${CARGO_TARGET_DIR}")
            fi
            roots+=("apps/desktop/src-tauri/target" "apps/desktop/target" "target")

            debs=()
            for root in "${roots[@]}"; do
              [[ -d "${root}" ]] || continue
              debs+=("${root}"/release/bundle/deb/*.deb)
              debs+=("${root}"/*/release/bundle/deb/*.deb)
            done
          fi

          if ((${#debs[@]} > 0)); then mapfile -t debs < <(printf '%s\n' "${debs[@]}" | sort -u); fi
          shopt -u nullglob

          if ((${#debs[@]} == 0)); then
            echo "::error::could not find any .deb artifacts under apps/desktop/src-tauri/target/release/bundle/deb or target/release/bundle/deb (or target/*/release/bundle/deb)" >&2
            exit 1
          fi

          for deb in "${debs[@]}"; do
            echo "Using deb: ${deb}"

            echo "::group::dpkg -I ${deb}"
            dpkg -I "${deb}" | tee dpkg-info.txt
            echo "::endgroup::"

            # Ensure key runtime deps are declared (at least: WebKitGTK + GTK + AppIndicator).
            for needle in "webkit2gtk" "libgtk-3" "appindicator"; do
              if ! grep -qi "$needle" dpkg-info.txt; then
                echo "::error::Expected runtime dependency '$needle' missing from dpkg -I output for ${deb}"
                exit 1
              fi
            done

            tmpdir="$(mktemp -d)"
            trap 'rm -rf "${tmpdir}"' EXIT
            dpkg-deb -x "${deb}" "${tmpdir}"

            bin="${tmpdir}/usr/bin/formula-desktop"
            if [[ ! -f "${bin}" ]]; then
              echo "::error::Expected installed binary not found at ${bin} after extracting ${deb}"
              exit 1
            fi

            echo "::group::ldd ${bin}"
            ldd "${bin}" | tee ldd.txt
            echo "::endgroup::"
            if grep -q "not found" ldd.txt; then
              echo "::error::Missing shared library dependencies detected by ldd for ${bin}"
              exit 1
            fi

            # Smoke test the packaged binary quickly under Xvfb.
            echo "::group::Run packaged binary smoke check (--cross-origin-isolation-check)"
            (
              export HOME="${tmpdir}/home"
              export XDG_CONFIG_HOME="${HOME}/.config"
              export XDG_DATA_HOME="${HOME}/.local/share"
              mkdir -p "${XDG_CONFIG_HOME}" "${XDG_DATA_HOME}"
              bash scripts/xvfb-run-safe.sh timeout 45s "${bin}" --cross-origin-isolation-check
            )
            echo "::endgroup::"

            python3 scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir}"

            rm -rf "${tmpdir}"
            trap - EXIT
          done

      - name: Verify Linux .rpm desktop integration (file associations + deep links + compliance)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          # Preferred location (matches docs/release.md), but fall back to scanning common Cargo target dirs.
          shopt -s nullglob
          rpms=(apps/desktop/src-tauri/target/release/bundle/rpm/*.rpm)
 
          if ((${#rpms[@]} == 0)); then
            roots=()
            if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
              roots+=("${CARGO_TARGET_DIR}")
            fi
            roots+=("apps/desktop/src-tauri/target" "apps/desktop/target" "target")
 
            rpms=()
            for root in "${roots[@]}"; do
              [[ -d "${root}" ]] || continue
              rpms+=("${root}"/release/bundle/rpm/*.rpm)
              rpms+=("${root}"/*/release/bundle/rpm/*.rpm)
            done
          fi
 
          if ((${#rpms[@]} > 0)); then mapfile -t rpms < <(printf '%s\n' "${rpms[@]}" | sort -u); fi
          shopt -u nullglob
  
          if ((${#rpms[@]} == 0)); then
            echo "::error::could not find any .rpm artifacts under apps/desktop/src-tauri/target/release/bundle/rpm or target/release/bundle/rpm (or target/*/release/bundle/rpm)" >&2
            exit 1
          fi
 
          for rpm_path in "${rpms[@]}"; do
            echo "Validating rpm: ${rpm_path}"
 
            tmpdir="$(mktemp -d)"
            trap 'rm -rf "${tmpdir}"' EXIT
 
            # Extract the RPM into a synthetic filesystem root so we can inspect its .desktop metadata.
            rpm2cpio "${rpm_path}" | (cd "${tmpdir}" && cpio -idm --quiet --no-absolute-filenames)
            python3 scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir}"
 
            rm -rf "${tmpdir}"
            trap - EXIT
          done

      - name: Verify Linux package dependency metadata (.deb + .rpm)
        if: runner.os == 'Linux'
        run: bash scripts/ci/verify-linux-package-deps.sh

      - name: Report desktop bundle sizes
        if: always()
        env:
          # Optional: set these as GitHub Actions "Variables" to enable gating.
          # - FORMULA_ENFORCE_BUNDLE_SIZE=1 to fail when any artifact exceeds the limit
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        run: python scripts/desktop_bundle_size_report.py

      - name: Restore CI-only Tauri config patches
        shell: bash
        run: |
          set -euo pipefail
          # `scripts/ci/prepare-tauri-signing-config.mjs` may patch `tauri.conf.json` in-place for
          # fork-friendly unsigned builds. Reset it so the reproducibility guard below only fails on
          # unexpected tracked file changes.
          git restore --source=HEAD -- apps/desktop/src-tauri/tauri.conf.json

      - name: Fail if the build modified tracked files
        run: git diff --exit-code

      - name: Upload desktop bundles
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: desktop-bundles-dry-run-${{ matrix.cache_target }}
          if-no-files-found: warn
          path: |
            apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg
            apps/desktop/src-tauri/target/*/release/bundle/dmg/*.dmg
            apps/desktop/src-tauri/target/release/bundle/appimage/*.AppImage
            apps/desktop/src-tauri/target/*/release/bundle/appimage/*.AppImage
            apps/desktop/src-tauri/target/release/bundle/deb/*.deb
            apps/desktop/src-tauri/target/*/release/bundle/deb/*.deb
            apps/desktop/src-tauri/target/release/bundle/rpm/*.rpm
            apps/desktop/src-tauri/target/*/release/bundle/rpm/*.rpm
            apps/desktop/src-tauri/target/release/bundle/msi/*.msi
            apps/desktop/src-tauri/target/*/release/bundle/msi/*.msi
            apps/desktop/src-tauri/target/release/bundle/nsis/*.exe
            apps/desktop/src-tauri/target/*/release/bundle/nsis/*.exe
            apps/desktop/src-tauri/target/release/bundle/nsis-web/*.exe
            apps/desktop/src-tauri/target/*/release/bundle/nsis-web/*.exe
            apps/desktop/src-tauri/target/release/bundle/*/*.pkg
            apps/desktop/src-tauri/target/*/release/bundle/*/*.pkg
            apps/desktop/src-tauri/target/release/bundle/*/*.zip
            apps/desktop/src-tauri/target/*/release/bundle/*/*.zip
            apps/desktop/src-tauri/target/release/bundle/*/*.tar.gz
            apps/desktop/src-tauri/target/*/release/bundle/*/*.tar.gz
            apps/desktop/src-tauri/target/release/bundle/*/*.tgz
            apps/desktop/src-tauri/target/*/release/bundle/*/*.tgz
            apps/desktop/src-tauri/target/release/bundle/*.sig
            apps/desktop/src-tauri/target/*/release/bundle/*.sig
            apps/desktop/src-tauri/target/release/bundle/*/*.sig
            apps/desktop/src-tauri/target/*/release/bundle/*/*.sig
            apps/desktop/src-tauri/target/release/bundle/latest.json
            apps/desktop/src-tauri/target/*/release/bundle/latest.json
            apps/desktop/src-tauri/target/release/bundle/*/latest.json
            apps/desktop/src-tauri/target/*/release/bundle/*/latest.json
            apps/desktop/src-tauri/target/release/bundle/update.json
            apps/desktop/src-tauri/target/*/release/bundle/update.json
            apps/desktop/src-tauri/target/release/bundle/*/update.json
            apps/desktop/src-tauri/target/*/release/bundle/*/update.json
            apps/desktop/target/release/bundle/dmg/*.dmg
            apps/desktop/target/*/release/bundle/dmg/*.dmg
            apps/desktop/target/release/bundle/appimage/*.AppImage
            apps/desktop/target/*/release/bundle/appimage/*.AppImage
            apps/desktop/target/release/bundle/deb/*.deb
            apps/desktop/target/*/release/bundle/deb/*.deb
            apps/desktop/target/release/bundle/rpm/*.rpm
            apps/desktop/target/*/release/bundle/rpm/*.rpm
            apps/desktop/target/release/bundle/msi/*.msi
            apps/desktop/target/*/release/bundle/msi/*.msi
            apps/desktop/target/release/bundle/nsis/*.exe
            apps/desktop/target/*/release/bundle/nsis/*.exe
            apps/desktop/target/release/bundle/nsis-web/*.exe
            apps/desktop/target/*/release/bundle/nsis-web/*.exe
            apps/desktop/target/release/bundle/*/*.pkg
            apps/desktop/target/*/release/bundle/*/*.pkg
            apps/desktop/target/release/bundle/*/*.zip
            apps/desktop/target/*/release/bundle/*/*.zip
            apps/desktop/target/release/bundle/*/*.tar.gz
            apps/desktop/target/*/release/bundle/*/*.tar.gz
            apps/desktop/target/release/bundle/*/*.tgz
            apps/desktop/target/*/release/bundle/*/*.tgz
            apps/desktop/target/release/bundle/*.sig
            apps/desktop/target/*/release/bundle/*.sig
            apps/desktop/target/release/bundle/*/*.sig
            apps/desktop/target/*/release/bundle/*/*.sig
            apps/desktop/target/release/bundle/latest.json
            apps/desktop/target/*/release/bundle/latest.json
            apps/desktop/target/release/bundle/*/latest.json
            apps/desktop/target/*/release/bundle/*/latest.json
            apps/desktop/target/release/bundle/update.json
            apps/desktop/target/*/release/bundle/update.json
            apps/desktop/target/release/bundle/*/update.json
            apps/desktop/target/*/release/bundle/*/update.json
            target/release/bundle/dmg/*.dmg
            target/*/release/bundle/dmg/*.dmg
            target/release/bundle/appimage/*.AppImage
            target/*/release/bundle/appimage/*.AppImage
            target/release/bundle/deb/*.deb
            target/*/release/bundle/deb/*.deb
            target/release/bundle/rpm/*.rpm
            target/*/release/bundle/rpm/*.rpm
            target/release/bundle/msi/*.msi
            target/*/release/bundle/msi/*.msi
            target/release/bundle/nsis/*.exe
            target/*/release/bundle/nsis/*.exe
            target/release/bundle/nsis-web/*.exe
            target/*/release/bundle/nsis-web/*.exe
            target/release/bundle/*/*.pkg
            target/*/release/bundle/*/*.pkg
            target/release/bundle/*/*.zip
            target/*/release/bundle/*/*.zip
            target/release/bundle/*/*.tar.gz
            target/*/release/bundle/*/*.tar.gz
            target/release/bundle/*/*.tgz
            target/*/release/bundle/*/*.tgz
            target/release/bundle/*.sig
            target/*/release/bundle/*.sig
            target/release/bundle/*/*.sig
            target/*/release/bundle/*/*.sig
            target/release/bundle/latest.json
            target/*/release/bundle/latest.json
            target/release/bundle/*/latest.json
            target/*/release/bundle/*/latest.json
            target/release/bundle/update.json
            target/*/release/bundle/update.json
            target/release/bundle/*/update.json
            target/*/release/bundle/*/update.json
