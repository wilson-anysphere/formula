name: Desktop installer artifact sizes

permissions:
  contents: read

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - "apps/desktop/**"
      - "crates/**"
      - "packages/**"
      - "extensions/**"
      - ".cargo/**"
      - "scripts/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - "rust-toolchain.toml"
      - "package.json"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - ".github/workflows/desktop-bundle-size.yml"
      - ".github/workflows/release.yml"
  pull_request:
    paths:
      - "apps/desktop/**"
      - "crates/**"
      - "packages/**"
      - "extensions/**"
      - ".cargo/**"
      - "scripts/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - "rust-toolchain.toml"
      - "package.json"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - ".github/workflows/desktop-bundle-size.yml"
      - ".github/workflows/release.yml"

concurrency:
  group: desktop-bundle-size-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  # Keep these pins aligned with CI/release so installer artifact size checks match what we ship.
  NODE_VERSION: 22
  WASM_PACK_VERSION: 0.13.1
  TAURI_CLI_VERSION: "2.9.5"
  # Opt-in: bundle Pyodide assets into `apps/desktop/dist` (otherwise Pyodide is downloaded
  # on-demand at runtime and cached in the app data directory).
  FORMULA_BUNDLE_PYODIDE_ASSETS: ${{ vars.FORMULA_BUNDLE_PYODIDE_ASSETS }}

jobs:
  conflict-marker-guard:
    name: "Guard: no merge conflict markers"
    # Pin runner image versions for reproducibility. GitHub's `*-latest` labels move
    # over time, which can cause unexpected workflow failures.
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v4
      - name: Fail if merge conflict markers are present
        run: bash scripts/ci/check-merge-conflict-markers.sh
      - name: "Guard: Rust toolchain pins match rust-toolchain.toml"
        run: bash scripts/ci/check-rust-toolchain-pins.sh
      - name: "Guard: release workflow runner images are pinned (no *-latest)"
        run: bash scripts/ci/check-gha-runner-pins.sh
      - name: "Guard: Node version pins match CI/release workflows"
        run: bash scripts/ci/check-node-version-pins.sh
      - name: "Guard: pnpm version pins match package.json"
        run: bash scripts/ci/check-pnpm-version-pins.sh
      - name: "Guard: wasm-pack version pins match CI/release workflows"
        run: bash scripts/ci/check-wasm-pack-version-pins.sh
      - name: "Guard: Tauri CLI version pins match CI/release workflows"
        run: bash scripts/ci/check-tauri-cli-version-pins.sh

  linux-desktop-bundle-size:
    name: Linux desktop installer artifact sizes
    needs: conflict-marker-guard
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v4

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4
        with:
          # Pin pnpm patch version for determinism (keep in sync with package.json).
          version: 9.0.0

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v4
        with:
          # Keep Node pinned to the same major used by CI/release workflows.
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: "Guard: pinned Tauri CLI version matches Cargo.toml"
        run: node scripts/ci/check-tauri-cli-version.mjs

      - name: Validate desktop compliance artifact bundling config (LICENSE/NOTICE)
        run: node scripts/ci/check-desktop-compliance-artifacts.mjs

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@e97e2d8cc328f1b50210efc529dca0028893a2d9 # v1
        with:
          toolchain: 1.92.0

      - name: Install Rust target (wasm32)
        # Required for wasm-pack builds (desktop renderer / engine WASM).
        run: rustup target add wasm32-unknown-unknown

      # Our dev scripts default to a repo-local CARGO_HOME to avoid cross-agent
      # contention on shared ~/.cargo. In GitHub Actions we prefer the default
      # CARGO_HOME so cargo installs/builds share the same cache.
      - name: Use shared Cargo home for CI caching
        run: echo "CARGO_HOME=$HOME/.cargo" >> "$GITHUB_ENV"

      - name: Cache Rust builds
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2

      - name: Check Cargo.lock is up-to-date (no implicit lockfile updates)
        shell: bash
        run: bash scripts/ci/check-cargo-lock-reproducible.sh

      - name: Fail if preflight modified tracked files
        shell: bash
        run: git diff --exit-code

      - name: Setup Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v5
        with:
          python-version: "3.11"

      - name: Install Linux dependencies (Tauri/WebView + packaging)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            file \
            binutils \
            cpio \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf \
            fakeroot \
            squashfs-tools \
            rpm \
            rpm2cpio

          # Some AppImage tooling requires FUSE2 at runtime. Ubuntu 24.04 renamed the
          # package to `libfuse2t64`; try both, but don't fail the build if neither exists.
          sudo apt-get install -y libfuse2 || sudo apt-get install -y libfuse2t64 || true

      - name: Install JS dependencies
        # Prefer cached pnpm store entries to reduce network flakiness on reruns.
        env:
          # This workflow does not run Playwright tests, so skip the ~GB browser downloads
          # performed by `@playwright/test`'s postinstall script.
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
        run: pnpm install --frozen-lockfile --prefer-offline

      - name: Cache wasm-pack binary
        id: wasm-pack-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          path: ~/.cargo/bin/wasm-pack
          # Include the Rust toolchain pin so Rust upgrades force rebuilding cargo-installed tools.
          key: wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Cache wasm-pack tool downloads (Linux)
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          # wasm-pack downloads wasm-bindgen + binaryen (wasm-opt) into this cache dir.
          path: ~/.cache/.wasm-pack
          key: wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-v${{ env.WASM_PACK_VERSION }}
          restore-keys: |
            wasm-pack-tools-${{ runner.os }}-${{ runner.arch }}-

      - name: Install wasm-pack (required for @formula/engine WASM build)
        # Pinned to match the tagged release workflow so we catch toolchain issues before cutting releases.
        if: steps.wasm-pack-cache.outputs.cache-hit != 'true'
        # Use --force so cache restore-keys (or other CI caches) can't strand a stale/untracked
        # wasm-pack binary that would otherwise block `cargo install` from overwriting it.
        run: cargo install wasm-pack --version ${{ env.WASM_PACK_VERSION }} --locked --force

      - name: Verify wasm-pack version
        shell: bash
        run: |
          set -euo pipefail
          expected="${WASM_PACK_VERSION}"
          actual="$(wasm-pack --version | tr -d '\r' | awk '{print $2}')"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected wasm-pack ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache pinned Tauri CLI binary (cargo-tauri)
        id: tauri-cli-cache
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          path: ~/.cargo/bin/cargo-tauri
          # Include the Rust toolchain pin so Rust upgrades force rebuilding cargo-installed tools.
          key: cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            cargo-tauri-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('rust-toolchain.toml') }}-

      - name: Install pinned Tauri CLI (cargo tauri)
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ${{ env.TAURI_CLI_VERSION }} --locked --force

      - name: Verify Tauri CLI version
        shell: bash
        run: |
          set -euo pipefail
          expected="${TAURI_CLI_VERSION}"
          actual="$(cargo tauri --version | tr -d '\r' | awk '{print $2}')"
          echo "cargo-tauri version: ${actual}"
          if [[ "${actual}" != "${expected}" ]]; then
            echo "Expected cargo-tauri ${expected}, but found ${actual}." >&2
            exit 1
          fi

      - name: Cache Tauri tooling downloads
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          path: ~/.cache/tauri
          key: tauri-tooling-${{ runner.os }}-${{ runner.arch }}-v${{ env.TAURI_CLI_VERSION }}
          restore-keys: |
            tauri-tooling-${{ runner.os }}-${{ runner.arch }}-

      - name: Detect Pyodide version (for caching)
        id: pyodide
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        shell: bash
        run: |
          set -euo pipefail
          version="$(node -e "const fs=require('node:fs'); const src=fs.readFileSync('apps/desktop/scripts/ensure-pyodide-assets.mjs','utf8'); const m=src.match(/const\\s+PYODIDE_VERSION\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/); if(!m) throw new Error('PYODIDE_VERSION not found'); process.stdout.write(m[1]);")"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Restore Pyodide asset cache
        id: pyodide-cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        uses: actions/cache/restore@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Ensure Pyodide assets are present
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1'
        run: node apps/desktop/scripts/ensure-pyodide-assets.mjs

      - name: Save Pyodide asset cache
        if: env.FORMULA_BUNDLE_PYODIDE_ASSETS == '1' && steps.pyodide-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@8b402f58fbc84540c8b491a91e594a4576fec3d7 # v4
        with:
          path: apps/desktop/public/pyodide/v${{ steps.pyodide.outputs.version }}/full/
          key: pyodide-${{ runner.os }}-${{ steps.pyodide.outputs.version }}-${{ hashFiles('apps/desktop/scripts/ensure-pyodide-assets.mjs') }}

      - name: Build desktop bundles (Tauri)
        env:
          # The AppImage tooling used by Tauri is itself distributed as an AppImage.
          # In CI we may not have FUSE2 available, so force AppImages to run in
          # "extract-and-run" mode (safe; does not affect the produced artifacts).
          APPIMAGE_EXTRACT_AND_RUN: "1"
          # `scripts/cargo_agent.sh` defaults `CARGO_PROFILE_RELEASE_CODEGEN_UNITS` to a value
          # based on its job count for stability on multi-agent hosts. Override so this check
          # matches the repo's Cargo.toml release profile (codegen-units = 1), keeping bundle
          # sizes comparable to tagged release builds.
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
        run: cd apps/desktop && bash ../../scripts/cargo_agent.sh tauri build --bundles appimage,deb,rpm

      - name: Verify desktop binary is stripped (no symbols)
        run: python scripts/verify_desktop_binary_stripped.py

      - name: Verify Linux package dependency metadata (deb + rpm)
        run: bash scripts/ci/verify-linux-package-deps.sh

      - name: Verify Linux desktop integration in packages (.deb + .rpm)
        shell: bash
        run: |
          set -euo pipefail
          roots=()
          if [[ -n "${CARGO_TARGET_DIR:-}" ]]; then
            roots+=("${CARGO_TARGET_DIR}")
          fi
          roots+=("apps/desktop/src-tauri/target" "apps/desktop/target" "target")
 
          shopt -s nullglob
          debs=()
          rpms=()
          for root in "${roots[@]}"; do
            [[ -d "${root}" ]] || continue
            debs+=("${root}"/release/bundle/deb/*.deb)
            debs+=("${root}"/*/release/bundle/deb/*.deb)
            rpms+=("${root}"/release/bundle/rpm/*.rpm)
            rpms+=("${root}"/*/release/bundle/rpm/*.rpm)
          done
          shopt -u nullglob
 
          if ((${#debs[@]} > 0)); then mapfile -t debs < <(printf '%s\n' "${debs[@]}" | sort -u); fi
          if ((${#rpms[@]} > 0)); then mapfile -t rpms < <(printf '%s\n' "${rpms[@]}" | sort -u); fi
 
           if ((${#debs[@]} == 0)); then
            echo "::error::Could not find a .deb under any target root (expected <target>/release/bundle/deb/*.deb or <target>/<triple>/release/bundle/deb/*.deb)" >&2
            echo "Searched roots:" >&2
            printf '  - %s\n' "${roots[@]}" >&2
            exit 1
          fi
          if ((${#rpms[@]} == 0)); then
            echo "::error::Could not find a .rpm under any target root (expected <target>/release/bundle/rpm/*.rpm or <target>/<triple>/release/bundle/rpm/*.rpm)" >&2
            echo "Searched roots:" >&2
            printf '  - %s\n' "${roots[@]}" >&2
            exit 1
          fi
 
          deb="${debs[0]}"
          rpm_path="${rpms[0]}"
 
          tmpdir_deb="$(mktemp -d)"
          tmpdir_rpm="$(mktemp -d)"
          cleanup() {
            rm -rf "${tmpdir_deb}" "${tmpdir_rpm}" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT
 
          echo "Validating .deb desktop integration: ${deb}"
          dpkg-deb -x "${deb}" "${tmpdir_deb}"
          python3 scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_deb}"
 
          echo "Validating .rpm desktop integration: ${rpm_path}"
          rpm2cpio "${rpm_path}" | (cd "${tmpdir_rpm}" && cpio -idm --quiet --no-absolute-filenames)
          python3 scripts/ci/verify_linux_desktop_integration.py --package-root "${tmpdir_rpm}"

      - name: Desktop dist asset report
        run: node scripts/desktop_dist_asset_report.mjs --json-out desktop-dist-assets-report.json
        env:
          # Optional: set as GitHub Actions variables to enable gating.
          FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_TOTAL_BUDGET_MB }}
          FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB: ${{ vars.FORMULA_DESKTOP_DIST_SINGLE_FILE_BUDGET_MB }}

      - name: Upload desktop dist asset report (JSON)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: desktop-dist-assets-report
          path: desktop-dist-assets-report.json
          if-no-files-found: ignore

      - name: Smoke test produced AppImage (extract + ldd + arch)
        run: bash scripts/ci/check-appimage.sh

      - name: Validate produced AppImage desktop integration (.desktop + file associations + deep links)
        run: bash scripts/validate-linux-appimage.sh

      - name: Validate produced RPM package payload (rpm -qp)
        run: bash scripts/validate-linux-rpm.sh --no-container

      - name: Report desktop installer artifact sizes
        # If earlier steps fail (dependency install / build), still try to emit an
        # empty report + JSON artifact to aid debugging. When the build succeeds,
        # this step enforces the size gate (if enabled) normally.
        if: always()
        continue-on-error: ${{ failure() }}
        env:
          # Optional: set these as GitHub Actions "Variables" to enable gating.
          # - FORMULA_ENFORCE_BUNDLE_SIZE=1 to fail when any artifact exceeds the limit
          # - FORMULA_BUNDLE_SIZE_LIMIT_MB=50 to adjust the default 50 MB budget
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        shell: bash
        run: |
          set -euo pipefail
          python scripts/desktop_bundle_size_report.py --json desktop-bundle-size-report.json | tee desktop-bundle-size-report.md

      - name: Upload desktop installer artifact size report (JSON)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          # Note: historical name; the report contains per-installer artifact sizes (AppImage/DEB/RPM/etc).
          name: desktop-bundle-size-report
          path: desktop-bundle-size-report.json
          if-no-files-found: warn

      - name: Post bundle size report PR comment
        if: always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        continue-on-error: true
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v7
        env:
          FORMULA_ENFORCE_BUNDLE_SIZE: ${{ vars.FORMULA_ENFORCE_BUNDLE_SIZE }}
          FORMULA_BUNDLE_SIZE_LIMIT_MB: ${{ vars.FORMULA_BUNDLE_SIZE_LIMIT_MB }}
        with:
          script: |
            const fs = require("fs");

            const marker = "<!-- formula-desktop-bundle-size -->";
            const prNumber = context.payload.pull_request.number;

            function isTruthyEnv(val) {
              if (!val) return false;
              const v = String(val).trim().toLowerCase();
              return ["1", "true", "yes", "y", "on"].includes(v);
            }

            function parseLimitMb(val) {
              if (!val || !String(val).trim()) return null;
              const n = Number.parseFloat(String(val).trim());
              if (Number.isNaN(n)) return null;
              return Number.parseInt(String(n), 10);
            }

            let reportMd = "";
            try {
              reportMd = fs.readFileSync("desktop-bundle-size-report.md", "utf8").trim();
            } catch (err) {
              core.warning(`Failed to read desktop-bundle-size-report.md: ${err.message}`);
            }

            let reportJson = null;
            try {
              reportJson = JSON.parse(fs.readFileSync("desktop-bundle-size-report.json", "utf8"));
            } catch (err) {
              core.warning(`Failed to read desktop-bundle-size-report.json: ${err.message}`);
            }

            const rawEnforce = process.env.FORMULA_ENFORCE_BUNDLE_SIZE || "";
            const rawLimit = process.env.FORMULA_BUNDLE_SIZE_LIMIT_MB || "";

            const enforceEnabled =
              reportJson && typeof reportJson.enforce === "boolean"
                ? reportJson.enforce
                : isTruthyEnv(rawEnforce);

            const limitMb =
              reportJson && Number.isInteger(reportJson.limit_mb)
                ? reportJson.limit_mb
                : parseLimitMb(rawLimit) || 50;

            const enforceVal = rawEnforce ? `\`${rawEnforce}\`` : "_(unset)_";
            const limitVal = rawLimit ? `\`${rawLimit}\`` : "_(unset)_";

            const note = `_Enforcement: **${enforceEnabled ? "enabled" : "disabled"}** (FORMULA_ENFORCE_BUNDLE_SIZE=${enforceVal}) Â· Limit: **${limitMb} MB** (FORMULA_BUNDLE_SIZE_LIMIT_MB=${limitVal})_`;

            const bodyParts = [
              marker,
              "",
              note,
              "",
              reportMd || "_No bundle-size report markdown was produced (build may have failed before bundling)._",
              "",
            ];
            const body = bodyParts.join("\n");

            const { owner, repo } = context.repo;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const existing = comments.find((c) => (c.body || "").includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
              core.info(`Updated existing bundle-size comment (id=${existing.id}).`);
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body,
              });
              core.info("Created new bundle-size comment.");
            }
